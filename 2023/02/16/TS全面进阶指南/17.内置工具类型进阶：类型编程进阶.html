<hr>
<p>title: 17.内置工具类型进阶：类型编程进阶<br>date: 2023-02-16 16:29:28<br>tags: TypeScript<br>updated: 更新日期<br>cover:<br>description: TS全面进阶指南<br>categories: TS全面进阶指南<br>highlight_shrink: false</p>
<h2 id="index-false"><a href="#index-false" class="headerlink" title="index: false"></a>index: false</h2><p>此前，我们已经了解了 TypeScript 中内置工具类型的实现原理，以及它们的扩展方向。这一节，我们会在这些基础上逐一实现这些扩展方向。</p>
<p>需要说明的是，本节中的工具类型会更加复杂和烧脑一些，你需要确保已经完全掌握了这一节前的绝大部分知识再来学习本节内容。如果在学习过程中发现有知识点的缺失，可以先回到前面的章节复习、巩固，再学不迟。</p>
<p>另外，这一节中介绍的工具类型绝大部分是具有实际应用场景的，如果你发现某一个工具类型恰好匹配了你的需求，不妨在自己的项目中复制一份。随着不断的积累，你会发现，你拥有了一个最适合自己的工具类型合集！</p>
<blockquote>
<p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F13-advanced-builtin-tool-types">Advanced Builtin Tool Types</a></p>
</blockquote>
<h2 id="属性修饰进阶"><a href="#属性修饰进阶" class="headerlink" title="属性修饰进阶"></a>属性修饰进阶</h2><p>在内置工具类型一节中，对属性修饰工具类型的进阶主要分为这么几个方向：</p>
<ul>
<li>深层的属性修饰；</li>
<li>基于已知属性的部分修饰，以及基于属性类型的部分修饰。</li>
</ul>
<p>首先是深层属性修饰，还记得我们在 infer 关键字一节首次接触到递归的工具类型吗？</p>
<pre><code class="lang-typescript">type PromiseValue&lt;T&gt; = T extends Promise&lt;infer V&gt; ? PromiseValue&lt;V&gt; : T
</code></pre>
<p>可以看到，此时我们只是在条件类型成立时，再次调用了这个工具类型而已。在某一次递归到条件类型不成立时，就会直接返回这个类型值。那么对于 Partial、Required，其实我们也可以进行这样地处理：</p>
<pre><code class="lang-typescript">export type DeepPartial&lt;T extends object&gt; = {
  [K in keyof T]?: T[K] extends object ? DeepPartial&lt;T[K]&gt; : T[K]
}
</code></pre>
<p>简单起见，我们直接使用了 object 作为泛型约束与条件，这意味着也有可能传入函数、数组等类型。但毕竟我们对这个类型知根知底，就可以假设只会传入对象结构，因此也只需要对对象类型进行处理了。</p>
<p>为了更直观地验证它的效果，我们使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ftsd">tsd</a> 这一工具类型单元测试库来进行验证，效果大概是这样：</p>
<pre><code class="lang-typescript">import { expectType } from &#39;tsd&#39;

type DeepPartialStruct = DeepPartial&lt;{
  foo: string
  nested: {
    nestedFoo: string
    nestedBar: {
      nestedBarFoo: string
    }
  }
}&gt;

expectType&lt;DeepPartialStruct&gt;({
  foo: &#39;bar&#39;,
  nested: {},
})

expectType&lt;DeepPartialStruct&gt;({
  nested: {
    nestedBar: {},
  },
})

expectType&lt;DeepPartialStruct&gt;({
  nested: {
    nestedBar: {
      nestedBarFoo: undefined,
    },
  },
})
</code></pre>
<p>在 expectType 的泛型坑位中传入一个类型，然后再传入一个值，就可以验证这个值是否符合泛型类型了。</p>
<p>类似的，我们还可以实现其他进行递归属性修饰的工具类型，展示如下：</p>
<pre><code class="lang-typescript">export type DeepPartial&lt;T extends object&gt; = {
  [K in keyof T]?: T[K] extends object ? DeepPartial&lt;T[K]&gt; : T[K]
}

export type DeepRequired&lt;T extends object&gt; = {
  [K in keyof T]-?: T[K] extends object ? DeepRequired&lt;T[K]&gt; : T[K]
}

// 也可以记作 DeepImmutable
export type DeepReadonly&lt;T extends object&gt; = {
  readonly [K in keyof T]: T[K] extends object ? DeepReadonly&lt;T[K]&gt; : T[K]
}

export type DeepMutable&lt;T extends object&gt; = {
  -readonly [K in keyof T]: T[K] extends object ? DeepMutable&lt;T[K]&gt; : T[K]
}
</code></pre>
<p>另外，在内置工具类型一节的结构工具类型中，存在一个从联合类型中剔除 <code>null | undefined</code> 的工具类型 NonNullable：</p>
<pre><code class="lang-typescript">type NonNullable&lt;T&gt; = T extends null | undefined ? never : T
</code></pre>
<p>在对象结构中我们也常声明类型为 <code>string | null</code> 的形式，代表了“<strong>这里有值，但可能是空值</strong>”。此时，我们也可以将其等价为一种属性修饰（Nullable 属性，前面则是 Optional / Readonly 属性）。因此，我们也可以像访问性修饰工具类型那样，实现一个 DeepNonNullable 来递归剔除所有属性的 null 与 undefined：</p>
<pre><code class="lang-typescript">type NonNullable&lt;T&gt; = T extends null | undefined ? never : T

export type DeepNonNullable&lt;T extends object&gt; = {
  [K in keyof T]: T[K] extends object
    ? DeepNonNullable&lt;T[K]&gt;
    : NonNullable&lt;T[K]&gt;
}
</code></pre>
<p>当然，就像 Partial 与 Required 的关系一样，DeepNonNullable 也有自己的另一半：DeepNullable：</p>
<pre><code class="lang-typescript">export type Nullable&lt;T&gt; = T | null

export type DeepNullable&lt;T extends object&gt; = {
  [K in keyof T]: T[K] extends object ? DeepNullable&lt;T[K]&gt; : Nullable&lt;T[K]&gt;
}
</code></pre>
<blockquote>
<p>需要注意的是，DeepNullable 和 DeepNonNullable 需要在开启 <code>--strictNullChecks</code> 下才能正常工作。</p>
</blockquote>
<p>搞定了递归属性修饰，接着就是<strong>基于已知属性进行部分修饰了</strong>。这其实也很简单。你想，如果我们要让一个对象的三个已知属性为可选的，那只要把这个对象拆成 A、B 两个对象结构，分别由三个属性和其他属性组成。然后让对象 A 的属性全部变为可选的，和另外一个对象 B 组合起来，不就行了吗？</p>
<p>拆开来描述一下这句话，看看这里都用到了哪些知识：</p>
<ul>
<li>拆分对象结构，那不就是内置工具类型一节中讲到的<strong>结构工具类型</strong>，即 Pick 与 Omit？</li>
<li>三个属性的对象全部变为可选，那不就是属性修饰？岂不是可以直接用上面刚学到的<strong>递归属性修饰</strong>？</li>
<li>组合两个对象类型，也就意味着得到一个同时符合这两个对象类型的新结构，那不就是<strong>交叉类型</strong>？</li>
</ul>
<p>分析出了需要用到的工具和方法，那执行起来就简单多了。这也是使用最广泛的一种类型编程思路：<strong>将复杂的工具类型，拆解为由基础工具类型、类型工具的组合</strong>。</p>
<p>直接来看基于已知属性的部分修饰，MarkPropsAsOptional 会将一个对象的部分属性标记为可选：</p>
<pre><code class="lang-typescript">export type MarkPropsAsOptional&lt;
  T extends object,
  K extends keyof T = keyof T
&gt; = Partial&lt;Pick&lt;T, K&gt;&gt; &amp; Omit&lt;T, K&gt;
</code></pre>
<p>T 为需要处理的对象类型，而 K 为需要标记为可选的属性。由于此时 K 必须为 T 内部的属性，因此我们将其约束为 keyof T，即对象属性组成的字面量联合类型。同时为了让它能够直接代替掉 Partial，我们为其指定默认值也为 keyof T，这样在不传入第二个泛型参数时，它的表现就和 Partial 一致，即全量的属性可选。</p>
<p>而其组成中，<code>Partial&lt;Pick&lt;T, K&gt;&gt;</code> 为需要标记为可选的属性组成的对象子结构，<code>Omit&lt;T, K&gt;</code> 则为不需要处理的部分，使用交叉类型将其组合即可。我们验证下效果：</p>
<pre><code class="lang-typescript">type MarkPropsAsOptionalStruct = MarkPropsAsOptional&lt;
  {
    foo: string
    bar: number
    baz: boolean
  },
  &#39;bar&#39;
&gt;
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25c9cbf92f7f4e6db685f61fdc6dd608~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>啊哦，这可不好看出来具体效果。此时我们可以引入一个辅助的工具类型，我称其为 Flatten，对于这种交叉类型的结构，Flatten 能够将它展平为单层的对象结构。而它的实现也很简单，就是复制一下结构罢了：</p>
<pre><code class="lang-typescript">export type Flatten&lt;T&gt; = { [K in keyof T]: T[K] }

export type MarkPropsAsOptional&lt;
  T extends object,
  K extends keyof T = keyof T
&gt; = Flatten&lt;Partial&lt;Pick&lt;T, K&gt;&gt; &amp; Omit&lt;T, K&gt;&gt;
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4800d32ded6f4b45bdc72f70c05df0d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>现在它就直观多了，那我们也就无需再进行实际验证了。</p>
<blockquote>
<p>在这里你其实也可以使用 <code>DeepPartial&lt;Pick&lt;T, K&gt;&gt;</code>，来把这些属性标记为深层的可选状态。</p>
</blockquote>
<p>我们来实现其它类型的部分修饰：</p>
<pre><code class="lang-typescript">export type MarkPropsAsRequired&lt;
  T extends object,
  K extends keyof T = keyof T
&gt; = Flatten&lt;Omit&lt;T, K&gt; &amp; Required&lt;Pick&lt;T, K&gt;&gt;&gt;

export type MarkPropsAsReadonly&lt;
  T extends object,
  K extends keyof T = keyof T
&gt; = Flatten&lt;Omit&lt;T, K&gt; &amp; Readonly&lt;Pick&lt;T, K&gt;&gt;&gt;

export type MarkPropsAsMutable&lt;
  T extends object,
  K extends keyof T = keyof T
&gt; = Flatten&lt;Omit&lt;T, K&gt; &amp; Mutable&lt;Pick&lt;T, K&gt;&gt;&gt;

export type MarkPropsAsNullable&lt;
  T extends object,
  K extends keyof T = keyof T
&gt; = Flatten&lt;Omit&lt;T, K&gt; &amp; Nullable&lt;Pick&lt;T, K&gt;&gt;&gt;

export type MarkPropsAsNonNullable&lt;
  T extends object,
  K extends keyof T = keyof T
&gt; = Flatten&lt;Omit&lt;T, K&gt; &amp; NonNullable&lt;Pick&lt;T, K&gt;&gt;&gt;
</code></pre>
<p>而对于按照值类型的部分修饰，比如标记所有函数类型属性为可选，其实和这里是一样的思路：<strong>拆分-处理-组合</strong>，只不过我们此前使用基于键名裁剪的 Pick、Omit，现在我们需要基于键值类型裁剪的 PickByValueType、OmitByValueType 了。而在接下来的结构工具类型进阶中，我们会了解到如何<strong>基于键值类型去裁剪结构</strong>。</p>
<p>这一节介绍的属性修饰工具类型在日常开发中也是非常常用的，如一个结构，在被用作多个 React 组件的属性类型时，可能存在一些属性修饰的差异。此时就可以基于这些工具类型，基于源头的接口结构做定制处理，避免多次声明基本重复的类型结构。</p>
<h2 id="结构工具类型进阶"><a href="#结构工具类型进阶" class="headerlink" title="结构工具类型进阶"></a>结构工具类型进阶</h2><p>前面对结构工具类型主要给出了两个进阶方向：</p>
<ul>
<li>基于键值类型的 Pick 与 Omit；</li>
<li>子结构的互斥处理。</li>
</ul>
<p>首先是基于键值类型的 Pick 与 Omit，我们就称之为 PickByValueType 好了。它的实现方式其实还是类似部分属性修饰中那样，将对象拆分为两个部分，处理完毕再组装。只不过，现在我们无法预先确定要拆分的属性了，而是需要<strong>基于期望的类型去拿到所有此类型的属性名</strong>，如想 Pick 出所有函数类型的值，那就要先拿到所有的函数类型属性名。先来一个 FunctionKeys 工具类型：</p>
<pre><code class="lang-typescript">type FuncStruct = (...args: any[]) =&gt; any

type FunctionKeys&lt;T extends object&gt; = {
  [K in keyof T]: T[K] extends FuncStruct ? K : never
}[keyof T]
</code></pre>
<p><code>{}[keyof T]</code> 这个写法我们是第一次见，但我们可以拆开来看，先看看前面的 <code>{ [K in keyof T]: T[K] extends FuncStruct ? K : never; }</code> 部分，为何在条件类型成立时它返回了键名 K，而非索引类型查询 <code>T[K]</code> ？</p>
<pre><code class="lang-typescript">type Tmp&lt;T extends object&gt; = {
  [K in keyof T]: T[K] extends FuncStruct ? K : never
}

type Res = Tmp&lt;{
  foo: () =&gt; void
  bar: () =&gt; number
  baz: number
}&gt;

type ResEqual = {
  foo: &#39;foo&#39;
  bar: &#39;bar&#39;
  baz: never
}
</code></pre>
<p>在 Res（等价于 ResEqual）中，我们获得了一个<strong>属性名-属性名字面量类型</strong>的结构，对于非函数类型的属性，其值为 never。然后，我们加上 <code>[keyof T]</code> 这一索引类型查询 + keyof 操作符的组合：</p>
<pre><code class="lang-typescript">type WhatWillWeGet = Res[keyof Res] // &quot;foo&quot; | &quot;bar&quot;
</code></pre>
<p>我们神奇地获得了所有函数类型的属性名！这又是如何实现的呢？其实就是我们此前学习过的，当索引类型查询中使用了一个联合类型时，它会使用类似分布式条件类型的方式，将这个联合类型的成员依次进行访问，然后再最终组合起来，上面的例子可以这么简化：</p>
<pre><code class="lang-typescript">type WhatWillWeGetEqual1 = Res[&#39;foo&#39; | &#39;bar&#39; | &#39;baz&#39;]
type WhatWillWeGetEqual2 = Res[&#39;foo&#39;] | Res[&#39;bar&#39;] | Res[&#39;baz&#39;]
type WhatWillWeGetEqual3 = &#39;foo&#39; | &#39;bar&#39; | never
</code></pre>
<p>通过这一方式，我们就能够获取到符合预期类型的属性名了。如果希望抽象“基于键值类型查找属性”名这么个逻辑，我们就需要对 FunctionKeys 的逻辑进行封装，即<strong>将预期类型也作为泛型参数</strong>，由外部传入：</p>
<pre><code class="lang-typescript">type ExpectedPropKeys&lt;T extends object, ValueType&gt; = {
  [Key in keyof T]-?: T[Key] extends ValueType ? Key : never
}[keyof T]

type FunctionKeys&lt;T extends object&gt; = ExpectedPropKeys&lt;T, FuncStruct&gt;

expectType&lt;
  FunctionKeys&lt;{
    foo: () =&gt; void
    bar: () =&gt; number
    baz: number
  }&gt;
&gt;(&#39;foo&#39;)

expectType&lt;
  FunctionKeys&lt;{
    foo: () =&gt; void
    bar: () =&gt; number
    baz: number
  }&gt;
  // 报错，因为 baz 不是函数类型属性
&gt;(&#39;baz&#39;)
</code></pre>
<p>注意，为了避免可选属性对条件类型语句造成干扰，这里我们使用 <code>-?</code> 移除了所有可选标记。</p>
<p>既然我们现在可以拿到对应类型的属性名，那么把这些属性交给 Pick，不就可以得到由这些属性组成的子结构了？</p>
<pre><code class="lang-typescript">export type PickByValueType&lt;T extends object, ValueType&gt; = Pick&lt;
  T,
  ExpectedPropKeys&lt;T, ValueType&gt;
&gt;

expectType&lt;PickByValueType&lt;{ foo: string; bar: number }, string&gt;&gt;({
  foo: &#39;linbudu&#39;,
})

expectType&lt;
  PickByValueType&lt;{ foo: string; bar: number; baz: boolean }, string | number&gt;
&gt;({
  foo: &#39;linbudu&#39;,
  bar: 599,
})
</code></pre>
<p>OmitByValueType 也是类似的，我们只需要一个和 ExpectedPropKeys 作用相反的工具类型即可，比如来个 FilteredPropKeys，只需要调换条件类型语句结果的两端即可：</p>
<pre><code class="lang-typescript">type FilteredPropKeys&lt;T extends object, ValueType&gt; = {
  [Key in keyof T]-?: T[Key] extends ValueType ? never : Key
}[keyof T]

export type OmitByValueType&lt;T extends object, ValueType&gt; = Pick&lt;
  T,
  FilteredPropKeys&lt;T, ValueType&gt;
&gt;

expectType&lt;OmitByValueType&lt;{ foo: string; bar: number }, string&gt;&gt;({
  bar: 599,
})

expectType&lt;
  OmitByValueType&lt;{ foo: string; bar: number; baz: boolean }, string | number&gt;
&gt;({
  baz: true,
})
</code></pre>
<p>或者，如果你想把 ExpectedPropKeys 和 FilteredPropKeys 合并在一起，其实也很简单，只是需要引入第三个泛型参数来控制返回结果：</p>
<pre><code class="lang-typescript">type Conditional&lt;Value, Condition, Resolved, Rejected&gt; = Value extends Condition
  ? Resolved
  : Rejected

export type ValueTypeFilter&lt;
  T extends object,
  ValueType,
  Positive extends boolean
&gt; = {
  [Key in keyof T]-?: T[Key] extends ValueType
    ? Conditional&lt;Positive, true, Key, never&gt;
    : Conditional&lt;Positive, true, never, Key&gt;
}[keyof T]

export type PickByValueType&lt;T extends object, ValueType&gt; = Pick&lt;
  T,
  ValueTypeFilter&lt;T, ValueType, true&gt;
&gt;

export type OmitByValueType&lt;T extends object, ValueType&gt; = Pick&lt;
  T,
  ValueTypeFilter&lt;T, ValueType, false&gt;
&gt;
</code></pre>
<p>看起来好像很完美，但这里基于条件类型的比较是否让你想到了某个特殊情况？即在联合类型的情况下，<code>1 | 2 extends 1 | 2 | 3</code>（通过泛型参数传入） 会被视为是合法的，这是由于分布式条件类型的存在。而有时我们希望对联合类型的比较是全等的比较，还记得我们说怎么禁用分布式条件类型吗？让它不满足裸类型参数这一条即可：</p>
<pre><code class="lang-typescript">type Wrapped&lt;T&gt; = [T] extends [boolean] ? &#39;Y&#39; : &#39;N&#39;
</code></pre>
<p>在这里我们也只需要简单进行改动即可：</p>
<pre><code class="lang-typescript">type StrictConditional&lt;Value, Condition, Resolved, Rejected&gt; = [Value] extends [
  Condition
]
  ? Resolved
  : Rejected
</code></pre>
<p>看起来好像没问题，但这里其实不够完美！比如下面这种情况：</p>
<pre><code class="lang-typescript">type Res1 = StrictConditional&lt;1 | 2, 1 | 2 | 3, true, false&gt; // true
</code></pre>
<p>当条件不再是一个简单的单体类型，而是一个联合类型时，我们使用数组的方式就产生问题了。因为 <code>Array&lt;1 | 2&gt; extends Array&lt;1 | 2 | 3&gt;</code> 就是合法的，<strong>第一个数组中的可能元素类型均被第二个数组的元素类型包含了，无论如何都是其子类型</strong>。</p>
<p>那么现在应该怎么办？其实只要反过来看，既然 <code>Array&lt;1 | 2&gt; extends Array&lt;1 | 2 | 3&gt;</code> 成立，那么 <code>Array&lt;1 | 2 | 3&gt; extends Array&lt;1 | 2&gt;</code> 肯定是不成立的，我们只要再加一个反方向的比较即可：</p>
<pre><code class="lang-typescript">type StrictConditional&lt;A, B, Resolved, Rejected, Fallback = never&gt; = [
  A
] extends [B]
  ? [B] extends [A]
    ? Resolved
    : Rejected
  : Fallback
</code></pre>
<p>在这种情况下 Value 和 Condition 的界限就比较模糊了，我们只是在比较两个类型是否严格相等，并没有值和表达式的概念了，因此就使用 A、B 来简称。</p>
<p>此时结果就符合预期了，需要联合类型完全一致：</p>
<pre><code class="lang-typescript">type Res1 = StrictConditional&lt;1 | 2, 1 | 2 | 3, true, false&gt; // false
type Res2 = StrictConditional&lt;1 | 2 | 3, 1 | 2, true, false, false&gt; // false
type Res3 = StrictConditional&lt;1 | 2, 1 | 2, true, false&gt; // true
</code></pre>
<p>应用到 TypeFilter 中：</p>
<pre><code class="lang-typescript">export type StrictValueTypeFilter&lt;
  T extends object,
  ValueType,
  Positive extends boolean = true
&gt; = {
  [Key in keyof T]-?: StrictConditional&lt;
    ValueType,
    T[Key],
    // 为了避免嵌套太多工具类型，这里就不使用 Conditional 了
    Positive extends true ? Key : never,
    Positive extends true ? never : Key,
    Positive extends true ? never : Key
  &gt;
}[keyof T]

export type StrictPickByValueType&lt;T extends object, ValueType&gt; = Pick&lt;
  T,
  StrictValueTypeFilter&lt;T, ValueType&gt;
&gt;

expectType&lt;
  StrictPickByValueType&lt;{ foo: 1; bar: 1 | 2; baz: 1 | 2 | 3 }, 1 | 2&gt;
&gt;({
  bar: 1,
})

export type StrictOmitByValueType&lt;T extends object, ValueType&gt; = Pick&lt;
  T,
  StrictValueTypeFilter&lt;T, ValueType, false&gt;
&gt;

expectType&lt;
  StrictOmitByValueType&lt;{ foo: 1; bar: 1 | 2; baz: 1 | 2 | 3 }, 1 | 2&gt;
&gt;({
  foo: 1,
  baz: 3,
})
</code></pre>
<p>需要注意的是，由于 StrictOmitByValueType 需要的是<strong>不符合类型的属性</strong>，因此这里 StrictConditional 的 Fallback 泛型参数也需要传入 Key （即第五个参数中的 <code>Positive extends true ? never : Key</code>），同时整体应当基于 Pick 来实现。</p>
<p>对于基于属性类型的结构工具类型就到这里，这一部分可能需要你先稍微放慢速度，好好理解一番。因为并不完全是我们此前了解到的知识，比如分布式条件类型中，我们并没有说到条件为联合类型时可能出现的问题。这是因为脱离实际使用去讲，很难建立并加深你对这一场景的印象，但我想现在你已经深刻记住它了。</p>
<p>接下来是基于结构的互斥工具类型。想象这样一个场景，假设我们有一个用于描述用户信息的对象结构，除了共有的一些基础结构以外，VIP 用户和普通用户、游客这三种类型的用户各自拥有一些独特的字段，如 vipExpires 代表 VIP 过期时间，仅属于 VIP 用户，promotionUsed 代表已领取过体验券，属于普通用户，而 refererType 代表跳转来源，属于游客。</p>
<p>先来看看如何声明一个接口，它要么拥有 vipExpires，要么拥有 promotionUsed 字段，而不能同时拥有这两个字段。你可能会首先想到使用联合类型？</p>
<pre><code class="lang-typescript">interface VIP {
  vipExpires: number
}

interface CommonUser {
  promotionUsed: boolean
}

type User = VIP | CommonUser
</code></pre>
<p>很遗憾，这种方式并不会约束“不能同时拥有”这个条件：</p>
<pre><code class="lang-typescript">const user1: User = {
  vipExpires: 599,
  promotionUsed: false,
}
</code></pre>
<p>为了表示不能同时拥有，实际上我们应该使用 never 类型来标记一个属性。这里我们直接看完整的实现：</p>
<pre><code class="lang-typescript">export type Without&lt;T, U&gt; = { [P in Exclude&lt;keyof T, keyof U&gt;]?: never }

export type XOR&lt;T, U&gt; = (Without&lt;T, U&gt; &amp; U) | (Without&lt;U, T&gt; &amp; T)

type XORUser = XOR&lt;VIP, CommonUser&gt;

expectType&lt;XORUser&gt;({
  vipExpires: 0,
})

expectType&lt;XORUser&gt;({
  promotionUsed: false,
})

// 报错，至少需要一个
// @ts-expect-error
expectType&lt;XORUser&gt;({})

// 报错，不允许同时拥有
// @ts-expect-error
expectType&lt;XORUser&gt;({
  promotionUsed: false,
  vipExpires: 0,
})
</code></pre>
<p>对 Without 做进一步展开可以看到，它其实就是将声明了一个不变的原属性+为 never 的其他属性的接口：</p>
<pre><code class="lang-typescript">// {
//    vipExpires?: never;
// }
type Tmp1 = Flatten&lt;Without&lt;VIP, CommonUser&gt;&gt;
// {
//    vipExpires?: never;
//    promotionUsed: boolean;
// }
type Tmp2 = Flatten&lt;Tmp1 &amp; CommonUser&gt;
</code></pre>
<p>再通过联合类型的合并，这样一来 XORUser 就满足了“至少实现 VIP / CommonUser 这两个接口中的一个”，“不能同时实现 VIP / CommonUser ”这两个条件。如果加上游客类型实现三个互斥属性，也只需要额外嵌套一层：</p>
<pre><code class="lang-typescript">interface Visitor {
  refererType: RefererType
}

// 联合类型会自动合并重复的部分
type XORUser = XOR&lt;VIP, XOR&lt;CommonUser, Visitor&gt;&gt;
</code></pre>
<p>我们还可以使用互斥类型实现绑定效果，即要么同时拥有 A、B 属性，要么一个属性都没有：</p>
<pre><code class="lang-typescript">type XORStruct = XOR&lt;
  {},
  {
    foo: string
    bar: number
  }
&gt;

// 没有 foo、bar
expectType&lt;XORStruct&gt;({})

// 同时拥有 foo、bar
expectType&lt;XORStruct&gt;({
  foo: &#39;linbudu&#39;,
  bar: 599,
})
</code></pre>
<p>互斥工具类型在很多实战场景下都有重要意义，它在联合类型的基础上添加了属性间的互斥逻辑，现在你可以让你的接口结构更加精确了！</p>
<h2 id="集合工具类型进阶"><a href="#集合工具类型进阶" class="headerlink" title="集合工具类型进阶"></a>集合工具类型进阶</h2><p>在集合工具类型中我们给到的进阶方向，其实就是从一维原始类型集合，扩展二维的对象类型，在对象类型之间进行交并补差集的运算，以及对同名属性的各种处理情况。</p>
<p>对于对象类型的交并补差集，我们仍然沿用“降级”的处理思路，把它简化为可以用基础工具类型处理的问题即可。在这里，对象类型的交并补差集基本上可以降维到对象属性名集合的交并补差集问题，比如交集就是两个对象属性名的交集，使用属性名的交集访问其中一个对象，就可以获得对象之间的交集结构（不考虑同名属性冲突下）。</p>
<p>复习一下前面的一维集合：</p>
<pre><code class="lang-typescript">// 并集
export type Concurrence&lt;A, B&gt; = A | B

// 交集
export type Intersection&lt;A, B&gt; = A extends B ? A : never

// 差集
export type Difference&lt;A, B&gt; = A extends B ? never : A

// 补集
export type Complement&lt;A, B extends A&gt; = Difference&lt;A, B&gt;
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00425dd09153488ca22b08c2c94a27c4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>我们对应地实现对象属性名的版本：</p>
<pre><code class="lang-typescript">// 使用更精确的对象类型描述结构
export type PlainObjectType = Record&lt;string, any&gt;

// 属性名并集
export type ObjectKeysConcurrence&lt;
  T extends PlainObjectType,
  U extends PlainObjectType
&gt; = keyof T | keyof U

// 属性名交集
export type ObjectKeysIntersection&lt;
  T extends PlainObjectType,
  U extends PlainObjectType
&gt; = Intersection&lt;keyof T, keyof U&gt;

// 属性名差集
export type ObjectKeysDifference&lt;
  T extends PlainObjectType,
  U extends PlainObjectType
&gt; = Difference&lt;keyof T, keyof U&gt;

// 属性名补集
export type ObjectKeysComplement&lt;
  T extends U,
  U extends PlainObjectType
&gt; = Complement&lt;keyof T, keyof U&gt;
</code></pre>
<p>对于交集、补集、差集，我们可以直接使用属性名的集合来实现对象层面的版本：</p>
<pre><code class="lang-typescript">export type ObjectIntersection&lt;
  T extends PlainObjectType,
  U extends PlainObjectType
&gt; = Pick&lt;T, ObjectKeysIntersection&lt;T, U&gt;&gt;

export type ObjectDifference&lt;
  T extends PlainObjectType,
  U extends PlainObjectType
&gt; = Pick&lt;T, ObjectKeysDifference&lt;T, U&gt;&gt;

export type ObjectComplement&lt;T extends U, U extends PlainObjectType&gt; = Pick&lt;
  T,
  ObjectKeysComplement&lt;T, U&gt;
&gt;
</code></pre>
<p>需要注意的是在 ObjectKeysComplement 与 ObjectComplement 中，<code>T extends U</code> 意味着 T 是 U 的子类型，但在属性组成的集合类型中却相反，<strong>U 的属性联合类型是 T 的属性联合类型的子类型</strong>，因为既然 T 是 U 的子类型，那很显然 T 所拥有的的属性会更多嘛。</p>
<p>而对于并集，就不能简单使用属性名并集版本了，因为使用联合类型实现，我们并不能控制<strong>同名属性的优先级</strong>，比如我到底是保持原对象属性类型呢，还是使用新对象属性类型？</p>
<p>还记得我们在 MarkPropsAsOptional、PickByValueType 中使用的方式吗？将一个对象拆分成数个子结构，处理各个子结构，再将它们合并。那么对于合并两个对象的情况，其实就是两个对象各自特有的部分加上同名属性组成的部分。</p>
<p>对于 T、U 两个对象，假设以 U 的同名属性类型优先，思路会是这样的：</p>
<ul>
<li>T 比 U 多的部分：T 相对于 U 的差集，<code>ObjectDifference&lt;T, U&gt;</code></li>
<li>U 比 T 多的部分：U 相对于 T 的差集，<code>ObjectDifference&lt;U, T&gt;</code></li>
<li>T 与 U 的交集，由于 U 的优先级更高，在交集处理中将 U 作为原集合， T 作为后传入的集合，<code>ObjectIntersection&lt;U, T&gt;</code></li>
</ul>
<p>我们就得到了 Merge：</p>
<pre><code class="lang-typescript">type Merge&lt;
  T extends PlainObjectType,
  U extends PlainObjectType
  // T 比 U 多的部分，加上 T 与 U 交集的部分(类型不同则以 U 优先级更高，再加上 U 比 T 多的部分即可
&gt; = ObjectDifference&lt;T, U&gt; &amp; ObjectIntersection&lt;U, T&gt; &amp; ObjectDifference&lt;U, T&gt;
</code></pre>
<p>如果要保证原对象优先级更高，那么只需要在交集处理中将 T 视为原集合，U 作为后传入的集合：</p>
<pre><code class="lang-typescript">type Assign&lt;
  T extends PlainObjectType,
  U extends PlainObjectType
  // T 比 U 多的部分，加上 T 与 U 交集的部分(类型不同则以 T 优先级更高，再加上 U 比 T 多的部分即可
&gt; = ObjectDifference&lt;T, U&gt; &amp; ObjectIntersection&lt;T, U&gt; &amp; ObjectDifference&lt;U, T&gt;
</code></pre>
<p>除了简单粗暴地完全合并以外，我们还可以实现不完全的并集，即使用对象 U 的属性类型覆盖对象 T 中的同名属性类型，但<strong>不会将 U 独特的部分</strong>合并过来：</p>
<pre><code class="lang-typescript">type Override&lt;
  T extends PlainObjectType,
  U extends PlainObjectType
  // T 比 U 多的部分，加上 T 与 U 交集的部分(类型不同则以 U 优先级更高（逆并集）)
&gt; = ObjectDifference&lt;T, U&gt; &amp; ObjectIntersection&lt;U, T&gt;
</code></pre>
<p>这样，我们完成了从一维集合到二维集合的跨越。你也可以探索更多样的情况，比如两个对象各自独有部分组成的新集合（<strong>即从并集中剔除掉交集</strong>）就是一个很适合自己动手巩固印象的好例子。</p>
<h2 id="模式匹配工具类型进阶"><a href="#模式匹配工具类型进阶" class="headerlink" title="模式匹配工具类型进阶"></a>模式匹配工具类型进阶</h2><p>在内置工具类型一节中，我们对模式匹配工具类型的进阶方向其实只有深层嵌套这么一种，特殊位置的 infer 处理其实大部分时候也是通过深层嵌套实现，比如此前我们实现了提取函数的首个参数类型：</p>
<pre><code class="lang-typescript">type FirstParameter&lt;T extends FunctionType&gt; = T extends (
  arg: infer P,
  ...args: any
) =&gt; any
  ? P
  : never
</code></pre>
<p>要提取最后一个参数类型则可以这样：</p>
<pre><code class="lang-typescript">type FunctionType = (...args: any) =&gt; any

type LastParameter&lt;T extends FunctionType&gt; = T extends (arg: infer P) =&gt; any
  ? P
  : T extends (...args: infer R) =&gt; any
  ? R extends [...any, infer Q]
    ? Q
    : never
  : never

type FuncFoo = (arg: number) =&gt; void
type FuncBar = (...args: string[]) =&gt; void
type FuncBaz = (arg1: string, arg2: boolean) =&gt; void

type FooLastParameter = LastParameter&lt;FuncFoo&gt; // number
type BarLastParameter = LastParameter&lt;FuncBar&gt; // string
type BazLastParameter = LastParameter&lt;FuncBaz&gt; // boolean
</code></pre>
<p>这也是模式匹配中常用的一种方法，通过 infer 提取到某一个结构，然后再对这个结构进行 infer 提取。</p>
<p>我们在此前曾经讲到一个提取 Promise 内部值类型的工具类型 PromiseValue， TypeScript 内置工具类型中也存在这么一个作用的工具类型，并且它的实现要更为严谨：</p>
<pre><code class="lang-typescript">type Awaited&lt;T&gt; = T extends null | undefined
  ? T
  : T extends object &amp; { then(onfulfilled: infer F): any }
  ? F extends (value: infer V, ...args: any) =&gt; any
    ? Awaited&lt;V&gt;
    : never
  : T
</code></pre>
<p>首先你会发现，在这里 Awaited 并非通过 <code>Promise&lt;infer V&gt;</code> 来提取函数类型，而是通过 <code>Promise.then</code> 方法提取，首先提取到 then 方法中的函数类型，再通过这个函数类型的首个参数来提取出实际的值。</p>
<p>更严谨地来说，PromiseValue 和 Awaited 并不应该放在一起比较，前者就只想提取 <code>Promise&lt;void&gt;</code> 这样结构的内部类型，后者则像在类型的层面执行了 <code>await Promise.then()</code> 之后的返回值类型。同样的，这里也用到了 infer 伴随结构转化的例子。</p>
<p>对于<strong>内置模式匹配工具类型的进阶</strong>我们暂时只进行到这里，在后续的漫谈篇中，我们会不再拘束于“内置”，而是会更新更多复杂的模式匹配工具类型。</p>
<h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>这一节我们了解了属性修饰、结构、集合、模式匹配这四大类的工具类型进阶，也通过这些进阶类型了解到了常用的类型编程方式，如<strong>对一个对象结构拆分为多个子结构再分别处理</strong>，将<strong>复杂类型降维到基础类型再逐个击破</strong>，以及<strong>在嵌套的条件类型中基于 infer 多次修改类型结构</strong>来提取最终需要的类型。最重要的是，这些思路不仅仅会用在这一节的工具类型实现里，当你以后面对更复杂的场景需要从头写一个工具类型时，也完全可以使用，不会再无从下手了。</p>
<p>至此，我们就完成了对 TypeScript 基本类型能力的学习。一路走来甚是不易，我们用了 16 节，总计约 7w 字的内容，来完成对 TypeScript 核心类型能力的入门、进阶、归纳与实战。从基本的类型标注到内置类型的使用，从掌握类型工具到类型系统的深入探索，从工具类型入门到进阶再到整理出类型编程的 4 大范式（访问性修饰、结构、集合以及模式匹配）。</p>
<p>对于类型编程部分，我想带给你的最重要收获其实就是，<strong>你不会再畏惧眼花缭乱的类型编程了</strong>。正如始终贯穿这几节的核心理念，<strong>无论多复杂的类型编程，最终都可以拆分为数个基础的工具类型来实现</strong>，你需要锻炼的就是拆分的思路。</p>
<p>下一节我们还要继续接触类型。先别激动，接下来的类型要更好玩有趣一些，它是 TypeScript 在 4.1 版本引入的重磅特性——模板字符串类型，我们会用两节的内容带你完成相关学习。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="RequiredKeys、OptionalKeys"><a href="#RequiredKeys、OptionalKeys" class="headerlink" title="RequiredKeys、OptionalKeys"></a>RequiredKeys、OptionalKeys</h3><p>在属性修饰工具类型中我们只实现了 FunctionKeys，它的实现相对简单，因为只需要判断类型即可。那如果，我们要获取一个接口中所有可选或必选的属性呢？现在没法通过类型判断，要怎么去收集属性？</p>
<p>这一部分的实际意义不大，因此我特意放在扩展阅读里，下面的 MutableKeys、ImmutableKeys 也是如此。</p>
<p>首先是 RequiredKeys ，我们可以通过一个很巧妙的方式判断一个属性是否是必选的，先看一个例子：</p>
<pre><code class="lang-typescript">type Tmp1 = {} extends { prop: number } ? &#39;Y&#39; : &#39;N&#39; // &quot;N&quot;
type Tmp2 = {} extends { prop?: number } ? &#39;Y&#39; : &#39;N&#39; // &quot;Y&quot;
</code></pre>
<p>在类型层级一节中我们已经了解，此时 TypeScript 会使用基于结构化类型的比较，也就意味着由于 <code>{ prop: number }</code> 可以视为继承自 <code>{}</code> ，<code>{} extends { prop: number }</code> 是不满足条件的。但是，如果这里的 prop 是可选的，那就不一样了！由于 <code>{ prop?: number }</code> 也可以是一个空的接口结构，那么 <code>{} extends { prop?: number }</code> 就可以认为是满足的。</p>
<p>因此，我们可以这么实现：</p>
<pre><code class="lang-typescript">export type RequiredKeys&lt;T&gt; = {
  [K in keyof T]-?: {} extends Pick&lt;T, K&gt; ? never : K
}[keyof T]
</code></pre>
<p>OptionalKeys 也是类似：</p>
<pre><code class="lang-typescript">export type OptionalKeys&lt;T&gt; = {
  [K in keyof T]-?: {} extends Pick&lt;T, K&gt; ? K : never
}[keyof T]
</code></pre>
<h3 id="MutableKeys、ImmutableKeys"><a href="#MutableKeys、ImmutableKeys" class="headerlink" title="MutableKeys、ImmutableKeys"></a>MutableKeys、ImmutableKeys</h3><p>MutableKeys 和 ImmutableKeys 则要更加复杂一些，因为 readonly 修饰符无法简单地通过结构化类型比较，我们需要一个能对只读这一特性进行判断的辅助工具类型，直接看例子再讲解：</p>
<pre><code class="lang-typescript">type Equal&lt;X, Y, A = X, B = never&gt; = (&lt;T&gt;() =&gt; T extends X ? 1 : 2) extends &lt;
  T
&gt;() =&gt; T extends Y ? 1 : 2
  ? A
  : B
</code></pre>
<p>在这里，<code>&lt;T&gt;() =&gt; T extends X ? 1 : 2</code> 和 <code>&lt;T&gt;() =&gt; T extends Y ? 1 : 2</code> 这两个函数结构实际上起辅助作用，内部的条件类型并不会真的进行运算。我们实际上是借助这一辅助结构判断类型 X 与 Y 的全等性，这一全等性就包括了 readonly 修饰符与可选性等。</p>
<p>我们基于其实现 MutableKeys 和 ImmutableKeys：</p>
<pre><code class="lang-typescript">export type MutableKeys&lt;T extends object&gt; = {
  [P in keyof T]-?: Equal&lt;
    { [Q in P]: T[P] },
    { -readonly [Q in P]: T[P] },
    P,
    never
  &gt;
}[keyof T]

expectType&lt;MutableKeys&lt;{ a: string; readonly b: string }&gt;&gt;(&#39;a&#39;)
expectNotType&lt;MutableKeys&lt;{ a: string; readonly b: string }&gt;&gt;(&#39;b&#39;)

export type ImmutableKeys&lt;T extends object&gt; = {
  [P in keyof T]-?: Equal&lt;
    { [Q in P]: T[P] },
    { -readonly [Q in P]: T[P] },
    never,
    P
  &gt;
}[keyof T]

expectType&lt;ImmutableKeys&lt;{ a: string; readonly b: string }&gt;&gt;(&#39;b&#39;)
expectNotType&lt;ImmutableKeys&lt;{ a: string; readonly b: string }&gt;&gt;(&#39;a&#39;)
</code></pre>
<p>在 MutableKeys 中，我们传入本次映射的单个属性组成的接口结构，以及这一结构去除了 readonly 的版本，如果前后两个接口结构被判定为全等，那就说明这一次映射的属性不是只读的。在 ImmutableKeys 中也是，但我们调换了符合条件类型时的正反结果位置。</p>
<p>Equal 这个工具类型在很多情况下还有特殊的妙用，不妨再试试各种类型都扔进来比一比？</p>
