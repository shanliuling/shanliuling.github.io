<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>陌生人三年前端2022总结 | 江承泰的小窝</title><meta name="author" content="江承泰"><meta name="copyright" content="江承泰"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="陌生人三年前端2022总结">
<meta property="og:type" content="article">
<meta property="og:title" content="陌生人三年前端2022总结">
<meta property="og:url" content="http://example.com/2023/03/10/%E9%9D%A2%E8%AF%95/%E9%99%8C%E7%94%9F%E4%BA%BA%E4%B8%89%E5%B9%B4%E5%89%8D%E7%AB%AF2022%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="江承泰的小窝">
<meta property="og:description" content="陌生人三年前端2022总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://b.zhutix.com/bizhi/Anime_Wallpaper_6/12.jpg">
<meta property="article:published_time" content="2023-03-10T01:52:28.000Z">
<meta property="article:modified_time" content="2023-03-10T02:17:13.232Z">
<meta property="article:author" content="江承泰">
<meta property="article:tag" content="面试相关">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://b.zhutix.com/bizhi/Anime_Wallpaper_6/12.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/03/10/%E9%9D%A2%E8%AF%95/%E9%99%8C%E7%94%9F%E4%BA%BA%E4%B8%89%E5%B9%B4%E5%89%8D%E7%AB%AF2022%E6%80%BB%E7%BB%93/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '陌生人三年前端2022总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-10 10:17:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/categoryBar/categoryBar.css"><link rel="stylesheet" href="/css/universe.css"><span id="fps"></span><link rel="stylesheet" href="/css/bilibiliheder.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/hexo-butterfly-swiper-marcus/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/hexo-butterfly-swiper-marcus/lib/swiperstyle.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/hexo-butterfly-swiper-marcus/lib/categoryGroup.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/jntm.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/imgGroup/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://b.zhutix.com/bizhi/Anime_Wallpaper_6/12.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">江承泰的小窝</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/imgGroup/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">陌生人三年前端2022总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-10T01:52:28.000Z" title="发表于 2023-03-10 09:52:28">2023-03-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-10T02:17:13.232Z" title="更新于 2023-03-10 10:17:13">2023-03-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">22.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>71分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="陌生人三年前端2022总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><div id="home_top"><div id="home_top_swiper"></div></div><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>今年的就业形式简直一片黑暗，本着明年会比今年还差的“侥幸心理”，我还是毫不犹豫地选择裸辞了，历经一个半月的努力，收到了还算不错的 offer，薪资和平台都有比较大的提升，但还是和自己的心理预期有着很大的差距。所以得出最大的结论就是：不要裸辞！不要裸辞！不要裸辞！因为面试期间带给人的压力，和现实与理想的落差对心理的摧残是不可估量的，在这样一个环境苟着是不错的选择。</p>
<p>接下来总结一般情况下前端面试中会经历的以下四个阶段和三个决定因素：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/323c8013d43f4a5b8ef2978834b0f1f5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image-20221204185636679.png"> 作为前端人员，技术的深度广度是排在第一位的，三年是一个分割线，一定要在这个时候找准自己的定位和方向。</p>
<p>其次良好的沟通表达能力、着装和表现等场外因素能提高面试官对你的认可度。</p>
<p>有的人技术很牛逼，但是面试时让面试官觉得不爽，觉得你盛气逼人/形象邋遢/自以为是/表述不清，就直接不要你，那是最得不偿失的。</p>
<p>以下是我整个面试准备以及被问到过的问题的一个凝练，因为在面试过程中，和面试官的交流很大程度并不是简单的背书，最好是要将知识通过自己的总结和凝练表达出来，再根据面试官的提问临场发挥将之补足完善。</p>
<h2 id="一、自我介绍"><a href="#一、自我介绍" class="headerlink" title="一、自我介绍"></a>一、自我介绍</h2><p>面试官让你自我介绍，而且不限定自我介绍的范围，肯定是面试官想从你的自我介绍中了解到你，所以介绍一定要保证简短和流畅，面对不同的面试官，自我介绍的内容可以是完全一样的，所以提前准备好说辞很重要，并且一定要注意：不要磕磕巴巴，要自信！<strong>流畅的表达和沟通能力</strong>，同样是面试官会对候选人考核点之一。我也曾当过面试官，自信大方的候选人，往往更容易受到青睐。</p>
<p>1、个人介绍（基本情况），主要的简历都有了，这方面一定要短</p>
<p>2、个人擅长什么，包括技术上的和非技术上的。技术上可以了解你的转场，非技术可以了解你这个人</p>
<p>3、做过的项目，捡最核心的项目说，不要把所有项目像背书一样介绍</p>
<p>4、自己的一些想法、兴趣或者是观点，甚至包括自己的职业规划。这要是给面试官一个感觉：热衷于”折腾”或者”思考”</p>
<blockquote>
<p>示例：</p>
<p>面试官您好，我叫 xxx，xx 年毕业于 xx 大学，自毕业以来一直从事着前端开发的相关工作。</p>
<p>我擅长的技术栈是 vue 全家桶，对 vue2 和 vue3 在使用上和源码都有一定程度的钻研；打包工具对 webpack 和 vite 都比较熟悉；有从零到一主导中大型项目落地的经验和能力。</p>
<p>在上家公司主要是 xx 产品线负责人的角色，主要职责是。。。。。。</p>
<p>除了开发相关工作，还有一定的技术管理经验：比如担任需求评审、UI/UE 交互评审评委，负责开发排期、成员协作、对成员代码进行 review、组织例会等等</p>
<p>平常会在自己搭建的博客上记录一些学习文章或者学习笔记，也会写一些原创的技术文章发表到掘金上，获得过 xx 奖。</p>
</blockquote>
<p>总的来说自我介绍尽量控制在 3 - 5 分钟之间，简明扼要为第一要义，其次是突出自己的能力和长处。</p>
<p>对于普通的技术面试官来说，自我介绍只是习惯性的面试前的开场白，一般简历上列举的基本信息已经满足他们对你的基本了解了。但是对于主管级别的面试官或者 Hr，会看重你的性格、行为习惯、抗压能力等等综合能力。所以要让自己在面试过程尽可能表现的积极向上，爱好广泛、喜欢持续学习，喜欢团队合作，可以无条件加班等等。当然也不是说让你去欺骗，只是在现在这种环境中，这些“侧面能力”也是能在一定程度提升自己竞争力的法宝。</p>
<h2 id="二、项目挖掘"><a href="#二、项目挖掘" class="headerlink" title="二、项目挖掘"></a>二、项目挖掘</h2><p>在目前这个行情，当你收到面试通知时，有很大概率是因为你的项目经验和所招聘的岗位比较符合。 所以在项目的准备上要额外上心，比如：</p>
<ol>
<li>对项目中使用到的<strong>技术</strong>的深挖</li>
<li>对项目<strong>整体设计</strong>思路的把控</li>
<li>对项目<strong>运作流程</strong>的管理</li>
<li><strong>团队协作</strong>的能力。</li>
<li>项目的<strong>优化点</strong>有哪些</li>
</ol>
<p>这些因人而异就不做赘述了，根据自己的情况好好挖掘即可。</p>
<h2 id="三、个人"><a href="#三、个人" class="headerlink" title="三、个人"></a>三、个人</h2><p>先说个人，当你通过了技术面试，到了主管和 hr 这一步，不管你当前的技术多牛逼，他们会额外考察你个人的潜力、学习能力、性格与团队的磨合等软实力，这里列出一些很容易被问到的：</p>
<h3 id="为什么跳槽？"><a href="#为什么跳槽？" class="headerlink" title="为什么跳槽？"></a>为什么跳槽？</h3><p>直接从个人发展入手表现出自己的上进心：</p>
<ol>
<li><p>一直想去更大的平台，不但有更好的技术氛围，而且学到的东西也更多</p>
</li>
<li><p>想扩展一下自己的知识面，之前一致是做 x 端的 xx 产品，技术栈比较单一一点，相对 xx 进行学习。</p>
</li>
<li><p>之前的工作陷入了舒适圈，做来做去也就那些东西，想要换个平台扩宽自己的技术广度，接触和学习一些新的技术体系，为后续的个人发展更有利</p>
</li>
</ol>
<h3 id="讲讲你和普通前端，你的亮点有哪些？"><a href="#讲讲你和普通前端，你的亮点有哪些？" class="headerlink" title="讲讲你和普通前端，你的亮点有哪些？"></a>讲讲你和普通前端，你的亮点有哪些？</h3><p>1、善于规划和总结，我会对自己经手的项目进行一个全面的分析，一个是业务拆解，对个各模块的业务通过脑图进行拆解；另一个就是对代码模块的拆解，按功能去区分各个代码模块。再去进行开发。我觉得这是很多只会进行盲目业务开发的前端做不到的</p>
<p>2、喜欢专研技术，平常对 vue 的源码一直在学习，也有输出自己的技术文章，像之前写过一篇逐行精读 <a target="_blank" rel="noopener" href="https://juejin.cn/post/7134640620571885598" title="https://juejin.cn/post/7134640620571885598">teleport 的源码</a>，花了大约有三十个小时才写出来的，对每一行源码的功能和作用进行了解读（但是为啥阅读和点赞这么低）。</p>
<h3 id="你有什么缺点？"><a href="#你有什么缺点？" class="headerlink" title="你有什么缺点？"></a>你有什么缺点？</h3><p>性子比较沉，更偏内向一点，所以我也会尝试让自己变得外向一点。</p>
<p>一个是要开各种评审会，作为前端代表需要我去准备各种材料和进行发言。</p>
<p>所以在团队内做比较多的技术分享，每周主持例会，也让我敢于去表达和探讨。</p>
<h3 id="最近有关注什么新技术吗？"><a href="#最近有关注什么新技术吗？" class="headerlink" title="最近有关注什么新技术吗？"></a>最近有关注什么新技术吗？</h3><ol>
<li>包依赖管理工具 pnpm(不会重复安装依赖，非扁平的 node_modules 结构，符号链接方式添加依赖包)</li>
<li>打包工具 vite （极速的开发环境）</li>
<li>flutter （Google 推出并开源的移动应用程序（App）开发框架，主打跨平台、高保真、高性能）</li>
<li>rust（听说是 js 未来的基座）</li>
<li>turbopack，webpack 的继任者，说是比 vite 快 10 倍，webpack 快 700 倍，然后尤雨溪亲自验证其实并没有比 vite 快 10 倍</li>
<li>webcomponents</li>
</ol>
<h3 id="你是偏向于走各个方向探索还是一直向某个方向研究下去？"><a href="#你是偏向于走各个方向探索还是一直向某个方向研究下去？" class="headerlink" title="你是偏向于走各个方向探索还是一直向某个方向研究下去？"></a>你是偏向于走各个方向探索还是一直向某个方向研究下去？</h3><p>我对个人的规划是这样的：</p>
<p>3 - 5 年在提高自己的技术深度的同时，扩宽自己的知识面，就是深度和广度上都要有提升，主要是在广度上，充分对大前端有了认知才能更好的做出选择</p>
<p>5 - 7 年就是当有足够的知识积累之后再选择某一个感兴趣方向深研下去，争取成为那个领域的专家</p>
<h3 id="团队规模，团队规范和开发流程"><a href="#团队规模，团队规范和开发流程" class="headerlink" title="团队规模，团队规范和开发流程"></a>团队规模，团队规范和开发流程</h3><p>这个因人而异，如实准备即可，因为不同规模团队的研发模式差别是很大的。</p>
<h3 id="代码-review-的目标"><a href="#代码-review-的目标" class="headerlink" title="代码 review 的目标"></a>代码 review 的目标</h3><p>1、最注重的是代码的可维护性（变量命名、注释、函数单一性原则等）</p>
<p>2、扩展性：封装能力（组件、代码逻辑是否可复用、可扩展性）</p>
<p>3、ES 新特性（es6+ 、ES2020, ES2021 可选链、at）</p>
<p>4、函数使用规范（比如遇到用 map 拿来当 forEach 用的）</p>
<p>5、性能提升，怎样运用算法，写出更加优雅，性能更好的代码</p>
<h3 id="如何带领团队的"><a href="#如何带领团队的" class="headerlink" title="如何带领团队的"></a>如何带领团队的</h3><p>我在上家公司是一个技术管理的角色。</p>
<p>0、<strong>落实开发规范</strong>，我在公司内部 wiki 上有发过，从命名、最佳实践到各种工具库的使用。新人进来前期我会优先跟进他们的代码质量</p>
<p>1、<strong>团队分工</strong>：每个人单独负责一个产品的开发，然后公共模块一般我会指定某几个人开发</p>
<p>2、<strong>代码质量保证</strong>：每周会 review 他们的代码，也会组织交叉 review 代码，将修改结果输出文章放到 wiki 中</p>
<p>3、<strong>组织例会</strong>：每周组织例会同步各自进度和风险，根据各自的进度调配工作任务</p>
<p>4、<strong>技术分享</strong>：还会组织不定时的技术分享。一开始就是单纯的我做分享，比如微前端的体系，ice stark 的源码</p>
<p>5、<strong>公共需求池</strong>：比如 webpack5/vite 的升级；vue2.7 的升级引入 setup 语法糖；pnpm 的使用；拓扑图性能优化</p>
<p>6、<strong>优化专项</strong>：在第一版产品出来之后，我还发起过性能优化专项，首屏加载性能，打包体积优化；让每个人去负责对应的优化项</p>
<h3 id="对加班怎么看？"><a href="#对加班怎么看？" class="headerlink" title="对加班怎么看？"></a>对加班怎么看？</h3><p>我觉得加班一般会有两种情况：</p>
<p>一是项目进度比较紧，那当然以项目进度为先，毕竟大家都靠这个吃饭</p>
<p>二是自身能力问题，对业务不熟啊或者引入一个全新的技术栈，那么我觉得不仅要加班跟上，还要去利用空闲时间抓紧学习，弥补自己的不足</p>
<h3 id="有什么兴趣爱好？"><a href="#有什么兴趣爱好？" class="headerlink" title="有什么兴趣爱好？"></a>有什么兴趣爱好？</h3><p>我平常喜欢阅读，就是在微信阅读里读一些心理学、时间管理、还有一些演讲技巧之类的书</p>
<p>然后是写文章，因为我发现单纯的记笔记很容易就忘了，因为只是记载别人的内容，而写自己的原创文章，在这个过程中能将知识非常高的比例转换成自身的东西，所以除了自个发掘金的文章，我也经常会对项目的产出有文章输出到 wiki 上</p>
<p>其他爱好就是和朋友约着打篮球、唱歌</p>
<h2 id="四、技术"><a href="#四、技术" class="headerlink" title="四、技术"></a>四、技术</h2><p>技术面试一定要注意：<strong>简明扼要，详略得当，不懂的就说不懂</strong>。因为在面试过程中是一个和面试官面对面交流的过程，没有面试官会喜欢一个絮絮叨叨半天说不到重点候选人，同时在说话过程中，听者会被动的忽略自己不感兴趣的部分，所以要着重突出某个技术的核心特点，并围绕着核心适当展开。</p>
<p>大厂基本都会通过算法题来筛选候选人，算法没有捷径，只能一步一步地刷题再刷题，这方面薄弱的要提前规划进行个学习了。</p>
<p>技术面过程主要会对前端领域相关的技术进行提问，一般面试官会基于你的建立，而更多的是，面试官基于他之前准备好的面试题，或者所在项目组比较熟悉的技术点进行提问，因为都是未知数，所以方方面面都还是要求比较足的。</p>
<p>如果想进入一个中大型且发展前景不错的公司，并不是照着别人的面经背一背就能糊弄过去的，这里作出的总结虽然每一条都很简短，但都是我对每一个知识点进行全面学习后才提炼出来的部分核心知识点，所以不惧怕面试官的“发散一下思维”。</p>
<p>面试过程一般会涉及到以下八大知识类型的考量：</p>
<p>JS/CSS/TypeScript/框架(Vue、React)/浏览器与网络/性能优化/前端工程化/架构/其他</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d67db982609402f80138d492d7d1cab~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"></p>
<p>所以面试前的技术准备绝不是一蹴而就，还需要平时的积累，比如可以利用每天十到二十分钟对其中一个小知识点进行全面的学习，长此以往，无论是几年的面试，都足够侃侃而谈。</p>
<h3 id="JS-篇"><a href="#JS-篇" class="headerlink" title="JS 篇"></a>JS 篇</h3><p>JS 的学习梭哈红包书和冴羽老师的<a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog" title="https://github.com/mqyqingfeng/Blog">深入 JS 系列博客</a>就基本 ok 了</p>
<p>常见的 JS 面试题一般会有这些</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86e56f19ba164b05b800e31e25683f1e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image-20221206221056905.png"></p>
<h4 id="什么是原型-原型链？"><a href="#什么是原型-原型链？" class="headerlink" title="什么是原型/原型链？"></a>什么是原型/原型链？</h4><p>原型的本质就是一个<strong>对象</strong>。</p>
<p>当我们在创建一个构造函数之后，这个函数会默认带上一个<code>prototype</code>属性，而这个属性的值就指向这个函数的原型对象。</p>
<p>这个原型对象是用来为通过该构造函数创建的实例对象提供共享属性，即<strong>用来实现基于原型的继承和属性的共享</strong></p>
<p>所以我们通过构造函数<strong>创建的实例对象</strong>都会从这个函数的原型对象上继承上面具有的属性</p>
<p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止（最顶层就是<code>Object.prototype</code>的原型，值为 null）。</p>
<p>所以<strong>通过原型一层层相互关联的链状结构就称为原型链</strong>。</p>
<h4 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h4><p>定义：闭包是指<strong>引用了其他函数作用域中变量的函数</strong>，通常是在嵌套函数中实现的。</p>
<p>从技术角度上所有 js 函数都是闭包。</p>
<p>从实践角度来看，满足以下俩个条件的函数算闭包</p>
<ol>
<li>即使创建它的上下文被销毁了，它依然存在。（比如从父函数中返回）</li>
<li>在代码中引用了自由变量（在函数中使用的既不是函数参数也不是函数局部变量的变量称作自由变量）</li>
</ol>
<p><strong>使用场景：</strong></p>
<ul>
<li><p>创建私有变量</p>
<p>vue 中的 data，需要是一个闭包，保证每个 data 中数据唯一，避免多次引用该组件造成的 data 共享</p>
</li>
<li><p>延长变量的生命周期</p>
<p>一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的</p>
</li>
</ul>
<p><strong>应用</strong></p>
<ul>
<li>柯里化函数</li>
<li>例如计数器、延迟调用、回调函数等</li>
</ul>
<h4 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h4><p>在绝大多数情况下，函数的调用方式决定了 <code>this</code> 的值（运行时绑定）</p>
<p>1、全局的 this 非严格模式指向 window 对象，严格模式指向 undefined</p>
<p>2、对象的属性方法中的 this 指向对象本身</p>
<p>3、apply、call、bind 可以变更 this 指向为第一个传参</p>
<p>4、箭头函数中的 this 指向它的父级作用域，它自身不存在 this</p>
<h4 id="浏览器的事件循环？"><a href="#浏览器的事件循环？" class="headerlink" title="浏览器的事件循环？"></a>浏览器的事件循环？</h4><p>js 代码执行过程中，会创建对应的执行上下文并压入执行上下文栈中。</p>
<p>如果遇到异步任务就会将任务挂起，交给其他线程去处理异步任务，当异步任务处理完后，会将回调结果加入事件队列中。</p>
<p>当执行栈中所有任务执行完毕后，就是主线程处于闲置状态时，才会从事件队列中取出排在首位的事件回调结果，并把这个回调加入执行栈中然后执行其中的代码，如此反复，这个过程就被称为事件循环。</p>
<p>事件队列分为了<strong>宏任务队列</strong>和微任务队列，在当前执行栈为空时，主线程回先查看微任务队列是否有事件存在，存在则依次执行微任务队列中的事件回调，直至微任务队列为空；不存在再去宏任务队列中处理。</p>
<p><strong>常见的宏任务有</strong><code>setTimeout()</code>、<code>setInterval()</code>、<code>setImmediate()</code>、I/O、用户交互操作，UI 渲染</p>
<p><strong>常见的微任务有</strong><code>promise.then()</code>、<code>promise.catch()</code>、<code>new MutationObserver</code>、<code>process.nextTick()</code></p>
<p><strong>宏任务和微任务的本质区别</strong></p>
<ol>
<li>宏任务有明确的异步任务需要执行和回调，需要其他异步线程支持</li>
<li>微任务没有明确的异步任务需要执行，只有回调，不需要其他异步线程支持。</li>
</ol>
<h4 id="javascript-中数据在栈和堆中的存储方式"><a href="#javascript-中数据在栈和堆中的存储方式" class="headerlink" title="javascript 中数据在栈和堆中的存储方式"></a>javascript 中数据在栈和堆中的存储方式</h4><p>1、基本数据类型大小固定且操作简单，所以放入栈中存储</p>
<p>2、引用数据类型大小不确定，所以将它们放入堆内存中，让它们在申请内存的时候自己确定大小</p>
<p>3、这样分开存储可以使内存占用最小。栈的效率高于堆</p>
<p>4、栈内存中变量在执行环境结束后会立即进行垃圾回收，而堆内存中需要变量的所有引用都结束才会被回收</p>
<h4 id="讲讲-v8-垃圾回收"><a href="#讲讲-v8-垃圾回收" class="headerlink" title="讲讲 v8 垃圾回收"></a>讲讲 v8 垃圾回收</h4><p>1、根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同分代采用不同的回收算法</p>
<p>2、新生代采用空间换时间的 scavenge 算法：整个空间分为两块，变量仅存在其中一块，回收的时候将存活变量复制到另一块空间，不存活的回收掉，周而复始轮流操作</p>
<p>3、老生代使用标记清除和标记整理，标记清除：遍历所有对象标记标记可以访问到的对象（活着的），然后将不活的当做垃圾进行回收。回收完后避免内存的断层不连续，需要通过标记整理将活着的对象往内存一端进行移动，移动完成后再清理边界内存</p>
<h4 id="函数调用的方法"><a href="#函数调用的方法" class="headerlink" title="函数调用的方法"></a>函数调用的方法</h4><p>1、普通<code>function</code>直接使用<code>()</code>调用并传参，如：<code>function test(x, y) &#123; return x + y&#125;</code>，<code>test(3, 4)</code></p>
<p>2、作为对象的一个属性方法调用，如：<code>const obj = &#123; test: function (val) &#123; return val &#125; &#125;</code>, <code>obj.test(2)</code></p>
<p>3、使用<code>call</code>或<code>apply</code>调用，更改函数 this 指向，也就是更改函数的执行上下文</p>
<p>4、<code>new</code>可以间接调用构造函数生成对象实例</p>
<h4 id="defer-和-async-的区别"><a href="#defer-和-async-的区别" class="headerlink" title="defer 和 async 的区别"></a>defer 和 async 的区别</h4><p>一般情况下，当执行到 script 标签时会进行下载 + 执行两步操作，这两步会阻塞 HTML 的解析；</p>
<p>async 和 defer 能将 script 的<strong>下载阶段</strong>变成异步执行（和 html 解析同步进行）；</p>
<p>async 下载完成后会立即执行 js，此时会阻塞 HTML 解析；</p>
<p>defer 会等全部 HTML 解析完成且在 DOMContentLoaded 事件之前执行。</p>
<h4 id="浏览器事件机制"><a href="#浏览器事件机制" class="headerlink" title="浏览器事件机制"></a>浏览器事件机制</h4><p>DOM 事件流三阶段：</p>
<ol>
<li><p><strong>捕获阶段</strong>：事件最开始由不太具体的节点最早接受事件, 而最具体的节点（触发节点）最后接受事件。为了让事件到达最终目标之前拦截事件。</p>
<p>比如点击一个 div，则 click 事件会按这种顺序触发: document =&gt; <code>&lt;html&gt;</code> =&gt; <code>&lt;body&gt;</code> =&gt; <code>&lt;div&gt;</code>，即由 document 捕获后沿着 DOM 树依次向下传播，<strong>并在各节点上触发捕获事件</strong>，直到到达实际目标元素。</p>
</li>
<li><p><strong>目标阶段</strong></p>
<p>当事件到达目标节点的，事件就进入了目标阶段。<strong>事件在目标节点上被触发</strong>(执行事件对应的函数)，然后会逆向回流，直到传播至最外层的文档节点。</p>
</li>
<li><p><strong>冒泡阶段</strong></p>
<p>事件在目标元素上触发后，会继续随着 DOM 树一层层往上冒泡，直到到达最外层的根节点。</p>
</li>
</ol>
<p>所有事件都要经历捕获阶段和目标阶段，但有些事件会跳过冒泡阶段，比如元素获得焦点 focus 和失去焦点 blur 不会冒泡</p>
<p><strong>扩展一</strong></p>
<p>e.target 和 e.currentTarget 区别？</p>
<ul>
<li><code>e.target</code> 指向触发事件监听的对象。</li>
<li><code>e.currentTarget</code> 指向添加监听事件的对象。</li>
</ul>
<p>例如：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>ul<span class="token operator">></span>
  <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>span<span class="token operator">></span>hello <span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span>
​
<span class="token keyword">let</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> aLi <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span>
ul<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">let</span> oLi1 <span class="token operator">=</span> e<span class="token punctuation">.</span>target  
  <span class="token keyword">let</span> oLi2 <span class="token operator">=</span> e<span class="token punctuation">.</span>currentTarget
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>oLi1<span class="token punctuation">)</span>   <span class="token comment">//  被点击的li</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>oLi2<span class="token punctuation">)</span>   <span class="token comment">// ul</span>
  console<span class="token punctuation">.</span><span class="token function">og</span><span class="token punctuation">(</span>oLi1<span class="token operator">===</span>oLi2<span class="token punctuation">)</span>  <span class="token comment">// false</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>给 ul 绑定了事件，点击其中 li 的时候，target 就是被点击的 li， currentTarget 就是被绑定事件的 ul</p>
<p>事件冒泡阶段（上述例子），<code>e.currenttarget</code>和<code>e.target</code>是不相等的，但是在事件的目标阶段，<code>e.currenttarget</code>和<code>e.target</code>是相等的</p>
<p>作用：</p>
<p><code>e.target</code>可以用来实现<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ac47521806d2" title="https://www.jianshu.com/p/ac47521806d2">事件委托</a>，该原理是通过事件冒泡（或者事件捕获）给父元素添加事件监听，e.target 指向引发触发事件的元素</p>
<p><strong>扩展二</strong></p>
<p>addEventListener 参数</p>
<p>语法：</p>
<pre class="line-numbers language-scss" data-language="scss"><code class="language-scss"><span class="token function">addEventListener</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">addEventListener</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> listener<span class="token punctuation">,</span> options || useCapture<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>type: 监听事件的类型，如：’click’/‘scroll’/‘focus’</li>
<li>listener: 必须是一个实现了 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" title="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener"><code>EventListener</code></a> 接口的对象，或者是一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functions" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functions">函数</a>。当监听的事件类型被触发时，会执行</li>
<li><p>options：指定 listerner 有关的可选参数对象</p>
<ul>
<li>capture: 布尔值，表示 listener 是否在事件捕获阶段传播到 EventTarget 时触发</li>
<li>once：布尔值，表示 listener 添加之后最多调用一次，为 true 则 listener 在执行一次后会移除</li>
<li>passive: 布尔值，表示 listener 永远不会调用 <code>preventDefault()</code></li>
<li>signal：可选，<code>AbortSignal</code>，当它的<code>abort()</code>方法被调用时，监听器会被移除</li>
</ul>
</li>
<li><p>useCapture：布尔值，默认为 false，listener 在事件冒泡阶段结束时执行，true 则表示在捕获阶段开始时执行。作用就是更改事件作用的时机，方便拦截/不被拦截。</p>
</li>
</ul>
<h3 id="Vue-篇"><a href="#Vue-篇" class="headerlink" title="Vue 篇"></a>Vue 篇</h3><p>笔主是主要从事 Vue 相关开发的，也做过 react 相关的项目，当然 react 也只是能做项目的水平，所以在简历中属于一笔带过的那种，框架贵不在多而在精，对 Vue 源码系列的学习让我对 Vue 还是十分自信的。学习过程也是如此，如果你能够对一门框架达到精通原理的掌握程度，学习其他框架不过只是花时间的事情。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51757304a24e4934877b626175e9109f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"></p>
<h4 id="vue-和-react-的区别"><a href="#vue-和-react-的区别" class="headerlink" title="vue 和 react 的区别"></a>vue 和 react 的区别</h4><p>1、数据可变性</p>
<ul>
<li>React 推崇函数式编程，数据不可变以及单向数据流，只能通过<code>setState</code>或者<code>onchange</code>来实现视图更新</li>
<li>Vue 基于数据可变，设计了响应式数据，通过监听数据的变化自动更新视图</li>
</ul>
<p>2、写法</p>
<ul>
<li>React 推荐使用 jsx + inline style 的形式，就是 all in js</li>
<li>Vue 是单文件组件（SFC）形式，在一个组件内分模块(tmplate/script/style)，当然 vue 也支持 jsx 形式，可以在开发 vue 的 ui 组件库时使用</li>
</ul>
<p>3、diff 算法</p>
<ul>
<li>Vue2 采用双端比较，Vue3 采用快速比较</li>
<li><code>react</code>主要使用 diff 队列保存需要更新哪些 DOM，得到 patch 树，再统一操作批量更新 DOM。，需要使用<code>shouldComponentUpdate()</code>来手动优化 react 的渲染。</li>
</ul>
<p><strong>扩展：了解 react hooks 吗</strong></p>
<p>组件类的写法很重，层级一多很难维护。</p>
<p>函数组件是纯函数，不能包含状态，也不支持生命周期方法，因此无法取代类。</p>
<p><strong>React Hooks 的设计目的，就是加强版函数组件，完全不使用”类”，就能写出一个全功能的组件</strong></p>
<p><strong>React Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。</strong></p>
<h4 id="vue-组件通信方式"><a href="#vue-组件通信方式" class="headerlink" title="vue 组件通信方式"></a>vue 组件通信方式</h4><ul>
<li>props / $emit</li>
<li>ref / $refs</li>
<li>parent/parent / parent/root</li>
<li>attrs / listeners</li>
<li>eventBus / vuex / pinia / localStorage / sessionStorage / Cookie / window</li>
<li>provide / inject</li>
</ul>
<h4 id="vue-渲染列表为什么要加-key"><a href="#vue-渲染列表为什么要加-key" class="headerlink" title="vue 渲染列表为什么要加 key?"></a>vue 渲染列表为什么要加 key?</h4><p>Vue 在处理更新同类型 vnode 的一组子节点（比如 v-for 渲染的列表节点）的过程中，为了减少 DOM 频繁创建和销毁的性能开销：</p>
<p>对没有 key 的子节点数组更新是通过<strong>就地更新</strong>的策略。它会通过对比新旧子节点数组的长度，先以比较短的那部分长度为基准，将新子节点的那一部分直接 patch 上去。然后再判断，如果是新子节点数组的长度更长，就直接将新子节点数组剩余部分挂载；如果是新子节点数组更短，就把旧子节点多出来的那部分给卸载掉）。<strong>所以如果子节点是组件或者有状态的 DOM 元素，原有的状态会保留，就会出现渲染不正确的问题</strong>。</p>
<p>有 key 的子节点更新是调用的<code>patchKeyedChildren</code>，这个函数就是大家熟悉的实现核心 diff 算法的地方，大概流程就是同步头部节点、同步尾部节点、处理新增和删除的节点，最后用求解最长递增子序列的方法区处理未知子序列。是为了<strong>最大程度实现对已有节点的复用，减少 DOM 操作的性能开销</strong>，同时避免了就地更新带来的子节点状态错误的问题。</p>
<p>综上，如果是用 v-for 去遍历常量或者子节点是诸如纯文本这类没有”状态“的节点，是可以使用不加 key 的写法的。但是实际开发过程中更推荐统一加上 key，能够实现更广泛场景的同时，避免了可能发生的状态更新错误，我们一般可以使用 ESlint 配置 key 为 v-for 的必需元素。</p>
<p>想详细了解这个知识点的可以去看看我之前写的文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7140446835311083534" title="https://juejin.cn/post/7140446835311083534">v-for 到底为啥要加上 key?</a></p>
<h4 id="vue3-相对-vue2-的响应式优化"><a href="#vue3-相对-vue2-的响应式优化" class="headerlink" title="vue3 相对 vue2 的响应式优化"></a>vue3 相对 vue2 的响应式优化</h4><p>vue2 使用的是<code>Object.defineProperty</code>去监听对象属性值的变化，但是它不能监听对象属性的新增和删除，所以需要使用<code>$set</code>、<code>$delete</code>这种语法糖去实现，这其实是一种设计上的不足。</p>
<p>所以 vue3 采用了<code>proxy</code>去实现响应式监听对象属性的增删查改。</p>
<p>其实从 api 的原生性能上<code>proxy</code>是比<code>Object.defineProperty</code>要差的。</p>
<p>而 vue 做的响应式性能优化主要是在将嵌套层级比较深的对象变成响应式的这一过程。</p>
<p>vue2 的做法是在组件初始化的时候就递归执行<code>Object.defineProperty</code>把子对象变成响应式的；</p>
<p>而 vue3 是在访问到子对象属性的时候，才会去将它转换为响应式。这种延时定义子对象响应式会对性能有一定的提升</p>
<h4 id="Vue-核心-diff-流程"><a href="#Vue-核心-diff-流程" class="headerlink" title="Vue 核心 diff 流程"></a>Vue 核心 diff 流程</h4><p>前提：当同类型的 vnode 的子节点都是一组节点（数组类型）的时候，</p>
<p>步骤：会走核心 diff 流程</p>
<p><strong>Vue3 是快速选择算法</strong></p>
<ul>
<li>同步头部节点</li>
<li>同步尾部节点</li>
<li>新增新的节点</li>
<li>删除多余节点</li>
<li>处理未知子序列（贪心 + 二分处理最长递增子序列）</li>
</ul>
<p><strong>Vue2 是双端比较算法</strong></p>
<p>在新旧字节点的头尾节点，也就是四个节点之间进行对比，找到可复用的节点，不断向中间靠拢的过程</p>
<p>diff 目的：diff 算法的目的就是为了尽可能地复用节点，减少 DOM 频繁创建和删除带来的性能开销</p>
<h4 id="vue-双向绑定原理"><a href="#vue-双向绑定原理" class="headerlink" title="vue 双向绑定原理"></a>vue 双向绑定原理</h4><p>基于 MVVM 模型，viewModel(业务逻辑层)提供了<strong>数据变化后更新视图</strong>和<strong>视图变化后更新数据</strong>这样一个功能，就是传统意义上的双向绑定。</p>
<p>Vue2.x 实现双向绑定核心是通过三个模块：Observer 监听器、Watcher 订阅者和 Compile 编译器。</p>
<p>首先监听器会监听所有的响应式对象属性，编译器会将模板进行编译，找到里面动态绑定的响应式数据并初始化视图；watchr 会去收集这些依赖；当响应式数据发生变更时 Observer 就会通知 Watcher；watcher 接收到监听器的信号就会执行更新函数去更新视图；</p>
<p>vue3 的变更是数据劫持部分使用了 porxy 替代 Object.defineProperty，收集的依赖使用组件的副作用渲染函数替代 watcher</p>
<h4 id="v-model-原理"><a href="#v-model-原理" class="headerlink" title="v-model 原理"></a>v-model 原理</h4><p><strong>vue2 v-model 原理剖析</strong></p>
<p>V-model 是用来监听用户事件然后更新数据的语法糖。</p>
<p>其本质还是单向数据流，内部是通过绑定元素的 value 值向下传递数据，然后通过绑定 input 事件，向上接收并处理更新数据。</p>
<p>单向数据流：父组件传递给子组件的值子组件不能修改，只能通过 emit 事件让父组件自个改。</p>
<pre class="line-numbers language-ini" data-language="ini"><code class="language-ini">// 比如
<span class="token key attr-name">&lt;input v-model</span><span class="token punctuation">=</span><span class="token value attr-value">"sth" /></span>
// 等价于
<span class="token key attr-name">&lt;input :value</span><span class="token punctuation">=</span><span class="token value attr-value">"sth" @input="sth = $event.target.value" /></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>给组件添加 <code>v-model</code> 属性时，默认会把<code>value</code> 作为组件的属性，把 <code>input</code>作为给组件绑定事件时的事件名</strong>:</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">// 父组件
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-button</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>number<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-button</span><span class="token punctuation">></span></span>
​
// 子组件
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>
  props<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    value<span class="token operator">:</span> Number<span class="token punctuation">,</span> <span class="token comment">//  属性名必须是 value</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
​
  methods<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 事件名必须是 input</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果想给绑定的 value 属性和 input 事件换个名称呢？可以这样：</p>
<p>在 Vue 2.2 及以上版本，你可以在定义组件时通过 model 选项的方式来定制 prop/event：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span>
export default &#123;
  model: &#123;
    prop: 'num', // 自定义属性名
    event: 'addNum' // 自定义事件名
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>vue3 v-model 原理</strong></p>
<p>实现和 vue2 基本一致</p>
<pre class="line-numbers language-ini" data-language="ini"><code class="language-ini"><span class="token key attr-name">&lt;Son v-model</span><span class="token punctuation">=</span><span class="token value attr-value">"modalValue"/></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>等同于</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token operator">&lt;</span>Son v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string-literal"><span class="token string">"modalValue"</span></span><span class="token operator">/</span><span class="token operator">></span> <span class="token operator">&lt;</span>Son <span class="token symbol">:modalValue</span><span class="token operator">=</span><span class="token string-literal"><span class="token string">"modalValue"</span></span> <span class="token variable">@update</span><span class="token symbol">:modalValue</span><span class="token operator">=</span><span class="token string-literal"><span class="token string">"modalUpdate=$event.target.value"</span></span><span class="token operator">/</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>自定义 model 参数</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>Son v<span class="token operator">-</span>model<span class="token operator">:</span>visible<span class="token operator">=</span><span class="token string">"visible"</span><span class="token operator">/</span><span class="token operator">></span>
<span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ctx</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    ctx<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">"update:visible"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="vue-响应式原理"><a href="#vue-响应式原理" class="headerlink" title="vue 响应式原理"></a>vue 响应式原理</h4><p>不管 vue2 还是 vue3，响应式的核心就是观察者模式 + 劫持数据的变化，在访问的时候做依赖收集和在修改数据的时候执行收集的依赖并更新数据。具体点就是：</p>
<p>vue2 的话采用的是 <code>Object.definePorperty</code>劫持对象的 get 和 set 方法，每个组件实例都会在渲染时初始化一个 watcher 实例，它会将组件渲染过程中所接触的响应式变量记为依赖，并且保存了组件的更新方法 update。当依赖的 setter 触发时，会通知 watcher 触发组件的 update 方法，从而更新视图。</p>
<p>Vue3 使用的是 ES6 的 proxy，proxy 不仅能够追踪属性的获取和修改，还可以追踪对象的增删，这在 vue2 中需要 set/set/set/delete 才能实现。然后就是收集的依赖是用组件的副作用渲染函数替代 watcher 实例。</p>
<p>性能方面，从原生 api 角度，proxy 这个方法的性能是不如 Object.property，但是 vue3 强就强在一个是上面提到的可以追踪对象的增删，第二个是对嵌套对象的处理上是访问到具体属性才会把那个对象属性给转换成响应式，而 vue2 是在初始化的时候就递归调用将整个对象和他的属性都变成响应式，这部分就差了。</p>
<p><strong>扩展一</strong></p>
<p>vue2 通过数组下标更改数组视图为什么不会更新？</p>
<p>尤大：性能不好</p>
<p>注意：vue3 是没问题的</p>
<p>why 性能不好？</p>
<p>我们看一下响应式处理:</p>
<pre class="line-numbers language-scss" data-language="scss"><code class="language-scss"><span class="token selector">export class Observer </span><span class="token punctuation">&#123;</span>
  this.value = value
    this.dep = new <span class="token function">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    this.vmCount = 0
    <span class="token function">def</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token string">'__ob__'</span><span class="token punctuation">,</span> this<span class="token punctuation">)</span>
    if <span class="token punctuation">(</span>Array.<span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// 这里对数组进行单独处理</span>
      if <span class="token punctuation">(</span>hasProto<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">protoAugment</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> arrayMethods<span class="token punctuation">)</span>
      <span class="token punctuation">&#125;</span> <span class="token selector">else </span><span class="token punctuation">&#123;</span>
        <span class="token function">copyAugment</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> arrayMethods<span class="token punctuation">,</span> arrayKeys<span class="token punctuation">)</span>
      <span class="token punctuation">&#125;</span>
      this.<span class="token function">observeArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span> <span class="token selector">else </span><span class="token punctuation">&#123;</span>
      <span class="token comment">// 对对象遍历所有键值</span>
      this.<span class="token function">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  walk <span class="token punctuation">(</span><span class="token property">obj</span><span class="token punctuation">:</span> Object<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    const keys = Object.<span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
    for <span class="token punctuation">(</span>let i = 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> keys[i]<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  observeArray <span class="token punctuation">(</span><span class="token property">items</span><span class="token punctuation">:</span> Array&lt;any><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    for <span class="token punctuation">(</span>let i = 0<span class="token punctuation">,</span> l = items.length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token function">observe</span><span class="token punctuation">(</span>items[i]<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于对象是通过<code>Object.keys()</code>遍历全部的键值，对数组只是<code>observe</code>监听已有的元素，所以通过下标更改不会触发响应式更新。</p>
<p>理由是数组的键相较对象多很多，当数组数据大的时候性能会很拉胯。所以不开放</p>
<h4 id="computed-和-watch"><a href="#computed-和-watch" class="headerlink" title="computed 和 watch"></a>computed 和 watch</h4><p>Computed 的大体实现和普通的响应式数据是一致的，不过加了延时计算和缓存的功能：</p>
<p>在访问 computed 对象的时候，会触发 getter ，初始化的时候将 computed 属性创建的 watcher （vue3 是副作用渲染函数）添加到与之相关的响应式数据的依赖收集器中（dep），然后根据里面一个叫 dirty 的属性判断是否要收集依赖，不需要的话直接返回上一次的计算结果，需要的话就执行更新重新渲染视图。</p>
<p><strong>watchEffect?</strong></p>
<p>watchEffect 会自动收集回调函数中响应式变量的依赖。并在首次自动执行</p>
<p>推荐在大部分时候用 <code>watch</code> 显式的指定依赖以避免不必要的重复触发，也避免在后续代码修改或重构时不小心引入新的依赖。<code>watchEffect</code> 适用于一些逻辑相对简单，依赖源和逻辑强相关的场景（或者懒惰的场景 ）</p>
<h4 id="nextTick-原理？"><a href="#nextTick-原理？" class="headerlink" title="$nextTick 原理？"></a>$nextTick 原理？</h4><p>vue 有个机制，更新 DOM 是异步执行的，当数据变化会产生一个异步更行队列，要等异步队列结束后才会统一进行更新视图，所以改了数据之后立即去拿 dom 还没有更新就会拿不到最新数据。所以提供了一个 nextTick 函数，它的回调函数会在 DOM 更新后立即执行。</p>
<p>nextTick 本质上是个异步任务，由于事件循环机制，异步任务的回调总是在同步任务执行完成后才得到执行。所以源码实现就是根据环境创建异步函数比如 Promise.then（浏览器不支持 promise 就会用 MutationObserver，浏览器不支持 MutationObserver 就会用 setTimeout），然后调用异步函数执行回调队列。</p>
<p>所以项目中不使用$nextTick 的话也可以直接使用 Promise.then 或者 SetTimeout 实现相同的效果</p>
<h4 id="Vue-异常处理"><a href="#Vue-异常处理" class="headerlink" title="Vue 异常处理"></a>Vue 异常处理</h4><p>1、全局错误处理：<code>Vue.config.errorHandler</code></p>
<p><code>Vue.config.errorHandler = function(err, vm, info) &#123;&#125;;</code></p>
<p>如果在组件渲染时出现运行错误，错误将会被传递至全局<code>Vue.config.errorHandler</code> 配置函数 (如果已设置)。</p>
<p>比如前端监控领域的 sentry，就是利用这个钩子函数进行的 vue 相关异常捕捉处理</p>
<p>2、<strong>全局警告处理</strong>：<code>Vue.config.warnHandler</code></p>
<pre class="line-numbers language-ini" data-language="ini"><code class="language-ini"><span class="token key attr-name">Vue.config.warnHandler</span> <span class="token punctuation">=</span> <span class="token value attr-value">function(msg, vm, trace) &#123;&#125;;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注意：仅在开发环境生效</p>
<p>像在模板中引用一个没有定义的变量，它就会有 warning</p>
<p>3、<strong>单个 vue 实例错误处理</strong>：<code>renderError</code></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  <span class="token function">renderError</span><span class="token punctuation">(</span><span class="token parameter">h<span class="token punctuation">,</span> err</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'pre'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">style</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">color</span><span class="token operator">:</span> <span class="token string">'red'</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> err<span class="token punctuation">.</span>stack<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>和组件相关，只适用于开发环境，这个用处不是很大，不如直接看控制台</p>
<p>4、<strong>子孙组件错误处理</strong>：<code>errorCaptured</code></p>
<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'cat'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div>&lt;slot>&lt;/slot>&lt;/div></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token punctuation">&#123;</span> type<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token function">errorCaptured</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> info<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">cat EC: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>err<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">\ninfo: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>info<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注：只能在组件内部使用，用于捕获子孙组件的错误，一般可以用于组件开发过程中的错误处理</p>
<p>5、<strong>终极错误捕捉</strong>：<code>window.onerror</code></p>
<pre class="line-numbers language-ini" data-language="ini"><code class="language-ini"><span class="token key attr-name">window.onerror</span> <span class="token punctuation">=</span> <span class="token value attr-value">function(message, source, line, column, error) &#123;&#125;;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>它是一个全局的异常处理函数，可以抓取所有的 JavaScript 异常</p>
<h4 id="Vuex-流程-amp-原理"><a href="#Vuex-流程-amp-原理" class="headerlink" title="Vuex 流程 &amp; 原理"></a>Vuex 流程 &amp; 原理</h4><p>Vuex 利用 vue 的 mixin 机制，在 beforeCreate 钩子前混入了 vuexinit 方法，这个方法实现了将 store 注入 vue 实例当中，并注册了 store 的引用属性 store，所以可以使用‘this.store ，所以可以使用 `this.store，所以可以使用‘this.store.xxx`去引入 vuex 中定义的内容。</p>
<p>然后 state 是利用 vue 的 data，通过<code>new Vue(&#123;data: &#123;$$state: state&#125;&#125;</code> 将 state 转换成响应式对象，然后使用 computed 函数实时计算 getter</p>
<h4 id="Vue-use-函数里面具体做了哪些事"><a href="#Vue-use-函数里面具体做了哪些事" class="headerlink" title="Vue.use 函数里面具体做了哪些事"></a>Vue.use 函数里面具体做了哪些事</h4><p><strong>概念</strong></p>
<p>可以通过全局方法<code>Vue.use()</code>注册插件，并能阻止多次注册相同插件，它需要在<code>new Vue</code>之前使用。</p>
<p>该方法第一个参数必须是<code>Object</code>或<code>Function</code>类型的参数。如果是<code>Object</code>那么该<code>Object</code>需要定义一个<code>install</code>方法；如果是<code>Function</code>那么这个函数就被当做<code>install</code>方法。</p>
<p><code>Vue.use()</code>执行就是执行<code>install</code>方法，其他传参会作为<code>install</code>方法的参数执行。</p>
<p>所以**<code>Vue.use()</code>本质就是执行需要注入插件的<code>install</code>方法**。</p>
<p><strong>源码实现</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">initUse</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">Vue</span><span class="token operator">:</span> GlobalAPI</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  Vue<span class="token punctuation">.</span><span class="token function-variable function">use</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">plugin</span><span class="token operator">:</span> Function <span class="token operator">|</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> installedPlugins <span class="token operator">=</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_installedPlugins <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_installedPlugins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 避免重复注册</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>installedPlugins<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>plugin<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span>
    <span class="token punctuation">&#125;</span> <span class="token comment">// 获取传入的第一个参数</span>
    <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token function">toArray</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    args<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> plugin<span class="token punctuation">.</span>install <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// 如果传入对象中的install属性是个函数则直接执行</span>
      plugin<span class="token punctuation">.</span><span class="token function">install</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>plugin<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> plugin <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// 如果传入的是函数，则直接（作为install方法）执行</span>
      <span class="token function">plugin</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span> <span class="token comment">// 将已经注册的插件推入全局installedPlugins中</span>
    installedPlugins<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>plugin<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>使用方式</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">installedPlugins <span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">import</span> Element <span class="token keyword">from</span> <span class="token string">'element-ui'</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Element<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="怎么编写一个-vue-插件"><a href="#怎么编写一个-vue-插件" class="headerlink" title="怎么编写一个 vue 插件"></a>怎么编写一个 vue 插件</h4><p>要暴露一个<code>install</code>方法，第一个参数是<code>Vue</code>构造器，第二个参数是一个可选的配置项对象</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Myplugin<span class="token punctuation">.</span><span class="token function-variable function">install</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">Vue<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 1、添加全局方法或属性</span>
  Vue<span class="token punctuation">.</span><span class="token function-variable function">myGlobalMethod</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 2、添加全局服务</span>
  Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'my-directive'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>
    <span class="token function">bind</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> pldVnode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token comment">// 3、注入组件选项</span>
  Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    <span class="token function-variable function">created</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token comment">// 4、添加实例方法</span>
  <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$myMethod</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">methodOptions</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="CSS-篇"><a href="#CSS-篇" class="headerlink" title="CSS 篇"></a>CSS 篇</h3><p>Css 直接面试问答的题目相对来说比较少，更多的是需要你能够当场手敲代码实现功能，一般来说备一些常见的布局，熟练掌握 flex 基本就没有什么问题了。</p>
<h4 id="什么是-BFC"><a href="#什么是-BFC" class="headerlink" title="什么是 BFC"></a>什么是 BFC</h4><p>Block Formatting context，块级格式上下文</p>
<p>BFC 是一个独立的渲染区域，相当于一个容器，在这个容器中的样式布局不会受到外界的影响。</p>
<p>比如浮动元素、绝对定位、overflow 除 visble 以外的值、display 为 inline/tabel-cells/flex 都能构建 BFC。</p>
<p>常常用于解决</p>
<ol>
<li>处于同一个 BFC 的元素外边距会产生重叠（此时需要将它们放在不同 BFC 中）；</li>
<li>清除浮动（float），使用 BFC 包裹浮动的元素即可</li>
<li>阻止元素被浮动元素覆盖，应用于两列式布局，左边宽度固定，右边内容自适应宽度（左边 float，右边 overflow）</li>
</ol>
<h4 id="伪类和伪元素及使用场景"><a href="#伪类和伪元素及使用场景" class="headerlink" title="伪类和伪元素及使用场景"></a>伪类和伪元素及使用场景</h4><p><strong>伪类</strong></p>
<p>伪类即：当元素处于特定状态时才会运用的特殊类</p>
<p>开头为冒号的选择器，用于选择处于特定状态的元素。比如<code>:first-child</code>选择第一个子元素；<code>:hover</code>悬浮在元素上会显示；<code>:focus</code>用键盘选定元素时激活；<code>:link</code> + <code>:visted</code>点击过的链接的样式;<code>:not</code>用于匹配不符合参数选择器的元素；<code>:fist-child</code>匹配元素的第一个子元素；<code>:disabled</code> 匹配禁用的表单元素</p>
<p><strong>伪元素</strong></p>
<p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过<code>::before</code> 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。示例：</p>
<p><code>::before</code> 在被选元素前插入内容。需要使用 content 属性来指定要插入的内容。被插入的内容实际上不在文档树中</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">h1:before</span> <span class="token punctuation">&#123;</span>
    content<span class="token punctuation">:</span> <span class="token string">"Hello "</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>::first-line</code> 匹配元素中第一行的文本</p>
<h4 id="src-和-href-区别"><a href="#src-和-href-区别" class="headerlink" title="src 和 href 区别"></a>src 和 href 区别</h4><ul>
<li>href 是 Hypertext Reference 的简写，表示超文本引用，指向网络资源所在位置。href 用于在当前文档和引用资源之间确立联系</li>
<li>src 是 source 的简写，目的是要把文件下载到 html 页面中去。src 用于替换当前内容</li>
<li><p>浏览器解析方式</p>
<p>当浏览器遇到 href 会并行下载资源并且不会停止对当前文档的处理。(同时也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式)</p>
<p>当浏览器解析到 src ，会暂停其他资源的下载和处理，直到将该资源加载或执行完毕。(这也是 script 标签为什么放在底部而不是头部的原因)</p>
</li>
</ul>
<h4 id="不定宽高元素的水平垂直居中"><a href="#不定宽高元素的水平垂直居中" class="headerlink" title="不定宽高元素的水平垂直居中"></a>不定宽高元素的水平垂直居中</h4><ul>
<li><p>flex</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">&lt;div class="wrapper flex-center">
  &lt;p>horizontal and vertical&lt;/p>
&lt;/div>
​
.wrapper</span> <span class="token punctuation">&#123;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 900px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
    <span class="token property">border</span><span class="token punctuation">:</span> 1px solid #ccc<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token selector">.flex-center</span> <span class="token punctuation">&#123;</span>  // 注意是父元素
    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
    <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>  // 主轴（竖线）上的对齐方式
    <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>      // 交叉轴（横轴）上的对齐方式
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>flex + margin</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">&lt;div class="wrapper">
  &lt;p>horizontal and vertical&lt;/p>
&lt;/div>
​
.wrapper</span> <span class="token punctuation">&#123;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 900px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
    <span class="token property">border</span><span class="token punctuation">:</span> 1px solid #ccc<span class="token punctuation">;</span>
    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token selector">.wrapper > p</span> <span class="token punctuation">&#123;</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>Transform + absolute</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">&lt;div class="wrapper">
    &lt;img src="test.png">
&lt;/div>
​
.wrapper</span> <span class="token punctuation">&#123;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
    <span class="token property">border</span><span class="token punctuation">:</span> 1px solid #ccc<span class="token punctuation">;</span>
    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token selector">.wrapper > img</span> <span class="token punctuation">&#123;</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
    <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
    <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
    <span class="token property">tansform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注：使用该方法只适用于行内元素(a、img、label、br、select 等)（宽度随元素的内容变化而变化），用于块级元素（独占一行）会有问题，left/top 的 50%是基于图片最左侧的边来移动的，tanslate 会将多移动的图片自身的半个长宽移动回去，就实现了水平垂直居中的效果</p>
</li>
<li><p>display: table-cell</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">&lt;div class="wrapper">
  &lt;p>absghjdgalsjdbhaksldjba&lt;/p>
&lt;/div>
​
.wrapper</span> <span class="token punctuation">&#123;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 900px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
    <span class="token property">border</span><span class="token punctuation">:</span> 1px solid #ccc<span class="token punctuation">;</span>
    <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
    <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>
    <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="浏览器和网络篇"><a href="#浏览器和网络篇" class="headerlink" title="浏览器和网络篇"></a>浏览器和网络篇</h3><p>浏览器和网络是八股中最典型的案例了，无论你是几年经验，只要是前端，总会有问到你的浏览器和网络协议。</p>
<p>最好的学习文章是李兵老师的《浏览器工作原理与实践》</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d710e1868138467bb70eb66ffd7da3b5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"></p>
<h4 id="跨页面通信的方法？"><a href="#跨页面通信的方法？" class="headerlink" title="跨页面通信的方法？"></a>跨页面通信的方法？</h4><p>这里分了同源页面和不同源页面的通信。</p>
<p>不同源页面可以通过 iframe 作为一个桥梁，因为 iframe 可以指定 origin 来忽略同源限制，所以可以在每个页面都嵌入同一个 iframe 然后监听 iframe 中传递的 message 就可以了。</p>
<p>同源页面的通信大致分为了三类：广播模式、共享存储模式和口口相传模式</p>
<p>第一种广播模式，就是可以通过 BroadCast Channel、Service Worker 或者 localStorage 作为广播，然后去监听广播事件中消息的变化，达到页面通信的效果。</p>
<p>第二种是共享存储模式，我们可以通过 Shared Worker 或者 IndexedDB，创建全局共享的数据存储。然后再通过轮询去定时获取这些被存储的数据是否有变更，达到一个的通信效果。像常见 cookie 也可以作为实现共享存储达到页面通信的一种方式</p>
<p>最后一种是口口相传模式，这个主要是在使用 window.open 的时候，会返回被打开页面的 window 的引用，而在被打开的页面可以通过 window.opener 获取打开它的页面的 window 点引用，这样，多个页面之间的 window 是能够相互获取到的，传递消息的话通过 postMessage 去传递再做一个事件监听就可以了</p>
<h4 id="详细说说-HTTP-缓存"><a href="#详细说说-HTTP-缓存" class="headerlink" title="详细说说 HTTP 缓存"></a>详细说说 HTTP 缓存</h4><p>在浏览器第一次发起请求服务的过程中，会根据响应报文中的缓存标识决定是否缓存结果，是否将缓存标识和请求结果存入到浏览器缓存中。</p>
<p>HTTP 缓存分为强制缓存和协商缓存两类。</p>
<p><strong>强制缓存就是请求的时候浏览器向缓存查找这次请求的结果</strong>，这里分了三种情况，没查找到直接发起请求（和第一次请求一致）；查找到了并且缓存结果还没有失效就直接使用缓存结果；查找到但是缓存结果失效了就会使用协商缓存。</p>
<p>强制缓存有 Expires 和 Cache-control 两个缓存标识，Expires 是 http/1.0 的字段，是用来指定过期的具体的一个时间（如 Fri, 02 Sep 2022 08:03:35 GMT），当服务器时间和浏览器时间不一致的话，就会出现问题。所以在 http1.1 添加了 cache-control 这个字段，它的值规定了缓存的范围（public/private/no-cache/no-store），也可以规定缓存在 xxx 时间内失效（max-age=xxx）是个相对值，就能避免了 expires 带来的问题。</p>
<p><strong>协商缓存就是强制缓存的缓存结果失效了，浏览器携带缓存标识向服务器发起请求，有服务器通过缓存标识决定是否使用缓存的过程</strong>。</p>
<p>控制协商缓存的字段有 last-modified / if-modified-since 和 Etag / if-none-match，后者优先级更高。</p>
<p>大致过程就是通过请求报文传递 last-modified 或 Etag 的值给服务器与服务器中对应值作对比，若和响应报文中的 if-modified-since 或 if-none-match 结果一致，则协商缓存有效，使用缓存结果，返回 304；否则失效，重新请求结果，返回 200</p>
<h4 id="输入-URL-到页面展现的全过程"><a href="#输入-URL-到页面展现的全过程" class="headerlink" title="输入 URL 到页面展现的全过程"></a>输入 URL 到页面展现的全过程</h4><p>用户输入一段内容后，浏览器会先去判断这段内容是搜索内容还是 URL ，是搜索内容的话就会接合默认的搜索引擎生成 URL，比如 google 浏览器是 goole.com/search?xxxx，如果是 URL 会拼接协议，比如 http/https。当页面没有监听 beforeupload 时间或者同意了继续执行流程，浏览器图标栏会进入加载中的状态。</p>
<p>接下来浏览器进程会通过 IPC 进程间通信将 URL 请求发送给网络进程，网络进程会先去缓存中查找该资源，如果有则拦截请求并直接 200 返回，没有的话会进入网络请求流程。</p>
<p>网络请求流程是网络进程请求 DNS 服务器返回域名对应的 IP 和端口号（如果这些之前有缓存也是直接返回缓存结果），如果没有端口号，http 默认为 80，https 默认为 443，如果是 https 还需要建立 TLS 安全连接创建加密的数据通道。</p>
<p>接着就是 TCP 三次握手建立浏览器和服务器连接，然后进行数据传输，数据传输完成四次挥手断开连接，如果设置了<code>connection: keep-alive</code>就可以一直保持连接。</p>
<p>网络进程将通过 TCP 获取的数据包进行解析，首先是根据响应头的 content-type 来判断数据类型，如果是字节流或者文件类型的话，会交给下载管理器进行下载，这时候导航流程就结束了。如果是 text/html 类型，就会通知到浏览器进程获取文档进行渲染。</p>
<p>浏览器进程获取到渲染的通知，会根据当前页面和新输入的页面判断是否是同一个站点，是的话就复用之前网页创建的渲染进程，否则的话会新创建一个单独的渲染进程。</p>
<p>浏览器进程将“提交文档”的消息给渲染进程，渲染进程接收到消息就会和网络进程建立传输数据的通道，数据传输完成后就返回“确认提交”的信息给浏览器进程。</p>
<p>浏览器接收到渲染进程的“确认提交“的消息后，就会更新浏览器的页面状态：安全状态、地址栏 URL、前进后退的历史消息，并更新 web 页面，此时页面是空白页面（白屏）。</p>
<p><strong>页面渲染过程</strong>（重点记忆）</p>
<p>最后是渲染进程对文档进行页面解析和子资源加载，渲染进程会将 HTML 转换成 DOM 树结构，将 css 转换成 styleSeets （ CSSOM）。然后复制 DOM 树过滤掉不显示的元素创建基本的渲染树，接着计算每个 DOM 节点的样式和计算每个节点的位置布局信息构建成布局树。</p>
<p>具有层叠上下文或者需要要裁剪的地方会独立创建图层，这就是分层，最终会形成一个分层树，渲染进程会给每个图层生成绘制列表并提交给合成线程，合成线程将图层分成图块（避免一次性绘制图层所有内容，可以根据图块优先需渲染视口部分），并在光栅化线程池中将图块转换成位图。</p>
<p>转换完毕后合成线程发送绘制图块命令 DrawQuard 给浏览器进程，浏览器根据 DrawQuard 消息生成页面，并显示到浏览器上。</p>
<p><strong>速记：</strong></p>
<p>浏览器的渲染进程将 html 解析成 dom 树，将 css 解析成 cssom 树，然后会先复制一份 DOM 树过滤掉不显示的元素（比如 display: none），再和 cssom 结合进行计算每个 dom 节点的布局信息构建成一个布局树。</p>
<p>布局树生成完毕就会根据图层的层叠上下文或者裁剪部分进行分层，形成一个分层树。</p>
<p>渲染进程再将每个图层生成绘制列表并提交给合成线程，合成线程为了避免一次性渲染，就是分块渲染，会将图层分成图块，并通过光栅化线程池将图块转换成位图。</p>
<p>转换完毕后，合成线程将绘制图块的命令发送给浏览器进行显示</p>
<h4 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h4><p>UDP 是<strong>用户数据包协议</strong>（User Dataprogram Protocol），IP 通过 IP 地址信息把数据包传送给指定电脑后，UDP 可以通过端口号把数据包分发给正确的程序。UDP 可以校验数据是否正确，但没有重发的机制，只会丢弃错误的数据包，同时 UDP 在发送之后无法确认是否到达目的地。UDP 不能保证数据的可靠性，但是传输的速度非常快，通常运用于在线视频、互动游戏这些不那么严格保证数据完整性的领域。</p>
<p>TCP 是为了解决 UDP 的数据容易丢失，且无法正确组装数据包二引入的传输控制协议（Transmission Control Protocol），<strong>是一种面向连接的，可靠的，基于字节流的传输层通信协议</strong>。TCP 在处理数据包丢失的情况，提供了重传机制；并且 TCP 引入了数据包排序机制，可以将乱序的数据包组合成完整的文件。</p>
<p>TCP 头除了包含目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。</p>
<h4 id="TCP-和-UDP-的区别-1"><a href="#TCP-和-UDP-的区别-1" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h4><p>一个 TCP 连接的生命周期会经历链接阶段，数据传输和断开连接阶段三个阶段。</p>
<p><strong>连接阶段</strong></p>
<p>用来建立客户端和服务器之间的链接，通过三次握手用来确认客户端、服务端相互之间的数据包收发能力。</p>
<p>1、客户端先发送 SYN 报文用来确认服务端能够发数据，并进入 SYN_SENT 状态等待服务端确认</p>
<p>2、服务端收到 SYN 报文，会向客户端发送一个 ACK 确认报文，同时服务端也会向客户端发送 SYN 报文用来确认客户端是否能够发送数据，此时服务端进入 SYN_RCVD 状态</p>
<p>3、客户端接收到 ACK + SYN 的报文，就会向服务端发送数据包并进入 ESTABLISHED 状态（建立连接）；服务端接收到客户端发送的 ACK 包也会进入 ESTABLISHED 状态，完成三次握手</p>
<p><strong>传输数据阶段</strong></p>
<p>该阶段，接收端需要对每个包进行确认操作；</p>
<p>所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，就会判断为包丢失，从而触发重发机制；</p>
<p>一个大文件在传输过程中会分为很多个小数据包，数据包到达接收端后会根据 TCP 头中的序号为其排序，保证数据的完整。</p>
<p><strong>断开连接阶段</strong></p>
<p>通过四次挥手，来保证双方的建立的连接能够断开</p>
<p>1、客户端向服务器发起 FIN 包，并进入 FIN_WAIT_1 状态</p>
<p>2、服务端收到 FIN 包，发出确认包 ACK，并带上自己的序号，服务端进入 CLOSE_WAIT 状态。这时候客户端已经没有数据要发给服务端了，但是服务端如果有数据要发给客户端，客户端还是需要接收。客户端收到 ACK 后进入 FIN_WAIT_2 状态</p>
<p>3、服务端数据发送完毕后，向客户端发送 FIN 包，此时服务器进入 LAST_ACK 状态</p>
<p>4、客户端收到 FIN 包发出确认包 ACK ，此时客户端进入 TIME_WAIT 状态，等待 2 MSL 后进入 CLOSED 状态；服务端接收到客户端的 ACK 后就进入 CLOSED 状态了。</p>
<p>对于四次挥手，因为 TCP 是全双工通信，在主动关闭方发送 FIN 包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的 <code>FIN</code> 包与对客户端的 <code>ACK</code> 包合并发送，只能先确认 <code>ACK</code>，然后服务器待无需发送数据时再发送 <code>FIN</code> 包，所以四次挥手时必须是四次数据包的交互</p>
<h4 id="Content-length-了解吗？"><a href="#Content-length-了解吗？" class="headerlink" title="Content-length 了解吗？"></a>Content-length 了解吗？</h4><p>Content-length 是 http 消息长度，用十进制数字表示的字节的数目。</p>
<p>如果 content-length &gt; 实际长度，服务端/客户端读取到消息队尾时会继续等待下一个字节，会出现无响应超时的情况</p>
<p>如果 content-length &lt; 实际长度，首次请求的消息会被截取，然后会导致后续的数据解析混乱。</p>
<p>当不确定 content-length 的值应该使用 Transfer-Encoding: chunked，能够将需要返回的数据分成多个数据块，直到返回长度为 0 的终止块</p>
<h4 id="跨域常用方案"><a href="#跨域常用方案" class="headerlink" title="跨域常用方案"></a>跨域常用方案</h4><p><strong>什么是跨域？</strong></p>
<p>协议 + 域名 + 端口号均相同时则为同域，任意一个不同则为跨域</p>
<p><strong>解决方案</strong></p>
<p>1、 传统的 jsonp：利用<code>&lt;script&gt;</code>标签没有跨域限制的特点，仅支持 get 接口，应该没有人用这个了</p>
<p>2、 一般使用 cors（跨域资源共享）来解决跨域问题，浏览器在请求头中发送 origin 字段指明请求发起的地址，服务端返回 Access-control-allow-orign，如果一致的话就可以进行跨域访问</p>
<p>3、 Iframe 解决主域名相同，子域名不同的跨域请求</p>
<p>4、 浏览器关闭跨域限制的功能</p>
<p>5、 http-proxy-middleware 代理</p>
<p><strong>预检</strong></p>
<p>补充：http 会在跨域的时候发起一次<strong>预检</strong>请求，“需预检的请求”要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。“预检请求”的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p>
<p>withCredentials 为 true 不会产生预请求；content-type 为 application/json 会产生预请求；设置了用户自定义请求头会产生预检请求；delete 方法会产生预检请求；</p>
<h4 id="XSS-和-CSRF"><a href="#XSS-和-CSRF" class="headerlink" title="XSS 和 CSRF"></a>XSS 和 CSRF</h4><p><strong>xss 基本概念</strong></p>
<p>Xss (Cross site scripting)跨站脚本攻击，为了和 css 区别开来所以叫 xss</p>
<p>Xss 指黑客向 html 或 dom 中注入恶意脚本，从而在用户浏览页面的时候利用注入脚本对用户实施攻击的手段</p>
<p>恶意脚本可以做到：窃取 cookie 信息、监听用户行为（比如表单的输入）、修改 DOM（比如伪造登录界面骗用户输入账号密码）、在页面生成浮窗广告等</p>
<p>恶意脚本注入方式：</p>
<ol>
<li><p>存储型 xss</p>
<p>黑客利用站点漏洞将恶意 js 代码提交到站点服务器，用户访问页面就会导致恶意脚本获取用户的 cookie 等信息。</p>
</li>
<li><p>反射性 xss</p>
<p>用户将一段恶意代码请求提交给 web 服务器，web 服务器接收到请求后将恶意代码反射到浏览器端</p>
</li>
<li><p>基于 DOM 的 xss 攻击</p>
<p>通过网络劫持在页面传输过程中更改 HTML 内容</p>
</li>
</ol>
<p>前两种属于服务端漏洞，最后一种属于前端漏洞</p>
<p><strong>防止 xss 攻击的策略</strong></p>
<p>1、服务器对输入脚本进行过滤或者转码，比如将<code>code:&lt;script&gt;alert(&#39;你被xss攻击了&#39;)&lt;/script&gt;</code>转换成<code>code:&amp;lt;script&amp;gt;alert(&amp;#39;你被xss攻击了&amp;#39;)&amp;lt;/script&amp;gt;</code></p>
<p>2、充分利用内容安全策略 CSP(content-security-policy)，可以通过 http 头信息的 content-security-policy 字段控制可以加载和执行的外部资源；或者通过 html 的 meta 标签<code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39;; object-src &#39;none&#39;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt;</code></p>
<p>3、cookie 设置为 http-only, cookie 就无法通过 <code>document.cookie</code> 来读取</p>
<p><strong>csrf 基本概念</strong></p>
<p>Csrf（cross site request forgery）跨站请求伪造，指黑客引导用户访问黑客的网站。</p>
<p>CSRF 是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。</p>
<p><strong>Csrf 攻击场景</strong></p>
<ol>
<li><p>自动发起 get 请求</p>
<p>比如黑客网站有个图片:</p>
<pre class="line-numbers language-ini" data-language="ini"><code class="language-ini"><span class="token key attr-name">&lt;img src</span><span class="token punctuation">=</span><span class="token value attr-value">"https://time.geekbang.org/sendcoin?user=hacker&amp;number=100"></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>黑客将转账的请求接口隐藏在 img 标签内，欺骗浏览器这是一张图片资源。当该页面被加载时，浏览器会自动发起 img 的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用户账户上的 100 极客币就被转移到黑客的账户上去了。</p>
</li>
<li><p>自动发起 post 请求</p>
<p>黑客在页面中构建一个隐藏的表单，当用户点开链接后，表单自动提交</p>
</li>
<li><p>引诱用户点击链接</p>
<p>比如页面上放了一张美女图片，下面放了图片下载地址，而这个下载地址实际上是黑客用来转账的接口，一旦用户点击了这个链接，那么他的极客币就被转到黑客账户上了</p>
</li>
</ol>
<p><strong>防止 csrf 方法</strong></p>
<p>1、设置 cookie 时带上 SameSite: strict/Lax 选项</p>
<p>2、验证请求的来源站点，通过 origin 和 refere 判断来源站点信息</p>
<p>3、csrf token，浏览器发起请求服务器生成 csrf token，发起请求前会验证 csrf token 是否合法。第三方网站肯定是拿不到这个 token。我们的 csrf token 是前后端约定好后写死的。</p>
<h4 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h4><p>websocket 是一种支持双向通信的协议，就是服务器可以主动向客户端发消息，客户端也可以主动向服务器发消息。</p>
<p>它是基于 HTTP 协议来建立连接的的，与 http 协议的兼容性很好，所以能通过 HTTP 代理服务器；没有同源限制。</p>
<p>WebSocket 是一种事件驱动的协议，这意味着可以将其用于真正的实时通信。与 HTTP 不同（必须不断地请求更新），而使用 websockets，更新在可用时就会立即发送</p>
<p>当连接终止时，WebSockets 不会自动恢复，这是应用开发中需要自己实现的机制，也是存在许多客户端开源库的原因之一。</p>
<p>像 webpack 和 vite 的 devServer 就使用了 websocket 实现热更新</p>
<h4 id="Post-和-Get-区别"><a href="#Post-和-Get-区别" class="headerlink" title="Post 和 Get 区别"></a>Post 和 Get 区别</h4><ul>
<li><strong>应用场景：</strong> (GET 请求是一个<strong>幂等</strong>的请求)一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。(而 Post 不是一个<strong>幂等</strong>的请求)一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。（<strong>幂等是指一个请求方法执行多次和仅执行一次的效果完全相同</strong>）</li>
<li><strong>是否缓存：</strong> 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</li>
<li><strong>传参方式不同：</strong> Get 通过查询字符串传参，Post 通过请求体传参。</li>
<li><strong>安全性：</strong> Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。</li>
<li><strong>请求长度：</strong> 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。</li>
<li><strong>参数类型：</strong> get 参数只允许 ASCII 字符，post 的参数传递支持更多的数据类型(如文件、图片)。</li>
</ul>
<h3 id="性能优化篇"><a href="#性能优化篇" class="headerlink" title="性能优化篇"></a>性能优化篇</h3><p>性能优化是中大型公司非常注重的点，因为和前端人的 KPI 息息相关，所以自然会作为面试题的常客。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c7edd66df3e406b9ea6f53805170e8d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"></p>
<h4 id="性能优化有哪些手段"><a href="#性能优化有哪些手段" class="headerlink" title="性能优化有哪些手段"></a>性能优化有哪些手段</h4><ol>
<li><p>从缓存的角度</p>
<ul>
<li>将一些不常变的大数据通过 localstorage/sessionStorage/indexdDB 进行读取</li>
<li>活用 http 缓存（强缓存和协商缓存），将内容存储在内存或者硬盘中，减少对服务器端的请求</li>
</ul>
</li>
<li><p>网络方面比较常用的是静态资源使用 CDN</p>
</li>
<li><p>打包方面</p>
<ul>
<li>路由的按需加载</li>
<li>优化打包后资源的大小</li>
<li>开启 gzip 压缩资源</li>
<li>按需加载三方库</li>
</ul>
</li>
<li><p>代码层面</p>
<ul>
<li>减少不必要的请求，删除不必要的代码</li>
<li>避免耗时过长的 js 处理阻塞主线程（耗时且无关 DOM 可以丢到 web worker 去处理或者拆分成小的任务）</li>
<li>图片可以使用懒加载的方式，长列表使用虚拟滚动</li>
</ul>
</li>
<li><p>首屏速度提升</p>
<ul>
<li>代码压缩，减少打包的静态资源体积(Terser plugin/MiniCssExtratplugin)</li>
<li>路由懒加载，首屏就只会请求第一个路由的相关资源</li>
<li>使用 cdn 加速第三方库，我们是 toB 的产品，会需要部署在内网，所以一般不用，toC 用的多</li>
<li>ssr 服务端渲染，由服务器直接返回拼接好的 html 页面</li>
</ul>
</li>
<li><p>vue 常见的性能优化方式</p>
<ul>
<li>图片懒加载： vue-lazyLoad</li>
<li>虚拟滚动</li>
<li>函数式组件</li>
<li>v-show/ keep-alive 复用 dom</li>
<li>deffer 延时渲染组件（requestIdleCallback）</li>
<li>时间切片 time slicing</li>
</ul>
</li>
</ol>
<h4 id="前端监控-SDK-技术要点"><a href="#前端监控-SDK-技术要点" class="headerlink" title="前端监控 SDK 技术要点"></a>前端监控 SDK 技术要点</h4><ol>
<li>可以通过<code>window.performance</code>获取各项性能指标数据</li>
<li>完整的前端监控平台包括：数据采集和上报、数据整理和存储、数据展示</li>
<li><p>网页性能指标：</p>
<ul>
<li>FP（first-paint）从页面加载到第一个像素绘制到屏幕上的时间</li>
<li>FCP（first-contentful-paint），从页面加载开始到页面内容的任何部分在屏幕上完成渲染的时间</li>
<li>LCP(largest-contentful-paint)，从页面加载到最大文本或图像元素在屏幕上完成渲染的时间</li>
</ul>
</li>
<li><p>以上指标可以通过<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceObserver" title="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceObserver">PerformanceObserver</a>获取</p>
</li>
<li>首屏渲染时间计算：通过<code>MutationObserver</code>监听<code>document</code>对象的属性变化</li>
</ol>
<h4 id="如何减少回流、重绘，充分利用-GPU-加速渲染？"><a href="#如何减少回流、重绘，充分利用-GPU-加速渲染？" class="headerlink" title="如何减少回流、重绘，充分利用 GPU 加速渲染？"></a>如何减少回流、重绘，充分利用 GPU 加速渲染？</h4><p>首先应该避免直接使用 DOM API 操作 DOM，像 vue react 虚拟 DOM 让对 DOM 的多次操作合并成了一次。</p>
<ol>
<li>样式集中改变，好的方式是使用动态 class</li>
<li><p>读写操作分离，避免读后写，写后又读</p>
<pre class="line-numbers language-ini" data-language="ini"><code class="language-ini">// bad 强制刷新 触发四次重排+重绘
<span class="token key attr-name">div.style.left</span> <span class="token punctuation">=</span> <span class="token value attr-value">div.offsetLeft + 1 + 'px';</span>
<span class="token key attr-name">div.style.top</span> <span class="token punctuation">=</span> <span class="token value attr-value">div.offsetTop + 1 + 'px';</span>
<span class="token key attr-name">div.style.right</span> <span class="token punctuation">=</span> <span class="token value attr-value">div.offsetRight + 1 + 'px';</span>
<span class="token key attr-name">div.style.bottom</span> <span class="token punctuation">=</span> <span class="token value attr-value">div.offsetBottom + 1 + 'px';</span>
​
​
// good 缓存布局信息 相当于读写分离 触发一次重排+重绘
<span class="token key attr-name">var curLeft</span> <span class="token punctuation">=</span> <span class="token value attr-value">div.offsetLeft;</span>
<span class="token key attr-name">var curTop</span> <span class="token punctuation">=</span> <span class="token value attr-value">div.offsetTop;</span>
<span class="token key attr-name">var curRight</span> <span class="token punctuation">=</span> <span class="token value attr-value">div.offsetRight;</span>
<span class="token key attr-name">var curBottom</span> <span class="token punctuation">=</span> <span class="token value attr-value">div.offsetBottom;</span>
​
<span class="token key attr-name">div.style.left</span> <span class="token punctuation">=</span> <span class="token value attr-value">curLeft + 1 + 'px';</span>
<span class="token key attr-name">div.style.top</span> <span class="token punctuation">=</span> <span class="token value attr-value">curTop + 1 + 'px';</span>
<span class="token key attr-name">div.style.right</span> <span class="token punctuation">=</span> <span class="token value attr-value">curRight + 1 + 'px';</span>
<span class="token key attr-name">div.style.bottom</span> <span class="token punctuation">=</span> <span class="token value attr-value">curBottom + 1 + 'px';</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>原来的操作会导致四次重排，读写分离之后实际上只触发了一次重排，这都得益于浏览器的渲染队列机制：</p>
<blockquote>
<p>当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。</p>
</blockquote>
</li>
<li><p>使用<code>display: none</code>后元素不会存在渲染树中，这时对它进行各种操作，然后更改 display 显示即可（示例：向 2000 个 div 中插入一个 div）</p>
</li>
<li>通过 documentFragment 创建 dom 片段，在它上面批量操作 dom ，操作完后再添加到文档中，这样只有一次重排（示例：一次性插入 2000 个 div）</li>
<li>复制节点在副本上操作然后替换它</li>
<li>使用 BFC 脱离文档流，重排开销小</li>
</ol>
<p>Css 中的<code>transform</code>、<code>opacity</code>、<code>filter</code>、<code>will-change</code>能触发硬件加速</p>
<h4 id="大图片优化的方案"><a href="#大图片优化的方案" class="headerlink" title="大图片优化的方案"></a>大图片优化的方案</h4><ol>
<li><p>优化请求数</p>
<ul>
<li>雪碧图，将所有图标合并成一个独立的图片文件，再通过 <code>background-url</code>和<code>backgroun-position</code>来显示图标</li>
<li>懒加载，尽量只加载用户正则浏览器或者即将浏览的图片。最简单使用监听页面滚动判断图片是否进入视野；使用 intersection Observer API；使用已知工具库；使用 css 的<code>background-url</code>来懒加载</li>
<li>base64，小图标或骨架图可以使用内联 base64 因为 base64 相比普通图片体积大。注意首屏不需要懒加载，设置合理的占位图避免抖动。</li>
</ul>
</li>
<li><p>减小图片大小</p>
<ul>
<li>使用合适的格式比如 WebP、svg、video 替代 GIF 、渐进式 JPEG</li>
<li>削减图片质量</li>
<li>使用合适的大小和分辨率</li>
<li>删除冗余的图片信息</li>
<li>Svg 压缩</li>
</ul>
</li>
<li><p>缓存</p>
</li>
</ol>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><ol>
<li>非响应式变量可以定义在<code>created</code>钩子中使用 this.xxx 赋值</li>
<li>访问局部变量比全局变量块，因为不需要切换作用域</li>
<li>尽可能使用 <code>const</code>声明变量，注意数组和对象</li>
<li>使用 v8 引擎时，运行期间，V8 会将创建的对象与隐藏类关联起来，以追踪它们的属性特征。能够共享相同隐藏类的对象性能会更好，v8 会针对这种情况去优化。所以为了贴合”共享隐藏类“，我们要避免”先创建再补充“式的<strong>动态属性复制以及动态删除属性</strong>（使用 delete 关键字）。即尽量在构造函数/对象中一次性声明所有属性。属性删除时可以设置为 null，这样可以保持隐藏类不变和继续共享。</li>
<li><p>避免内存泄露的方式</p>
<ul>
<li>尽可能少创建全局变量</li>
<li>手动清除定时器</li>
<li>少用闭包</li>
<li>清除 DOM 引用</li>
<li>弱引用</li>
</ul>
</li>
<li><p>避免强制同步，在修改 DOM 之前查询相关值</p>
</li>
<li>避免布局抖动（一次 JS 执行过程中多次执行强制布局和抖动操作），尽量不要在修改 DOM 结构时再去查询一些相关值</li>
<li>合理利用 css 合成动画，如果能用 css 处理就交给 css。因为合成动画会由合成线程执行，不会占用主线程</li>
<li>避免频繁的垃圾回收，优化存储结构，避免小颗粒对象的产生</li>
</ol>
<p>感兴趣的可以看看我之前的一篇性能优化技巧整理的文章<a target="_blank" rel="noopener" href="https://juejin.cn/post/7157900749651836936" title="https://juejin.cn/post/7157900749651836936">极意 · 代码性能优化之道</a></p>
<h3 id="前端工程化篇"><a href="#前端工程化篇" class="headerlink" title="前端工程化篇"></a>前端工程化篇</h3><p>前端工程化是前端 er 成长路上最必不可少的技能点，<strong>一切能够提高前端开发效率的功能</strong>都可以当做前端工程化的一部分。刚入门的可以从零搭建脚手架开始<a target="_blank" rel="noopener" href="https://juejin.cn/post/7069315908597973023" title="https://juejin.cn/post/7069315908597973023">万字长文详解从零搭建企业级 vue3 + vite2+ ts4 框架全过程</a></p>
<p>对于面试而言，考察的最多的还是对打包工具的掌握程度。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61162f0e3219448db79bff6f65c9830e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"></p>
<h4 id="webpack-的执行流程和生命周期"><a href="#webpack-的执行流程和生命周期" class="headerlink" title="webpack 的执行流程和生命周期"></a>webpack 的执行流程和生命周期</h4><p>webpack 是为现代 JS 应用提供静态资源打包功能的 bundle。</p>
<p>核心流程有三个阶段: 初始化阶段、构建阶段和生成阶段</p>
<p>1、初始化阶段，会从配置文件、配置对象和 Shell 参数中读取初始化的参数并与默认配置结合成最终的参数，之以及创建 compiler 编译器对象和初始化它的运行环境</p>
<p>2、构建阶段，编译器会执行它的 run()方法开始编译的过程，其中会先确认 entry 入口文件，从入口文件开始搜索和入口文件有直接或者简介关联的所有文件创建依赖对象，之后再根据依赖对象创建 module 对象，这时候会使用 loader 将模块转换标准的 js 内容，再调用 js 的解释器将内容转换成 AST 对象，再从 AST 中找到该模块依赖的模块，递归本步骤知道所有入口依赖文件都经过了本步骤的处理。最后完成模块编译，得到了每个模块被翻译的内容和他们之间的关系依赖图（dependency graph），这个依赖图就是项目所有用到的模块的映射关系。</p>
<p>3、生成阶段，将编译后的 module 组合成 chunk ，再把每个 chunk 转换成一个单独的文件输出到文件列表，确定好输出内容后，根据配置确定输出路径和文件名，就把文件内容写入文件系统</p>
<h4 id="webpack-的-plugin-和-loader"><a href="#webpack-的-plugin-和-loader" class="headerlink" title="webpack 的 plugin 和 loader"></a>webpack 的 plugin 和 loader</h4><p><strong>loader</strong></p>
<p>webpack 只能理解 JS 和 JSON 文件，loader 本质上就是个转换器，能将其他类型的文件转换成 webpack 识别的东西</p>
<p>loader 会在 webpack 的构建阶段将依赖对象创建的 module 转换成标准的 js 内容的东西。比如 vue-loader 将 vue 文件转换成 js 模块，图片字体通过 url-loader 转换成 data URL，这些 webpack 能够识别的东西。</p>
<p>可以在 module.rules 中配置不同的 loader 解析不同的文件</p>
<p><strong>plugin</strong></p>
<p>插件本质是一个带有 apply 函数的类<code>class myPlugin &#123; apply(compiler) &#123;&#125; &#125;</code>,这个 apply 函数有个参数 compiler 是 webpack 初始化阶段生成的编译器对象，可以调用编译器对象中的 hooks 注册各种钩子的回调这些 hooks 是贯穿整个编译的生命周期。所以开发者可以通过钩子回调在里面插入特定的代码，实现特定的功能。</p>
<p>比如 stylelint plugin 可以指定 stylelint 的需要检查文件类型和文件范围；HtmlWebpackPlugin 用来生成打包后的模板文件；MiniCssExtactPlugin 会将所有的 css 提取成独立的 chunks,stylelintplugin 可以在开发阶段提供样式的检查功能。</p>
<h4 id="webpack-的-hash-策略"><a href="#webpack-的-hash-策略" class="headerlink" title="webpack 的 hash 策略"></a>webpack 的 hash 策略</h4><p>MiniCssExtractPlugin 对于浏览器来说，一方面期望每次请求页面资源时，获得的都是最新的资源；一方面期望在资源没有发生变化时，能够复用缓存对象。这个时候，使用文件名+文件哈希值的方式，就可以实现只要通过文件名，就可以区分资源是否有更新。而 webpack 就内置了 hash 计算方法，对生成文件的可以在输出文件中添加 hash 字段。</p>
<p>Webpack 内置 hash 有三种</p>
<ul>
<li><p><strong>hash</strong>: 项目每次构建都会生成一个 hash，和整个项目有关，项目任意地方有改变就会改变</p>
<p>hash 会更据每次工程的内容进行计算，很容易造成不必要的 hash 变更，不利于版本管理。 一般来说，没有什么机会直接使用 hash。</p>
</li>
<li><p><strong>content hash</strong>: 和单个文件的内容相关。指定文件的内容发生改变，就会改变 hash，内容不变 hash 值不变</p>
<p>对于 css 文件来说，一般会使用 MiniCssExtractPlugin 将其抽取为一个单独的 css 文件。</p>
<p>此时可以使用 contenthash 进行标记，确保 css 文件内容变化时，可以更新 hash。</p>
</li>
<li><p><strong>chunk hash</strong>：和 webpack 打包生成的 chunk 相关。每一个 entry，都会有不同的 hash。</p>
<p>一般来说，针对于输出文件，我们使用 chunkhash。</p>
<p>因为 webpack 打包后，最终每个 entry 文件及其依赖会生成单独的一个 js 文件。</p>
<p>此时使用 chunkhash，能够保证整个打包内容的更新准确性。</p>
</li>
</ul>
<p><strong>扩展：file-loader 的 hash</strong> 可能有同学会表示有以下疑问。</p>
<p>明明经常看到在处理一些图片，字体的 file-loader 的打包时，使用的是[name]_[hash:8].[ext]</p>
<p>但是如果改了其他工程文件，比如 index.js，生成的图片 hash 并没有变化。</p>
<p>这里需要注意的是，file-loader 的 hash 字段，这个 loader 自己定义的占位符，和 webpack 的内置 hash 字段并不一致。</p>
<p>这里的 hash 是使用 md4 等 hash 算法，对文件内容进行 hash。</p>
<p>所以只要文件内容不变，hash 还是会保持一致。</p>
<h4 id="vite-原理"><a href="#vite-原理" class="headerlink" title="vite 原理"></a>vite 原理</h4><p>Vite 主要由两个部分组成</p>
<ol>
<li><p>开发环境</p>
<p>Vite 利用浏览器去解析 imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用（就相当于把我们在开发的文件转换成 ESM 格式直接发送给浏览器）</p>
<p>当浏览器解析 import HelloWorld from ‘./components/HelloWorld.vue’ 时，会向当前域名发送一个请求获取对应的资源（ESM 支持解析相对路径）,浏览器直接下载对应的文件然后解析成模块记录（打开 network 面板可以看到响应数据都是 ESM 类型的 js）。然后实例化为模块分配内存，按照导入导出语句建立模块和内存的映射关系。最后运行代码。</p>
<p><strong>vite 会启动一个 koa 服务器拦截浏览器对 ESM 的请求，通过请求路径找到目录下对应的文件并处理成 ESM 格式返回给客户端</strong>。</p>
<p>vite 的热加载是在客户端和服务端之间建立了 websocket 连接，代码修改后服务端发送消息通知客户端去请求修改模块的代码，完成热更新，就是改了哪个 view 文件就重新请求那个文件，这样保证了热更新速度不受项目大小影响。</p>
<p>开发环境会使用 esbuild 对依赖进行个预构建缓存，第一次启动会慢一点，后面的启动会直接读取缓存</p>
</li>
<li><p>生产环境</p>
<p>使用 rollup 来构建代码，提供指令可以用来优化构建过程。缺点就是开发环境和生产环境可能不一致;</p>
</li>
</ol>
<h4 id="webpack-和-vite-对比"><a href="#webpack-和-vite-对比" class="headerlink" title="webpack 和 vite 对比"></a>webpack 和 vite 对比</h4><p>Webpack 的热更新原理简单来说就是，一旦发生某个依赖（比如 <code>a.js</code> ）改变，就将这个依赖所处的 <code>module</code> 的更新，并将新的 <code>module</code> 发送给浏览器重新执行。每次热更新都会重新生成 <code>bundle</code>。试想如果依赖越来越多，就算只修改一个文件，理论上热更新的速度也会越来越慢</p>
<p>Vite 利用浏览器去解析 imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用，热更新是在客户端和服务端之间建立了 websocket 连接，代码修改后服务端发送消息通知客户端去请求修改模块的代码，完成热更新，就是改了哪个文件就重新请求那个文件，这样保证了热更新速度不受项目大小影响。</p>
<p>所以 vite 目前的最大亮点在于开发体验上，服务启动快、热更新快，明显地优化了开发者体验，生产环境因为底层是 rollup ，rollup 更适合小的代码库，从扩展和功能上都是不如 webpack 的，可以使用 vite 作为一个开发服务器 dev server 使用，生产打包用 webpack 这样的模式。</p>
<h4 id="做过哪些-wewbpack-的优化"><a href="#做过哪些-wewbpack-的优化" class="headerlink" title="做过哪些 wewbpack 的优化"></a>做过哪些 wewbpack 的优化</h4><p>0、升级 webpack 版本，3 升 4，实测是提升了几十秒的打包速度</p>
<p>1、splitChunksPlugin 抽离共用模块输出单独的 chunks ,像一些第三方的依赖库，可以单独拆分出来，避免单个 chunks 过大。</p>
<p>2、DllPlugin 作用同上，这个依赖库相当于从业务代码中剥离出来，只有依赖库自身版本变化才会重新打包，提升打包速度</p>
<p>3、loaders 的运行是同步的，同各模块会执行全部的 loaders</p>
<ul>
<li>可以使用 oneOf,只要匹配上对应的 loader 就不会继续执行 loader</li>
<li>使用 happyPack 将 loader 的同步执行转换成并行比如（style-loader,css-loader,less-loader 合并起来执行）</li>
</ul>
<p>4、exclude/include 指定匹配范围；alias 指定路径别名;</p>
<p>5、cache-loader 持久化存储；</p>
<p>6、ESM 项目开启 useExport 标记，使用 tree-shaking</p>
<p>7、exclude/include 指定匹配范围；alias 指定路径别名;cache-loader 持久化存储；</p>
<p>8、terserPlugin 可以提供代码压缩，去除注释、去除空格的功能；MiniCssExtractPlugin 压缩 css</p>
<h4 id="npm-run-执行过程"><a href="#npm-run-执行过程" class="headerlink" title="npm run 执行过程"></a>npm run 执行过程</h4><p>0、在 package.json 文件中可以定义 script 配置项，里面可以定义运行脚本的键和值</p>
<p>1、在 npm install 的时候，npm 会读取配置将<strong>执行脚本软链接</strong>到<code>node_modules/.bin</code>目录下，<strong>同时将<code>./bin</code>加入当环境变量<code>$PATH</code>中</strong>，所以如果在全局直接运行该命令会去全局目录里找，可能会找不到该命令就会报错。比如 npm run start，他是执行的 webpack-dev-server 带上参数</p>
<p>2、还有一种情况，就是单纯的执行脚本命令，比如 npm run build，实际运行的是 node build.js，即使用 node 执行 build.js 这个文件</p>
<h4 id="ESM-和-CJS-的区别"><a href="#ESM-和-CJS-的区别" class="headerlink" title="ESM 和 CJS 的区别"></a>ESM 和 CJS 的区别</h4><p><strong>ES6</strong></p>
<ul>
<li>ES6 模块是引用，重新赋值会编译报错，不能修改其变量的指针指向，但可以改变内部属性的值；</li>
<li>ES6 模块中的值属于动态只读引用。</li>
<li>对于只读来说，即不允许修改引入变量的值，import 的变量是只读的，不论是基本数据类型还是复杂数据类型。当模块遇到 import 命令时，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li>
<li>对于动态来说，原始值发生变化，import 加载的值也会发生变化。不论是基本数据类型还是复杂数据类型。</li>
<li>循环加载时，ES6 模块是动态引用。只要两个模块之间存在某个引用，代码就能够执行。</li>
</ul>
<p><strong>CommonJS</strong></p>
<ul>
<li>CommonJS 模块是拷贝（浅拷贝），可以重新赋值，可以修改指针指向；</li>
<li>对于基本数据类型，属于复制。即会被模块缓存。同时，在另一个模块可以对该模块输出的变量重新赋值。</li>
<li>对于复杂数据类型，属于浅拷贝。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块。 当使用 require 命令加载某个模块时，就会运行整个模块的代码。</li>
<li>当使用 require 命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</li>
<li>当循环加载时，脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</li>
</ul>
<h3 id="设计模式篇"><a href="#设计模式篇" class="headerlink" title="设计模式篇"></a>设计模式篇</h3><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>代理模式：为对象提供一个代用品或占位符，以便控制对它的访问</p>
<p>例如实现图片懒加载的功能，先通过一张<code>loading</code>图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到<code>img</code>标签里面</p>
<h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><p>装饰者模式的定义：在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法</p>
<p>通常运用在原有方法维持不变，在原有方法上再挂载其他方法来满足现有需求。</p>
<p>像 typescript 的装饰器就是一个典型的装饰者模式，还有 vue 当中的 mixin</p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象</p>
<p>比如 ice stark 的子应用，一次只保证渲染一个子应用</p>
<h4 id="观察者模式和发布订阅模式"><a href="#观察者模式和发布订阅模式" class="headerlink" title="观察者模式和发布订阅模式"></a>观察者模式和发布订阅模式</h4><p>1、虽然两种模式都存在订阅者和发布者（具体观察者可认为是订阅者、具体目标可认为是发布者），但是观察者模式是由具体目标调度的，而发布/订阅模式是统一由调度中心调的，所以观察者模式的订阅者与发布者之间是存在依赖的，而发布/订阅模式则不会。</p>
<p>2、两种模式都可以用于松散耦合，改进代码管理和潜在的复用。</p>
<p>3、在观察者模式中，观察者是知道 Subject 的，Subject 一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信</p>
<p>4、观察者模式大多数时候是同步的，比如当事件触发，Subject 就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p><strong>正则表达式是什么数据类型？</strong></p>
<p>是对象，<code>let re = /ab+c/</code>等价于<code>let re = new RegExp(&#39;ab+c&#39;)</code></p>
<p><strong>正则贪婪模式和非贪婪模式？</strong></p>
<p><strong>量词</strong></p>
<p><code>*</code>：0 或多次； <code>?</code>：0 或 1 次； <code>+</code>：1 到多次； <code>&#123;m&#125;</code>：出现 m 次； <code>&#123;m,&#125;</code>：出现至少 m 次； <code>&#123;m, n&#125;</code>：出现 m 到 n 次</p>
<p><strong>贪婪模式</strong></p>
<p>正则中，表示次数的量词默认是贪婪的，会尽可能匹配最大长度，比如<code>a*</code>会从第一个匹配到 a 的时候向后匹配尽可能多的 a，直到没有 a 为止。</p>
<p><strong>非贪婪模式</strong></p>
<p>在量词后面加<code>?</code>就能变成非贪婪模式，非贪婪即找出长度最小且满足条件的</p>
<p><strong>贪婪&amp; 非贪婪特点</strong></p>
<p>贪婪模式和非贪婪模式，都需要发生<strong>回溯</strong>才能完成相应的功能</p>
<p><strong>独占模式</strong></p>
<p>独占模式和贪婪模式很像，独占模式会尽可能多地去匹配，如果匹配失败就结束，不会进行回溯，这样的话就比较节省时间。</p>
<p>写法：量词后面使用<code>+</code></p>
<p>优缺点：独占模式性能好，可以减少匹配的时间和 cpu 资源；但是某些情况下匹配不到，比如：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>正则</th>
<th>文本</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>贪婪模式</td>
<td>a{1,3}ab</td>
<td>aaab</td>
<td>匹配</td>
</tr>
<tr>
<td>非贪婪模式</td>
<td>a{1,3}?ab</td>
<td>aaab</td>
<td>匹配</td>
</tr>
<tr>
<td>独占模式</td>
<td>a{1,3}+ab</td>
<td>aaab</td>
<td>不匹配</td>
</tr>
</tbody>
</table>
</div>
<p>a{1,3}+ab 去匹配 aaab 字符串，a{1,3}+ 会把前面三个 a 都用掉，并且不会回溯</p>
<p><strong>常见正则匹配</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>表示任何单个字符</td>
<td></td>
</tr>
<tr>
<td>[ ]</td>
<td>字符集，对单个字符给出范围</td>
<td><code>[abc]</code>表示 a、b、c,[a-z]表示 a-z 的单个字符</td>
</tr>
<tr>
<td>[^ ]</td>
<td>非字符集，对单个字符给出排除范围</td>
<td><code>[^abc]</code>表示非 a 或 b 或 c 的单个字符</td>
</tr>
<tr>
<td>_</td>
<td>前一个字符零次或无限次扩展</td>
<td><code>abc_</code>表示 ab、abc、abcc、abccc 等</td>
</tr>
<tr>
<td>`</td>
<td>`</td>
<td>左右表达式的任意一个</td>
<td>`abc</td>
<td>def`表示 abc、def</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串结尾</td>
<td><code>abc$</code>表示 abc 且在一个字符串结尾</td>
</tr>
<tr>
<td>( )</td>
<td>分组标记内部只能使用</td>
<td><code>(abc)</code>表示 abc,`(abc</td>
<td>def)`表示 abc、def</td>
</tr>
<tr>
<td>\D</td>
<td>非数字</td>
<td></td>
</tr>
<tr>
<td>\d</td>
<td>数字，等价于 0-9</td>
<td></td>
</tr>
<tr>
<td>\S</td>
<td>可见字符</td>
<td></td>
</tr>
<tr>
<td>\s</td>
<td>空白字符(空格、换行、制表符等等)</td>
<td></td>
</tr>
<tr>
<td>\W</td>
<td>非单词字符</td>
<td></td>
</tr>
<tr>
<td>\w</td>
<td>单词字符，等价于[a-z0-9A-Z_]</td>
<td></td>
</tr>
<tr>
<td>匹配字符串开头</td>
<td><code>^abc</code>表示 abc 且在一个字符串的开头</td>
</tr>
<tr>
<td>{m,n}</td>
<td>扩展前一个字符 m 到 n 次</td>
<td><code>ab&#123;1,2&#125;c</code>表示 abc、abbc</td>
</tr>
<tr>
<td>{m}</td>
<td>扩展前一个字符 m 次</td>
<td><code>ab&#123;2&#125;c</code>表示 abbc</td>
</tr>
<tr>
<td>{m,}</td>
<td>匹配前一个字符至少 m 次</td>
<td></td>
</tr>
<tr>
<td>？</td>
<td>前一个字符 0 次或 1 次扩展</td>
<td><code>abc?</code> 表示 ab、abc</td>
</tr>
</tbody>
</table>
</div>
<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>概念：前端自动化测试领域的， 用来验证独立的代码片段能否正常工作</p>
<p>1、可以直接用 Node 中自带的 assert 模块做断言：如果当前程序的某种状态符合 assert 的期望此程序才能正常执行，否则直接退出应用。</p>
<pre class="line-numbers language-ini" data-language="ini"><code class="language-ini">function multiple(a, b) &#123;
 <span class="token key attr-name">   let result</span> <span class="token punctuation">=</span> <span class="token value attr-value">0;</span>
 <span class="token key attr-name">   for (let i</span> <span class="token punctuation">=</span> <span class="token value attr-value">0; i &lt; b; ++i)</span>
 <span class="token key attr-name">       result +</span><span class="token punctuation">=</span> <span class="token value attr-value">a;</span>
    return result;
&#125;
​
<span class="token key attr-name">const assert</span> <span class="token punctuation">=</span> <span class="token value attr-value">require('assert');</span>
assert.equal(multiple(1, 2), 3));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>2、常见单测工具：Jest，使用示例</p>
<pre class="line-numbers language-scss" data-language="scss"><code class="language-scss">const sum = <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./sum'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
​
<span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'sum function test'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token selector">=> </span><span class="token punctuation">&#123;</span>
  <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'sum(1, 2) === 3'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token selector">=> </span><span class="token punctuation">&#123;</span>
    <span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span> 2<span class="token punctuation">)</span><span class="token punctuation">)</span>.<span class="token function">toBe</span><span class="token punctuation">(</span>3<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 这里 test 和 it 没有明显区别，it 是指: it should xxx, test 是指 test xxx</span>
  <span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'sum(1, 2) === 3'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token selector">=> </span><span class="token punctuation">&#123;</span>
    <span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span> 2<span class="token punctuation">)</span><span class="token punctuation">)</span>.<span class="token function">toBe</span><span class="token punctuation">(</span>3<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="babel-原理和用途"><a href="#babel-原理和用途" class="headerlink" title="babel 原理和用途"></a>babel 原理和用途</h4><p><strong>babel 用途</strong></p>
<ul>
<li>转义 esnext、typescript 到目标环境支持 js （高级语言到到低级语言叫编译，高级语言到高级语言叫转译）</li>
<li>代码转换（taro）</li>
<li>代码分析（模块分析、tree-shaking、linter 等）</li>
</ul>
<p><strong>bebel 如何转换的？</strong></p>
<p>对源码字符串 parse 生成 AST，然后对 AST 进行增删改，然后输出目标代码字符串</p>
<p><strong>转换过程</strong></p>
<ol>
<li>parse 阶段：首先使用 <code>@babel/parser</code>将源码转换成 AST</li>
<li>transform 阶段：接着使用<code>@babel/traverse</code>遍历 AST，并调用 visitor 函数修改 AST，修改过程中通过<code>@babel/types</code>来创建、判断 AST 节点；使用<code>@babel/template</code>来批量创建 AST</li>
<li>generate 阶段：使用<code>@babel/generate</code>将 AST 打印为目标代码字符串，期间遇到代码错误位置时会用到<code>@babel/code-frame</code></li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d626498295d94c258eb0ecd03432beab~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="技术面.png"></p>
<p>好的，以上就是我对三年前端经验通过面试题做的一个总结了，祝大家早日找到心仪的工作~</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">江承泰</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/10/%E9%9D%A2%E8%AF%95/%E9%99%8C%E7%94%9F%E4%BA%BA%E4%B8%89%E5%B9%B4%E5%89%8D%E7%AB%AF2022%E6%80%BB%E7%BB%93/">http://example.com/2023/03/10/%E9%9D%A2%E8%AF%95/%E9%99%8C%E7%94%9F%E4%BA%BA%E4%B8%89%E5%B9%B4%E5%89%8D%E7%AB%AF2022%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">江承泰的小窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/">面试相关</a></div><div class="post_share"><div class="social-share" data-image="https://b.zhutix.com/bizhi/Anime_Wallpaper_6/12.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/404.jpg" target="_blank"><img class="post-qr-code-img" src="/img/404.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/404.jpg" target="_blank"><img class="post-qr-code-img" src="/img/404.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/03/10/%E9%9D%A2%E8%AF%95/%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"><img class="next-cover" src="https://b.zhutix.com/bizhi/Anime_Wallpaper_6/12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">如何准备前端面试</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/10/%E9%9D%A2%E8%AF%95/%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/" title="如何准备前端面试"><img class="cover" src="https://b.zhutix.com/bizhi/Anime_Wallpaper_6/12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-03-10</div><div class="title">如何准备前端面试</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">一、自我介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%A1%B9%E7%9B%AE%E6%8C%96%E6%8E%98"><span class="toc-number">2.</span> <span class="toc-text">二、项目挖掘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%AA%E4%BA%BA"><span class="toc-number">3.</span> <span class="toc-text">三、个人</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B7%B3%E6%A7%BD%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">为什么跳槽？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E4%BD%A0%E5%92%8C%E6%99%AE%E9%80%9A%E5%89%8D%E7%AB%AF%EF%BC%8C%E4%BD%A0%E7%9A%84%E4%BA%AE%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">讲讲你和普通前端，你的亮点有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">你有什么缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%89%E5%85%B3%E6%B3%A8%E4%BB%80%E4%B9%88%E6%96%B0%E6%8A%80%E6%9C%AF%E5%90%97%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">最近有关注什么新技术吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E6%98%AF%E5%81%8F%E5%90%91%E4%BA%8E%E8%B5%B0%E5%90%84%E4%B8%AA%E6%96%B9%E5%90%91%E6%8E%A2%E7%B4%A2%E8%BF%98%E6%98%AF%E4%B8%80%E7%9B%B4%E5%90%91%E6%9F%90%E4%B8%AA%E6%96%B9%E5%90%91%E7%A0%94%E7%A9%B6%E4%B8%8B%E5%8E%BB%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">你是偏向于走各个方向探索还是一直向某个方向研究下去？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A2%E9%98%9F%E8%A7%84%E6%A8%A1%EF%BC%8C%E5%9B%A2%E9%98%9F%E8%A7%84%E8%8C%83%E5%92%8C%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">3.6.</span> <span class="toc-text">团队规模，团队规范和开发流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-review-%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">3.7.</span> <span class="toc-text">代码 review 的目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B8%A6%E9%A2%86%E5%9B%A2%E9%98%9F%E7%9A%84"><span class="toc-number">3.8.</span> <span class="toc-text">如何带领团队的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%8A%A0%E7%8F%AD%E6%80%8E%E4%B9%88%E7%9C%8B%EF%BC%9F"><span class="toc-number">3.9.</span> <span class="toc-text">对加班怎么看？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD%EF%BC%9F"><span class="toc-number">3.10.</span> <span class="toc-text">有什么兴趣爱好？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%8A%80%E6%9C%AF"><span class="toc-number">4.</span> <span class="toc-text">四、技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JS-%E7%AF%87"><span class="toc-number">4.1.</span> <span class="toc-text">JS 篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F"><span class="toc-number">4.1.1.</span> <span class="toc-text">什么是原型&#x2F;原型链？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%9F"><span class="toc-number">4.1.2.</span> <span class="toc-text">什么是闭包？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this-%E7%9A%84%E6%8C%87%E5%90%91"><span class="toc-number">4.1.3.</span> <span class="toc-text">this 的指向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%9F"><span class="toc-number">4.1.4.</span> <span class="toc-text">浏览器的事件循环？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#javascript-%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%9C%A8%E6%A0%88%E5%92%8C%E5%A0%86%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.5.</span> <span class="toc-text">javascript 中数据在栈和堆中的存储方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2-v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">4.1.6.</span> <span class="toc-text">讲讲 v8 垃圾回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.7.</span> <span class="toc-text">函数调用的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#defer-%E5%92%8C-async-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.8.</span> <span class="toc-text">defer 和 async 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.9.</span> <span class="toc-text">浏览器事件机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E7%AF%87"><span class="toc-number">4.2.</span> <span class="toc-text">Vue 篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vue-%E5%92%8C-react-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.1.</span> <span class="toc-text">vue 和 react 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text">vue 组件通信方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue-%E6%B8%B2%E6%9F%93%E5%88%97%E8%A1%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0-key"><span class="toc-number">4.2.3.</span> <span class="toc-text">vue 渲染列表为什么要加 key?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue3-%E7%9B%B8%E5%AF%B9-vue2-%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E4%BC%98%E5%8C%96"><span class="toc-number">4.2.4.</span> <span class="toc-text">vue3 相对 vue2 的响应式优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue-%E6%A0%B8%E5%BF%83-diff-%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.5.</span> <span class="toc-text">Vue 核心 diff 流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.6.</span> <span class="toc-text">vue 双向绑定原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-model-%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.7.</span> <span class="toc-text">v-model 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.8.</span> <span class="toc-text">vue 响应式原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#computed-%E5%92%8C-watch"><span class="toc-number">4.2.9.</span> <span class="toc-text">computed 和 watch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nextTick-%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">4.2.10.</span> <span class="toc-text">$nextTick 原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">4.2.11.</span> <span class="toc-text">Vue 异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vuex-%E6%B5%81%E7%A8%8B-amp-%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.12.</span> <span class="toc-text">Vuex 流程 &amp; 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue-use-%E5%87%BD%E6%95%B0%E9%87%8C%E9%9D%A2%E5%85%B7%E4%BD%93%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B"><span class="toc-number">4.2.13.</span> <span class="toc-text">Vue.use 函数里面具体做了哪些事</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-vue-%E6%8F%92%E4%BB%B6"><span class="toc-number">4.2.14.</span> <span class="toc-text">怎么编写一个 vue 插件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E7%AF%87"><span class="toc-number">4.3.</span> <span class="toc-text">CSS 篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-BFC"><span class="toc-number">4.3.1.</span> <span class="toc-text">什么是 BFC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.3.2.</span> <span class="toc-text">伪类和伪元素及使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#src-%E5%92%8C-href-%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.3.</span> <span class="toc-text">src 和 href 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%AE%9A%E5%AE%BD%E9%AB%98%E5%85%83%E7%B4%A0%E7%9A%84%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-number">4.3.4.</span> <span class="toc-text">不定宽高元素的水平垂直居中</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E7%AF%87"><span class="toc-number">4.4.</span> <span class="toc-text">浏览器和网络篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">4.4.1.</span> <span class="toc-text">跨页面通信的方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4-HTTP-%E7%BC%93%E5%AD%98"><span class="toc-number">4.4.2.</span> <span class="toc-text">详细说说 HTTP 缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">4.4.3.</span> <span class="toc-text">输入 URL 到页面展现的全过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.4.4.</span> <span class="toc-text">TCP 和 UDP 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB-1"><span class="toc-number">4.4.5.</span> <span class="toc-text">TCP 和 UDP 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Content-length-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">4.4.6.</span> <span class="toc-text">Content-length 了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E5%B8%B8%E7%94%A8%E6%96%B9%E6%A1%88"><span class="toc-number">4.4.7.</span> <span class="toc-text">跨域常用方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XSS-%E5%92%8C-CSRF"><span class="toc-number">4.4.8.</span> <span class="toc-text">XSS 和 CSRF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#websocket"><span class="toc-number">4.4.9.</span> <span class="toc-text">websocket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Post-%E5%92%8C-Get-%E5%8C%BA%E5%88%AB"><span class="toc-number">4.4.10.</span> <span class="toc-text">Post 和 Get 区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87"><span class="toc-number">4.5.</span> <span class="toc-text">性能优化篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%E6%89%8B%E6%AE%B5"><span class="toc-number">4.5.1.</span> <span class="toc-text">性能优化有哪些手段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7-SDK-%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9"><span class="toc-number">4.5.2.</span> <span class="toc-text">前端监控 SDK 技术要点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%9B%9E%E6%B5%81%E3%80%81%E9%87%8D%E7%BB%98%EF%BC%8C%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8-GPU-%E5%8A%A0%E9%80%9F%E6%B8%B2%E6%9F%93%EF%BC%9F"><span class="toc-number">4.5.3.</span> <span class="toc-text">如何减少回流、重绘，充分利用 GPU 加速渲染？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">4.5.4.</span> <span class="toc-text">大图片优化的方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">4.5.5.</span> <span class="toc-text">代码优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%AF%87"><span class="toc-number">4.6.</span> <span class="toc-text">前端工程化篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack-%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.6.1.</span> <span class="toc-text">webpack 的执行流程和生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack-%E7%9A%84-plugin-%E5%92%8C-loader"><span class="toc-number">4.6.2.</span> <span class="toc-text">webpack 的 plugin 和 loader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack-%E7%9A%84-hash-%E7%AD%96%E7%95%A5"><span class="toc-number">4.6.3.</span> <span class="toc-text">webpack 的 hash 策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vite-%E5%8E%9F%E7%90%86"><span class="toc-number">4.6.4.</span> <span class="toc-text">vite 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack-%E5%92%8C-vite-%E5%AF%B9%E6%AF%94"><span class="toc-number">4.6.5.</span> <span class="toc-text">webpack 和 vite 对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B-wewbpack-%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">4.6.6.</span> <span class="toc-text">做过哪些 wewbpack 的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#npm-run-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">4.6.7.</span> <span class="toc-text">npm run 执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ESM-%E5%92%8C-CJS-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.6.8.</span> <span class="toc-text">ESM 和 CJS 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AF%87"><span class="toc-number">4.7.</span> <span class="toc-text">设计模式篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.7.1.</span> <span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.7.2.</span> <span class="toc-text">装饰者模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.7.3.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.7.4.</span> <span class="toc-text">观察者模式和发布订阅模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">4.8.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.8.1.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">4.8.2.</span> <span class="toc-text">单元测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babel-%E5%8E%9F%E7%90%86%E5%92%8C%E7%94%A8%E9%80%94"><span class="toc-number">4.8.3.</span> <span class="toc-text">babel 原理和用途</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 江承泰</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0</span></button><button id="go-down" type="button" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer data-pjax src="/js/readPercent.js"></script><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script><script async src="/js/console.js"></script><script async src="/js/fps.js"></script><script async src="/js/title.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><script async src="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/categoryBar/categoryBar.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="我,是,真,I ❥ kun" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://b.zhutix.com/bizhi/dmmz/5.jpg);"> <a class="categoryBar-list-link" href="categories/TS全面进阶指南/">TS全面进阶指南</a><span class="categoryBar-list-count">33</span><span class="categoryBar-list-descr">TS相关</span></li><li class="categoryBar-list-item" style="background:url(https://b.zhutix.com/bizhi/dmmz/3.jpg);"> <a class="categoryBar-list-link" href="categories/杂文/">杂文</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">杂篇文章集合</span></li><li class="categoryBar-list-item" style="background:url(https://b.zhutix.com/bizhi/dmmz/4.jpg);"> <a class="categoryBar-list-link" href="categories/React相关/">React相关</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">React相关</span></li><li class="categoryBar-list-item" style="background:url(https://b.zhutix.com/bizhi/dmmz/6.jpg);"> <a class="categoryBar-list-link" href="categories/面试/">面试</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">面试相关</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('home_top');
    var item_html = '<div class="swiper_container_card" style="height: auto;width: 100%"><div id="bannerGroup"><div id="random"><div id="random-banner"><div class="banners-title"><div class="banners-title-big">不露圭角</div><div class="banners-title-big">择时而发</div><div class="banners-title-small">晦养厚积</div></div><div id="skills-style-group-all"><div class="tags-group-wrapper"><div class="tags-group-icon-pair"><div class="tags-group-icon" style="background: #b8f0ae"><img class="no-lightbox" title="Vue" src="https://img02.anzhiy.cn/adminuploads/1/2022/09/25/633001374747b.png"/></div><div class="tags-group-icon" style="background: #222"><img class="no-lightbox" title="React" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9Ii0xMS41IC0xMC4yMzE3NCAyMyAyMC40NjM0OCI+CiAgPHRpdGxlPlJlYWN0IExvZ288L3RpdGxlPgogIDxjaXJjbGUgY3g9IjAiIGN5PSIwIiByPSIyLjA1IiBmaWxsPSIjNjFkYWZiIi8+CiAgPGcgc3Ryb2tlPSIjNjFkYWZiIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiPgogICAgPGVsbGlwc2Ugcng9IjExIiByeT0iNC4yIi8+CiAgICA8ZWxsaXBzZSByeD0iMTEiIHJ5PSI0LjIiIHRyYW5zZm9ybT0icm90YXRlKDYwKSIvPgogICAgPGVsbGlwc2Ugcng9IjExIiByeT0iNC4yIiB0cmFuc2Zvcm09InJvdGF0ZSgxMjApIi8+CiAgPC9nPgo8L3N2Zz4K"/></div></div><div class="tags-group-icon-pair"><div class="tags-group-icon" style="background: #57b6e6"><img class="no-lightbox" title="Docker" src="https://img02.anzhiy.cn/adminuploads/1/2022/09/25/63300647df7fa.png"/></div><div class="tags-group-icon" style="background: #4082c3"><img class="no-lightbox" title="Photoshop" src="https://img02.anzhiy.cn/adminuploads/1/2022/09/25/63300647e1f10.png"/></div></div><div class="tags-group-icon-pair"><div class="tags-group-icon" style="background: #333"><img class="no-lightbox" title="Node" src="https://npm.elemecdn.com/anzhiyu-blog@2.1.1/img/svg/node-logo.svg"/></div><div class="tags-group-icon" style="background: #2e3a41"><img class="no-lightbox" title="Webpack" src="https://img02.anzhiy.cn/adminuploads/1/2022/09/26/6330ff27e5c9b.png"/></div></div><div class="tags-group-icon-pair"><div class="tags-group-icon" style="background: #fff"><img class="no-lightbox" title="Pinia" src="https://npm.elemecdn.com/anzhiyu-blog@2.0.8/img/svg/pinia-logo.svg"/></div><div class="tags-group-icon" style="background: #fff"><img class="no-lightbox" title="Python" src="https://img02.anzhiy.cn/adminuploads/1/2022/09/25/63300647dea51.png"/></div></div><div class="tags-group-icon-pair"><div class="tags-group-icon" style="background: #937df7"><img class="no-lightbox" title="Vite" src="https://npm.elemecdn.com/anzhiyu-blog@2.0.8/img/svg/vite-logo.svg"/></div><div class="tags-group-icon" style="background: #4499e4"><img class="no-lightbox" title="Flutter" src="https://img02.anzhiy.cn/adminuploads/1/2022/09/25/633004063ff15.png"/></div></div><div class="tags-group-icon-pair"><div class="tags-group-icon" style="background: #fff"><img class="no-lightbox" title="Java" src="https://img02.anzhiy.cn/adminuploads/1/2022/09/25/633005bf0fd1e.jpg"/></div><div class="tags-group-icon" style="background: #2c51db"><img class="no-lightbox" title="CSS3" src="https://img02.anzhiy.cn/adminuploads/1/2022/09/25/633006cc55e07.png"/></div></div><div class="tags-group-icon-pair"><div class="tags-group-icon" style="background: #f7cb4f"><img class="no-lightbox" title="JS" src="https://img02.anzhiy.cn/adminuploads/1/2022/09/25/633006eee047b.png"/></div><div class="tags-group-icon" style="background: #e9572b"><img class="no-lightbox" title="HTML" src="https://img02.anzhiy.cn/adminuploads/1/2022/09/25/633006f9ab27d.png"/></div></div><div class="tags-group-icon-pair"><div class="tags-group-icon" style="background: #df5b40"><img class="no-lightbox" title="Git" src="https://img02.anzhiy.cn/adminuploads/1/2022/09/25/633006e37c7fd.webp"/></div><div class="tags-group-icon" style="background: #e65164"><img class="no-lightbox" title="Apifox" src="https://img02.anzhiy.cn/adminuploads/1/2022/09/25/633007087a4dc.webp"/></div></div></div></div></div><a id="random-hover" style="width:100%;height:auto;" href="javascript:toRandomPost()" rel="external nofollow noreferrer" one-link-mark="yes"><i class="fa fa-paper-plane" style="margin-left:10px"></i><div style="margin-left:10px">随便逛逛<i class="fa-solid fa-arrow-right" style="margin-left:10px"></i></div></a></div><div class="categoryGroup"><div class="categoryItem" style="box-shadow: var(--marcus-shadow-blue)"><a class="categoryButton blue" href="/categories/前端/"><span class="categoryButtonText">前端</span><i class="fas fa-dove"></i></a></div><div class="categoryItem" style="box-shadow: var(--marcus-shadow-red)"><a class="categoryButton red" href="/categories/"><span class="categoryButtonText">分类</span><i class="fas fa-burn"></i></a></div><div class="categoryItem" style="box-shadow: var(--marcus-shadow-green)"><a class="categoryButton green" href="/categories/生活/"><span class="categoryButtonText">生活</span><i class="fas fa-book"></i></a></div></div></div><div id="swiper_container_blog"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div><div id="topGroup"><div class="topGroup"></div></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://cdn1.tianli0.top/npm/hexo-butterfly-swiper-marcus/lib/swiper.min.js"></script><script defer data-pjax src="https://cdn1.tianli0.top/npm/hexo-butterfly-swiper-marcus/lib/swiper_init.min.js"></script><script async src="/Marcus/random.js"></script><!-- hexo injector body_end end --></body></html>