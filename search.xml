<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客标题写法与杂项</title>
      <link href="/2023/03/08/%E6%9D%82%E6%96%87/%E5%8D%9A%E5%AE%A2%E6%A0%87%E9%A2%98%E5%86%99%E6%B3%95/"/>
      <url>/2023/03/08/%E6%9D%82%E6%96%87/%E5%8D%9A%E5%AE%A2%E6%A0%87%E9%A2%98%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><table></p><p><thead></p><p><tr></p><p><th>参数</th></p><p><th>功能</th><br>&lt;/tr&gt;<br>&lt;/thead&gt;</p><p><tbody></p><p><tr></p><p><td>title</td></p><p><td>【必需】页面标题</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>date</td></p><p><td>【必需】页面创建日期</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>type</td></p><p><td>【必需】标签、分类和友情链接三个页面需要配置</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>updated</td></p><p><td>【可选】页面更新日期</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>description</td></p><p><td>【可选】页面描述</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>keywords</td></p><p><td>【可选】页面关键字</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>comments</td></p><p><td>【可选】显示页面评论模块(默认 true)</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>top_img</td></p><p><td>【可选】页面顶部图片</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>mathjax</td></p><p><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>katex</td></p><p><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>aside</td></p><p><td>【可选】显示侧边栏 (默认 true)</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>aplayer</td></p><p><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>highlight_shrink</td></p><p><td>【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td><br>&lt;/tr&gt;<br>&lt;/tbody&gt;<br>&lt;/table&gt;<br>&lt;/div&gt;</p><p><h3 id="文章页配置（Post）"><a href="#文章页配置（Post）" class="headerlink" title="文章页配置（Post）"></a>文章页配置（Post）</h3><div class="table-container"></p><p><table></p><p><thead></p><p><tr></p><p><th>参数</th></p><p><th>功能</th><br>&lt;/tr&gt;<br>&lt;/thead&gt;</p><p><tbody></p><p><tr></p><p><td>title</td></p><p><td>【必需】文章标题</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>date</td></p><p><td>【必需】文章创建日期</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>updated</td></p><p><td>【可选】文章更新日期</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>tags</td></p><p><td>【可选】文章标签</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>categories</td></p><p><td>【可选】文章分类</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>keywords</td></p><p><td>【可选】文章关键字</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>description</td></p><p><td>【可选】文章描述</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>top_img</td></p><p><td>【可选】文章顶部图片</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>cover</td></p><p><td>【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>comments</td></p><p><td>【可选】显示文章评论模块(默认 true)</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>toc</td></p><p><td>【可选】显示文章TOC(默认为设置中toc的enable配置)</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>toc_number</td></p><p><td>【可选】显示toc_number(默认为设置中toc的number配置)</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>toc_style_simple</td></p><p><td>【可选】显示 toc 简洁模式</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>copyright</td></p><p><td>【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>copyright_author</td></p><p><td>【可选】文章版权模块的文章作者</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>copyright_author_href</td></p><p><td>【可选】文章版权模块的文章作者链接</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>copyright_url</td></p><p><td>【可选】文章版权模块的文章连结链接</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>copyright_info</td></p><p><td>【可选】文章版权模块的版权声明文字</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>mathjax</td></p><p><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>katex</td></p><p><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>aplayer</td></p><p><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>highlight_shrink</td></p><p><td>【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>aside</td></p><p><td>【可选】显示侧边栏 (默认 true)</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>sticky</td></p><p><td>【可选】文章置顶显示，数值越大，排序越高。最小为1，负数则为置底。</td><br>&lt;/tr&gt;<br>&lt;/tbody&gt;<br>&lt;/table&gt;<br>&lt;/div&gt;</p><p>*以上参数按需使用即可。</p><p>*摘自：<a target="_blank" rel="noopener" href="https://butterfly.js.org/posts/dc584b87/#Page-Front-matter">Butterfly 安装文档(二) 主题页面</a></p><h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><h3 id="QQ"><a href="#QQ" class="headerlink" title="QQ"></a>QQ</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://wpa.qq.com/msgrd?v=3&amp;uin=#####&amp;site=qq&amp;menu=yes</span><br></pre></td></tr></table></figure><p>将链接中的“#####”改为自己的 QQ 号，用户点击链接将跳转到添加好友的界面，若已经是好友则进入聊天对话框。</p><p>（手机端测试无效。）</p><h3 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mailto:#####</span><br></pre></td></tr></table></figure><p>将链接中的“#####”改为自己的邮箱地址，用户点击链接将跳转到 email 应用，手机端可自行选择发送邮件的应用， Windows 端唤起默认应用， Mac 端未测试。</p><h2 id="图标库"><a href="#图标库" class="headerlink" title="图标库"></a>图标库</h2><h3 id="阿里巴巴矢量图标库"><a href="#阿里巴巴矢量图标库" class="headerlink" title="阿里巴巴矢量图标库"></a><a target="_blank" rel="noopener" href="https://www.iconfont.cn/">阿里巴巴矢量图标库</a></h3><p>首先将需要的图标加购购物车，然后添加至项目（如果没有，则新建一个），在 “资源管理” - “我的项目” 里选择 <mark class="hl-label blue">Font_class</mark> 类型，复制 CDN 代码（如果没有，则生成一个）待用。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgtg.com/2023/01/07/GpWti.png" alt=""></p><p>在 Hexo 根目录下，在主题配置 _config.butterfly.yml 文件中的 inject 部分引入</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;//at.alicdn.com/t/c/font_3854537_gjtqti1yoi4.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css&quot;&gt;</span></span><br><span class="line">    <span class="comment"># - xxxxxxxxxx</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">      <span class="comment"># - xxxxxxxxxx</span></span><br></pre></td></tr></table></figure><p>需要注意的是，一旦你的项目发生了变化（新增、删减或修改某个图标），那么就需要重新生成 CDN 代码，并在你的主题配置中更新。</p><h3 id="FontAwesome"><a href="#FontAwesome" class="headerlink" title="FontAwesome"></a><a target="_blank" rel="noopener" href="https://fontawesome.com/">FontAwesome</a></h3><p>这是 Butterfly 自带的图标库，测试发现两个小问题，一是有些特效仅对此图标库有效，换成其他图标库的图标就无效，比如图片旋转；二是有些图标应用后无显示，比如 <mark class="hl-label blue">fa-photo</mark> 等。图标详情可以看这篇博客：<a target="_blank" rel="noopener" href="https://9iphp.com/fa-icons">https://9iphp.com/fa-icons</a></p><p>同样的，该图标库的引用方法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css&quot;&gt;</span></span><br><span class="line">    <span class="comment"># - xxxxxxxxxx</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">      <span class="comment"># - xxxxxxxxxx</span></span><br></pre></td></tr></table></figure><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><h3 id="IMG-TG"><a href="#IMG-TG" class="headerlink" title="IMG.TG"></a><a target="_blank" rel="noopener" href="https://img.tg/">IMG.TG</a></h3><p>本站使用 IMG.TG 图床，这是个4年老图床，单张图片最大支持5MB，采用国内百度云 CDN 节点加速，测试图片打开速度中国大陆基本在 1s 以内。</p><h3 id="聚合图床"><a href="#聚合图床" class="headerlink" title="聚合图床"></a><a target="_blank" rel="noopener" href="https://www.superbed.cn/">聚合图床</a></h3><p>这个图床有丰富的客户端和接口，还可以挂载自己的 OSS、COS、七牛云等存储，自己有足够的盈利措施去长时间运营，并且免费用户的速度也很快，有国内 CDN ，必须登陆后上传。测试图片打开速度国内基本在 1s，免费用户最大上传5MB图。</p><p>更多图床信息可以看以下链接：</p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kjcy8/articles/16648814.html">https://www.cnblogs.com/kjcy8/articles/16648814.html</a></p><p><a target="_blank" rel="noopener" href="https://xlenco.eu.org/posts/7ea9.html">https://xlenco.eu.org/posts/7ea9.html</a></p><h2 id="域名、CDN等"><a href="#域名、CDN等" class="headerlink" title="域名、CDN等"></a>域名、CDN等</h2><p>参考这篇博客：<a target="_blank" rel="noopener" href="https://www.fomal.cc/posts/4aa2d85f.html">https://www.fomal.cc/posts/4aa2d85f.html</a></p><p>本站的域名是从阿里云购买的，DNS配置成了cloudflare的服务器，网站托管用的Vercel，CDN主要用的字节的公共资源库，还有一些是参考的洪哥的。</p><h2 id="压缩与异步加载"><a href="#压缩与异步加载" class="headerlink" title="压缩与异步加载"></a>压缩与异步加载</h2><p>异步加载问题参考这篇博客：<br><a target="_blank" rel="noopener" href="https://akilar.top/posts/615d5ede/">https://akilar.top/posts/615d5ede/</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搞懂这12个Hooks，保证让你玩转React</title>
      <link href="/2023/03/08/React%E7%9B%B8%E5%85%B3/%E6%90%9E%E6%87%82%E8%BF%9912%E4%B8%AAHooks%EF%BC%8C%E4%BF%9D%E8%AF%81%E8%AE%A9%E4%BD%A0%E7%8E%A9%E8%BD%ACReact/"/>
      <url>/2023/03/08/React%E7%9B%B8%E5%85%B3/%E6%90%9E%E6%87%82%E8%BF%9912%E4%B8%AAHooks%EF%BC%8C%E4%BF%9D%E8%AF%81%E8%AE%A9%E4%BD%A0%E7%8E%A9%E8%BD%ACReact/</url>
      
        <content type="html"><![CDATA[<p>我们知道<code>React Hooks</code>有<code>useState</code>设置变量，<code>useEffect</code>副作用，<code>useRef</code>来获取元素的所有属性，还有<code>useMemo</code>、<code>useCallback</code>来做性能优化，当然还有一个<code>自定义Hooks</code>,来创造出你所想要的<code>Hooks</code></p><p>接下来我们来看看以下几个问题，问问自己，是否全都知道：</p><ul><li>Hooks 的由来是什么？</li><li><code>useRef</code>的高级用法是什么？</li><li><code>useMemo</code> 和 <code>useCallback</code> 是怎么做优化的？</li><li>一个好的自定义 Hooks 该如何设计？</li><li>如何做一个不需要<code>useState</code>就可以直接修改属性并刷新视图的自定义 Hooks？</li><li>如何做一个可以监听任何事件的自定义 Hooks？</li></ul><p>如果你对以上问题有疑问，有好奇，那么这篇文章应该能够帮助到你～</p><p>注：这里讲解的自定义钩子可能会和 <code>ahooks</code>上的略有不同，不会考虑过多的情况，如果用于项目，建议直接使用<code>ahooks</code>上的钩子～</p><p>如果有小伙伴不懂<strong>TS</strong>，可以看看我的这篇文章：<a href="https://juejin.cn/post/7088304364078497800" title="https://juejin.cn/post/7088304364078497800">一篇让你完全够用 TS 的指南</a></p><p>先附上一张今天的知识图，还请各位小伙伴多多支持：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddea1c732cfb425da5bedbb2dc1295fe~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="深入 Hooks.png"></p><h1 id="自定义-Hooks-是什么？"><a href="#自定义-Hooks-是什么？" class="headerlink" title="自定义 Hooks 是什么？"></a>自定义 Hooks 是什么？</h1><p><code>react-hooks</code>是<code>React16.8</code>以后新增的钩子 API，目的是增加代码的可复用性、逻辑性，最主要的是解决了<strong>函数式组件无状态的问题</strong>，这样既保留了函数式的简单，又解决了没有数据管理状态的缺陷</p><p>那么什么是自定义 hooks 呢？</p><p><code>自定义hooks</code>是在<code>react-hooks</code>基础上的一个扩展，可以根据业务、需求去制定相应的<code>hooks</code>,将常用的逻辑进行封装，从而具备复用性</p><h2 id="如何设计一个自定义-Hooks"><a href="#如何设计一个自定义-Hooks" class="headerlink" title="如何设计一个自定义 Hooks"></a>如何设计一个自定义 Hooks</h2><p><code>hooks</code>本质上是一个<strong>函数</strong>，而这个函数主要就是<strong>逻辑复用</strong>，我们首先要知道一件事，<code>hooks</code>的驱动条件是什么？</p><p>其实就是<code>props</code>的修改，<code>useState</code>、<code>useReducer</code>的使用是无状态组件更新的条件，从而驱动自定义 hooks</p><h2 id="通用模式"><a href="#通用模式" class="headerlink" title="通用模式"></a>通用模式</h2><p>自定义 hooks 的名称是以<strong>use</strong>开头，我们设计为：</p><blockquote><p>const [ xxx, …] = useXXX(参数一，参数二…)</p></blockquote><h2 id="简单的小例子：usePow"><a href="#简单的小例子：usePow" class="headerlink" title="简单的小例子：usePow"></a>简单的小例子：usePow</h2><p>我们先写一个简单的小例子来了解下<code>自定义hooks</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// usePow.ts</span><span class="token keyword">const</span> <span class="token function-variable function">Index</span> <span class="token operator">=</span> <span class="token punctuation">(</span>list<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> Index<span class="token comment">// index.tsx</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Button <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'antd-mobile'</span><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> useState <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> usePow <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@/components'</span><span class="token keyword">const</span> Index<span class="token operator">:</span> React<span class="token punctuation">.</span><span class="token constant">FC</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>flag<span class="token punctuation">,</span> setFlag<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">boolean</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">usePow</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>数字：<span class="token punctuation">&#123;</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>Button        color<span class="token operator">=</span><span class="token string">"primary"</span>        onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>          <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token operator">!</span>v<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>        切换      <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>切换状态：<span class="token punctuation">&#123;</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> Index<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们简单的写了个 <code>usePow</code>，我们通过 <code>usePow</code> 给所传入的数字平方, 用切换状态的按钮表示函数内部的状态，我们来看看此时的效果：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d21cc3b15e24a8fba7a7cf3f2a89d14~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="img2.gif"></p><p>我们发现了一个问题，为什么点击切换按钮也会触发<code>console.log(1)</code>呢？</p><p>这样明显增加了性能开销，我们的理想状态肯定不希望做无关的渲染，所以我们做自定义 <code>hooks</code>的时候一定要注意，需要<strong>减少性能开销</strong>,我们为组件加入 <code>useMemo</code>试试：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useMemo <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">const</span> <span class="token function-variable function">Index</span> <span class="token operator">=</span> <span class="token punctuation">(</span>list<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">useMemo</span><span class="token punctuation">(</span>    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>      list<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> Index<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3e583fe589a4dacbb0a5a72b2e99cef~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="img3.gif"></p><p>发现此时就已经解决了这个问题，所以要非常注意一点，一个好用的自定义<code>hooks</code>,一定要配合<code>useMemo</code>、<code>useCallback</code>等 Api 一起使用。</p><h1 id="玩转-React-Hooks"><a href="#玩转-React-Hooks" class="headerlink" title="玩转 React Hooks"></a>玩转 React Hooks</h1><p>在上述中我们讲了用 <code>useMemo</code>来处理无关的渲染，接下来我们一起来看看<code>React Hooks</code>的这些钩子的妙用（这里建议先熟知、并使用对应的<code>React Hooks</code>,才能造出好的钩子）</p><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>当一个父组件中调用了一个子组件的时候，父组件的 state 发生变化，会导致父组件更新，而子组件虽然没有发生改变，但也会进行更新。</p><p>简单的理解下，当一个页面内容非常复杂，模块非常多的时候，函数式组件会<strong>从头更新到尾</strong>，只要一处改变，所有的模块都会进行刷新，这种情况显然是没有必要的。</p><p>我们理想的状态是各个模块只进行自己的更新，不要相互去影响，那么此时用<code>useMemo</code>是最佳的解决方案。</p><p>这里要尤其注意一点，<strong>只要父组件的状态更新，无论有没有对自组件进行操作，子组件都会进行更新</strong>，<code>useMemo</code>就是为了防止这点而出现的</p><p>在讲 <code>useMemo</code> 之前，我们先说说<code>memo</code>,<code>memo</code>的作用是<strong>结合了 pureComponent 纯组件和 componentShouldUpdate 功能</strong>，会对传入的 props 进行一次对比，然后根据第二个函数返回值来进一步判断哪些 props 需要更新。（具体使用会在下文讲到～）</p><p><code>useMemo</code>与<code>memo</code>的理念上差不多，都是判断是否满足当前的限定条件来决定是否执行<code>callback</code>函数，而<code>useMemo</code>的第二个参数是一个数组，通过这个数组来判定是否更新回掉函数</p><p>这种方式可以运用在<strong>元素、组件、上下文中</strong>，尤其是利用在数组上，先看一个例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div<span class="token operator">></span>        <span class="token punctuation">&#123;</span>            list<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>                <span class="token operator">&lt;</span>p key<span class="token operator">=</span><span class="token punctuation">&#123;</span>index<span class="token punctuation">&#125;</span><span class="token operator">></span>                    <span class="token punctuation">&#123;</span>item<span class="token punctuation">.</span>name<span class="token punctuation">&#125;</span>                <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span>            <span class="token punctuation">)</span><span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span>list<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面我们看出 <code>useMemo</code>只有在<code>list</code>发生变化的时候才会进行渲染，从而减少了不必要的开销</p><p>总结一下<code>useMemo</code>的好处：</p><ul><li>可以减少不必要的循环和不必要的渲染</li><li>可以减少子组件的渲染次数</li><li>通过特地的依赖进行更新，可以避免很多不必要的开销，但要注意，有时候在配合 <code>useState</code>拿不到最新的值，这种情况可以考虑使用 <code>useRef</code>解决</li></ul><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p><code>useCallback</code>与<code>useMemo</code>极其类似,可以说是一模一样，唯一不同的是<code>useMemo</code>返回的是函数运行的<strong>结果</strong>，而<code>useCallback</code>返回的是<strong>函数</strong></p><p>注意：这个函数是父组件传递子组件的一个函数，防止做无关的刷新，其次，这个组件必须配合<code>memo</code>,否则<strong>不但不会提升性能，还有可能降低性能</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> useState<span class="token punctuation">,</span> useCallback <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Button <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'antd-mobile'</span><span class="token keyword">const</span> MockMemo<span class="token operator">:</span> React<span class="token punctuation">.</span><span class="token constant">FC</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>show<span class="token punctuation">,</span> setShow<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> display<span class="token operator">:</span> <span class="token string">'flex'</span><span class="token punctuation">,</span> justifyContent<span class="token operator">:</span> <span class="token string">'flex-start'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>        <span class="token operator">&lt;</span>TestButton title<span class="token operator">=</span><span class="token string">"普通点击"</span> onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span>TestButton title<span class="token operator">=</span><span class="token string">"useCallback点击"</span> onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span>add<span class="token punctuation">&#125;</span> <span class="token operator">/</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> marginTop<span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>count<span class="token operator">:</span> <span class="token punctuation">&#123;</span>count<span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>Button        onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>          <span class="token function">setShow</span><span class="token punctuation">(</span><span class="token operator">!</span>show<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>        <span class="token punctuation">&#123;</span><span class="token string">' '</span><span class="token punctuation">&#125;</span>        切换      <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> TestButton <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span>props<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>title<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>Button      color<span class="token operator">=</span><span class="token string">"primary"</span>      onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span>props<span class="token punctuation">.</span>onClick<span class="token punctuation">&#125;</span>      style<span class="token operator">=</span><span class="token punctuation">&#123;</span>        props<span class="token punctuation">.</span>title <span class="token operator">===</span> <span class="token string">'useCallback点击'</span>          <span class="token operator">?</span> <span class="token punctuation">&#123;</span>              marginLeft<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>            <span class="token punctuation">&#125;</span>          <span class="token operator">:</span> <span class="token keyword">undefined</span>      <span class="token punctuation">&#125;</span><span class="token operator">></span>      <span class="token punctuation">&#123;</span>props<span class="token punctuation">.</span>title<span class="token punctuation">&#125;</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> MockMemo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c00efe7071b40c583a3d167d073a979~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="img2.gif"></p><p>我们可以看到，当点击切换按钮的时候，没有经过 <code>useCallback</code>封装的函数会再次刷新，而经过 <code>useCallback</code>包裹的函数不会被再次刷新</p><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p><strong>useRef</strong> 可以获取当前元素的所有属性，并且返回一个可变的 ref 对象，并且这个对象<strong>只有 current 属性</strong>，可设置 initialValue</p><h3 id="通过-useRef-获取对应的属性值"><a href="#通过-useRef-获取对应的属性值" class="headerlink" title="通过 useRef 获取对应的属性值"></a>通过 useRef 获取对应的属性值</h3><p>我们先看个案例：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> useState<span class="token punctuation">,</span> useRef <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">const</span> Index<span class="token operator">:</span> React<span class="token punctuation">.</span><span class="token constant">FC</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> scrollRef <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>clientHeight<span class="token punctuation">,</span> setClientHeight<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>scrollTop<span class="token punctuation">,</span> setScrollTop<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>scrollHeight<span class="token punctuation">,</span> setScrollHeight<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token function-variable function">onScroll</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>scrollRef<span class="token operator">?.</span>current<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">let</span> clientHeight <span class="token operator">=</span> scrollRef<span class="token operator">?.</span>current<span class="token punctuation">.</span>clientHeight <span class="token comment">//可视区域高度</span>      <span class="token keyword">let</span> scrollTop <span class="token operator">=</span> scrollRef<span class="token operator">?.</span>current<span class="token punctuation">.</span>scrollTop <span class="token comment">//滚动条滚动高度</span>      <span class="token keyword">let</span> scrollHeight <span class="token operator">=</span> scrollRef<span class="token operator">?.</span>current<span class="token punctuation">.</span>scrollHeight <span class="token comment">//滚动内容高度</span>      <span class="token function">setClientHeight</span><span class="token punctuation">(</span>clientHeight<span class="token punctuation">)</span>      <span class="token function">setScrollTop</span><span class="token punctuation">(</span>scrollTop<span class="token punctuation">)</span>      <span class="token function">setScrollHeight</span><span class="token punctuation">(</span>scrollHeight<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span>p<span class="token operator">></span>可视区域高度：<span class="token punctuation">&#123;</span>clientHeight<span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>        <span class="token operator">&lt;</span>p<span class="token operator">></span>滚动条滚动高度：<span class="token punctuation">&#123;</span>scrollTop<span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>        <span class="token operator">&lt;</span>p<span class="token operator">></span>滚动内容高度：<span class="token punctuation">&#123;</span>scrollHeight<span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>div        style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> height<span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">,</span> overflowY<span class="token operator">:</span> <span class="token string">'auto'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>        ref<span class="token operator">=</span><span class="token punctuation">&#123;</span>scrollRef<span class="token punctuation">&#125;</span>        onScroll<span class="token operator">=</span><span class="token punctuation">&#123;</span>onScroll<span class="token punctuation">&#125;</span><span class="token operator">></span>        <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> height<span class="token operator">:</span> <span class="token number">2000</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> Index<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上述可知，我们可以通过<code>useRef</code>来获取对应元素的相关属性，以此来做一些操作</p><p>效果： <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce0221becc3940ec8610783afa66f5dc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="img1.gif"></p><h3 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h3><p>除了获取对应的属性值外，<code>useRef</code>还有一点比较重要的特性，那就是 <strong>缓存数据</strong></p><p>上述讲到我们封装一个合格的<code>自定义hooks</code>的时候需要结合<strong>useMemo</strong>、<strong>useCallback</strong>等 Api，但我们控制变量的值用<strong>useState</strong> 有可能会导致拿到的是旧值，并且如果他们更新会带来整个组件重新执行，这种情况下，我们使用<strong>useRef</strong>将会是一个非常不错的选择</p><p>在<code>react-redux</code>的源码中，在 hooks 推出后，<code>react-redux</code>用大量的<strong>useMemo</strong>重做了<strong>Provide</strong>等核心模块，其中就是运用<strong>useRef</strong>来缓存数据，并且所运用的 <strong>useRef()</strong> 没有一个是绑定在 dom 元素上的，都是做数据缓存用的</p><p>可以简单的来看一下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 缓存数据</span><span class="token comment">/* react-redux 用userRef 来缓存 merge之后的 props */</span><span class="token keyword">const</span> lastChildProps <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// lastWrapperProps 用 useRef 来存放组件真正的 props信息</span><span class="token keyword">const</span> lastWrapperProps <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>wrapperProps<span class="token punctuation">)</span><span class="token comment">//是否储存props是否处于正在更新状态</span><span class="token keyword">const</span> renderIsScheduled <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment">//更新数据</span><span class="token keyword">function</span> <span class="token function">captureWrapperProps</span><span class="token punctuation">(</span>  <span class="token parameter">lastWrapperProps<span class="token punctuation">,</span>  lastChildProps<span class="token punctuation">,</span>  renderIsScheduled<span class="token punctuation">,</span>  wrapperProps<span class="token punctuation">,</span>  actualChildProps<span class="token punctuation">,</span>  childPropsFromStoreUpdate<span class="token punctuation">,</span>  notifyNestedSubs</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  lastWrapperProps<span class="token punctuation">.</span>current <span class="token operator">=</span> wrapperProps  lastChildProps<span class="token punctuation">.</span>current <span class="token operator">=</span> actualChildProps  renderIsScheduled<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到 <code>react-redux</code> 用重新赋值的方法，改变了缓存的数据源，减少了不必要的更新，如过采取<code>useState</code>势必会重新渲染</p><h3 id="useLatest"><a href="#useLatest" class="headerlink" title="useLatest"></a>useLatest</h3><p>经过上面的讲解我们知道<code>useRef</code> 可以拿到最新值，我们可以进行简单的封装，这样做的好处是：<strong>可以随时确保获取的是最新值，并且也可以解决闭包问题</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useRef <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">const</span> useLatest <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>  ref<span class="token punctuation">.</span>current <span class="token operator">=</span> value  <span class="token keyword">return</span> ref<span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> useLatest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结合-useMemo-和-useRef-封装-useCreation"><a href="#结合-useMemo-和-useRef-封装-useCreation" class="headerlink" title="结合 useMemo 和 useRef 封装 useCreation"></a>结合 useMemo 和 useRef 封装 useCreation</h3><p><strong>useCreation</strong> ：是 <code>useMemo</code> 或 <code>useRef</code>的替代品。换言之，<code>useCreation</code>这个钩子增强了 <code>useMemo</code> 和 <code>useRef</code>，让这个钩子可以替换这两个钩子。（来自<a href="https://ahooks.js.org/zh-CN/hooks/use-creation" title="https://ahooks.js.org/zh-CN/hooks/use-creation">ahooks-useCreation</a>）</p><ul><li><code>useMemo</code>的值不一定是最新的值，但<code>useCreation</code>可以保证拿到的值一定是最新的值</li><li>对于复杂常量的创建，<code>useRef</code>容易出现潜在的的性能隐患，但<code>useCreation</code>可以避免</li></ul><p>这里的性能隐患是指：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 每次重渲染，都会执行实例化 Subject 的过程，即便这个实例立刻就被扔掉了</span><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Subject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 通过 factory 函数，可以避免性能隐患</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token function">useCreation</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Subject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们来看看如何封装一个<code>useCreation</code>,首先我们要明白以下三点：</p><ul><li>第一点：先确定参数，<code>useCreation</code> 的参数与<code>useMemo</code>的一致，第一个参数是函数，第二个参数参数是可变的数组</li><li>第二点：我们的值要保存在 <code>useRef</code>中，这样可以将值缓存，从而减少无关的刷新</li><li>第三点：更新值的判断，怎么通过第二个参数来判断是否更新 <code>useRef</code>里的值。</li></ul><p>明白了一上三点我们就可以自己实现一个<code>useCreation</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useRef <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> DependencyList <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">const</span> depsAreSame <span class="token operator">=</span> <span class="token punctuation">(</span>  oldDeps<span class="token operator">:</span> DependencyList<span class="token punctuation">,</span>  deps<span class="token operator">:</span> DependencyList<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldDeps <span class="token operator">===</span> deps<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> oldDeps<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 判断两个值是否是同一个值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Object<span class="token punctuation">.</span><span class="token keyword">is</span><span class="token punctuation">(</span>oldDeps<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> deps<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> useCreation <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">T</span><span class="token punctuation">,</span> deps<span class="token operator">:</span> DependencyList<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> current <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    deps<span class="token punctuation">,</span>    obj<span class="token operator">:</span> <span class="token keyword">undefined</span> <span class="token keyword">as</span> <span class="token keyword">undefined</span> <span class="token operator">|</span> <span class="token constant">T</span><span class="token punctuation">,</span>    initialized<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>initialized <span class="token operator">===</span> <span class="token boolean">false</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">depsAreSame</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>deps<span class="token punctuation">,</span> deps<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    current<span class="token punctuation">.</span>deps <span class="token operator">=</span> deps    current<span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    current<span class="token punctuation">.</span>initialized <span class="token operator">=</span> <span class="token boolean">true</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> current<span class="token punctuation">.</span>obj <span class="token keyword">as</span> <span class="token constant">T</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> useCreation<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>useRef</code>判断是否更新值通过<code>initialized</code> 和 <code>depsAreSame</code>来判断，其中<code>depsAreSame</code>通过存储在 <code>useRef</code>下的<code>deps</code>(旧值) 和 新传入的 <code>deps</code>（新值）来做对比，判断两数组的数据是否一致，来确定是否更新</p><h3 id="验证-useCreation"><a href="#验证-useCreation" class="headerlink" title="验证 useCreation"></a>验证 useCreation</h3><p>接下来我们写个小例子，来验证下 <code>useCreation</code>是否能满足我们的要求：</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> useState <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Button <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'antd-mobile'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useCreation <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@/components'</span><span class="token keyword">const</span> Index<span class="token operator">:</span> React<span class="token punctuation">.</span><span class="token constant">FC</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>_<span class="token punctuation">,</span> setFlag<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">boolean</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token function-variable function">getNowData</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> nowData <span class="token operator">=</span> <span class="token function">useCreation</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">getNowData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">style</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> padding<span class="token operator">:</span> <span class="token number">50</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">正常的函数： </span><span class="token punctuation">&#123;</span><span class="token function">getNowData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">useCreation包裹后的： </span><span class="token punctuation">&#123;</span>nowData<span class="token punctuation">&#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Button</span></span>        <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>primary<span class="token punctuation">"</span></span>        <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>          <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token operator">!</span>v<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text">        </span><span class="token punctuation">&#123;</span><span class="token string">' '</span><span class="token punctuation">&#125;</span><span class="token plain-text">        渲染      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Button</span></span><span class="token punctuation">></span></span><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> Index<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa5645ef84d141878142032ae2079bdc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="useCreation.gif"></p><p>我们可以看到，当我们做无关的<code>state</code>改变的时候，正常的函数也会刷新，但<code>useCreation</code>没有刷新，从而增强了渲染的性能～</p><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p><code>useEffect</code>相信各位小伙伴已经用的熟的不能再熟了，我们可以使用<code>useEffect</code>来模拟下<code>class</code>的<code>componentDidMount</code>和<code>componentWillUnmount</code>的功能。</p><h3 id="useMount"><a href="#useMount" class="headerlink" title="useMount"></a>useMount</h3><p>这个钩子不必多说，只是简化了使用<code>useEffect</code>的第二个参数：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useEffect <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">const</span> <span class="token function-variable function">useMount</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    fn<span class="token operator">?.</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> useMount<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="useUnmount"><a href="#useUnmount" class="headerlink" title="useUnmount"></a>useUnmount</h3><p>这个需要注意一个点，就是使用<code>useRef</code>来确保所传入的函数为最新的状态，所以可以结合上述讲的<strong>useLatest</strong>结合使用</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useEffect<span class="token punctuation">,</span> useRef <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">const</span> <span class="token function-variable function">useUnmount</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>  ref<span class="token punctuation">.</span>current <span class="token operator">=</span> fn  <span class="token function">useEffect</span><span class="token punctuation">(</span>    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      ref<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> useUnmount<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结合useMount和useUnmount做个小例子"><a href="#结合useMount和useUnmount做个小例子" class="headerlink" title="结合useMount和useUnmount做个小例子"></a>结合<code>useMount</code>和<code>useUnmount</code>做个小例子</h3><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Button<span class="token punctuation">,</span> Toast <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'antd-mobile'</span><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> useState <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useMount<span class="token punctuation">,</span> useUnmount <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@/components'</span><span class="token keyword">const</span> <span class="token function-variable function">Child</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token function">useMount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    Toast<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token string">'首次渲染'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token function">useUnmount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    Toast<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token string">'组件已卸载'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span>你好，我是小杜杜<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> Index<span class="token operator">:</span> React<span class="token punctuation">.</span><span class="token constant">FC</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>flag<span class="token punctuation">,</span> setFlag<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">boolean</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> padding<span class="token operator">:</span> <span class="token number">50</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>      <span class="token operator">&lt;</span>Button        color<span class="token operator">=</span><span class="token string">"primary"</span>        onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>          <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token operator">!</span>v<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>        切换 <span class="token punctuation">&#123;</span>flag <span class="token operator">?</span> <span class="token string">'unmount'</span> <span class="token operator">:</span> <span class="token string">'mount'</span><span class="token punctuation">&#125;</span>      <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>      <span class="token punctuation">&#123;</span>flag <span class="token operator">&amp;&amp;</span> <span class="token operator">&lt;</span>Child <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">&#125;</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> Index<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下： <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27b1cfa623a944eb9056b62eeafaba5f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="img5.gif"></p><h3 id="useUpdate"><a href="#useUpdate" class="headerlink" title="useUpdate"></a>useUpdate</h3><p><strong>useUpdate</strong>:强制更新</p><p>有的时候我们需要组件强制更新，这个时候就可以使用这个钩子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useCallback<span class="token punctuation">,</span> useState <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">const</span> <span class="token function-variable function">useUpdate</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> useUpdate<span class="token comment">//示例：</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Button <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'antd-mobile'</span><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useUpdate <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@/components'</span><span class="token keyword">const</span> Index<span class="token operator">:</span> React<span class="token punctuation">.</span><span class="token constant">FC</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> update <span class="token operator">=</span> <span class="token function">useUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> padding<span class="token operator">:</span> <span class="token number">50</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>时间：<span class="token punctuation">&#123;</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>Button color<span class="token operator">=</span><span class="token string">"primary"</span> onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span>update<span class="token punctuation">&#125;</span><span class="token operator">></span>        更新时间      <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> Index<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbe4ebe0e17f439693b48eac899e3f67~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="img6.gif"></p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="案例-1-useReactive"><a href="#案例-1-useReactive" class="headerlink" title="案例 1: useReactive"></a>案例 1: useReactive</h2><p><strong>useReactive</strong>: 一种具备<strong>响应式</strong>的<code>useState</code></p><p>缘由：我们知道用<code>useState</code>可以定义变量其格式为：</p><p><code>const [count, setCount] = useState&lt;number&gt;(0)</code></p><p>通过<code>setCount</code>来设置，<code>count</code>来获取，使用这种方式才能够渲染视图</p><p>来看看正常的操作，像这样 <code>let count = 0; count =7</code> 此时<code>count</code>的值就是 7，也就是说数据是响应式的</p><p>那么我们可不可以将 <code>useState</code>也写成<strong>响应式</strong>的呢？我可以自由设置<strong>count 的值,并且可以随时获取到 count 的最新值</strong>，而不是通过<code>setCount</code>来设置。</p><p>我们来想想怎么去实现一个具备 <strong>响应式</strong> 特点的 <code>useState</code> 也就是 <code>useRective</code>,提出以下疑问，感兴趣的，可以先自行思考一下：</p><ul><li>这个钩子的出入参该怎么设定？</li><li>如何将数据制作成响应式（毕竟普通的操作无法刷新视图）？</li><li>如何使用<code>TS</code>去写，完善其类型？</li><li>如何更好的去优化？</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>以上四个小问题，最关键的就是<code>第二个</code>，我们如何将数据弄成<strong>响应式</strong>，想要弄成响应式，就必须监听到值的变化，在做出更改，也就是说，我们对这个数进行操作的时候，要进行相应的<strong>拦截</strong>，这时就需要<code>ES6</code>的一个知识点：<strong>Proxy</strong></p><p>在这里会用到 <strong>Proxy</strong>和<strong>Reflect</strong>的点，感兴趣的可以看看我的这篇文章：<a href="https://juejin.cn/post/7068935394191998990#heading-36" title="https://juejin.cn/post/7068935394191998990#heading-36">🔥 花一个小时，迅速了解 ES6~ES12 的全部特性</a></p><p><strong>Proxy</strong>：接受的参数是<strong>对象</strong>，所以第一个问题也解决了，入参就为对象。那么如何去刷新视图呢？这里就使用上述的<strong>useUpdate</strong>来强制刷新，使数据更改。</p><p>至于优化这一块，使用上文说的<code>useCreation</code>就好，再配合<code>useRef</code>来放<code>initialState</code>即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useRef <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useUpdate<span class="token punctuation">,</span> useCreation <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'../index'</span><span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">></span></span><span class="token operator">></span><span class="token punctuation">(</span>  initialVal<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span>  <span class="token function-variable function">cb</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span><span class="token punctuation">(</span>initialVal<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token keyword">typeof</span> res <span class="token operator">===</span> <span class="token string">'object'</span>        <span class="token operator">?</span> <span class="token function">observer</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> cb<span class="token punctuation">)</span>        <span class="token operator">:</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> ret <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>      <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> ret    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> proxy<span class="token punctuation">&#125;</span><span class="token keyword">const</span> useReactive <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">></span></span><span class="token operator">></span><span class="token punctuation">(</span>initialState<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>initialState<span class="token punctuation">)</span>  <span class="token keyword">const</span> update <span class="token operator">=</span> <span class="token function">useUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">useCreation</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">observer</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span>current<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> state<span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> useReactive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里先说下<code>TS</code>，因为我们不知道会传递什么类型的<code>initialState</code>所以在这需要使用<strong>泛型</strong>，我们接受的参数是<strong>对象</strong>，可就是 key-value 的形式，其中 key 为 string，value 可以是 任意类型，所以我们使用 <code>Record&lt;string, any&gt;</code></p><p>有不熟悉的小伙伴可以看看我的这篇文章： <a href="https://juejin.cn/post/7088304364078497800#heading-82" title="https://juejin.cn/post/7088304364078497800#heading-82">一篇让你完全够用 TS 的指南</a>（又推销一遍，有点打广告，别在意～）</p><p>再来说下<code>拦截这块</code>,我们只需要拦截<strong>设置（set）</strong> 和 <strong>获取（get）</strong> 即可，其中：</p><ul><li>设置这块，需要改变是图，也就是说需要，使用<strong>useUpdate</strong>来强制刷新</li><li>获取这块，需要判断其是否为对象，是的话继续递归，不是的话返回就行</li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>接下来我们来验证一下我们写的 <code>useReactive</code>,我们将以 字符串、数字、布尔、数组、函数、计算属性几个方面去验证一下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Button <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'antd-mobile'</span><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useReactive <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@/components'</span><span class="token keyword">const</span> Index<span class="token operator">:</span> React<span class="token punctuation">.</span><span class="token constant">FC</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useReactive</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    name<span class="token operator">:</span> <span class="token string">'小杜杜'</span><span class="token punctuation">,</span>    flag<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    arr<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    bugs<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'小杜杜'</span><span class="token punctuation">,</span> <span class="token string">'react'</span><span class="token punctuation">,</span> <span class="token string">'hook'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token function">addBug</span><span class="token punctuation">(</span>bug<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>bugs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>bug<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token keyword">get</span> <span class="token function">bugsCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>bugs<span class="token punctuation">.</span>length    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> padding<span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>      <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> fontWeight<span class="token operator">:</span> <span class="token string">'bold'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>基本使用：<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> marginTop<span class="token operator">:</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span> 对数字进行操作：<span class="token punctuation">&#123;</span>state<span class="token punctuation">.</span>count<span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>div        style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>          margin<span class="token operator">:</span> <span class="token string">'8px 0'</span><span class="token punctuation">,</span>          display<span class="token operator">:</span> <span class="token string">'flex'</span><span class="token punctuation">,</span>          justifyContent<span class="token operator">:</span> <span class="token string">'flex-start'</span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>        <span class="token operator">&lt;</span>Button color<span class="token operator">=</span><span class="token string">"primary"</span> onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> state<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">&#125;</span><span class="token operator">></span>          加<span class="token number">1</span>        <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>        <span class="token operator">&lt;</span>Button          color<span class="token operator">=</span><span class="token string">"primary"</span>          style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> marginLeft<span class="token operator">:</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>          onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> state<span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">&#125;</span><span class="token operator">></span>          减<span class="token number">1</span>        <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>        <span class="token operator">&lt;</span>Button          color<span class="token operator">=</span><span class="token string">"primary"</span>          style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> marginLeft<span class="token operator">:</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>          onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token operator">></span>          设置为<span class="token number">7</span>        <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> marginTop<span class="token operator">:</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span> 对字符串进行操作：<span class="token punctuation">&#123;</span>state<span class="token punctuation">.</span>name<span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>div        style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>          margin<span class="token operator">:</span> <span class="token string">'8px 0'</span><span class="token punctuation">,</span>          display<span class="token operator">:</span> <span class="token string">'flex'</span><span class="token punctuation">,</span>          justifyContent<span class="token operator">:</span> <span class="token string">'flex-start'</span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>        <span class="token operator">&lt;</span>Button color<span class="token operator">=</span><span class="token string">"primary"</span> onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'小杜杜'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token operator">></span>          设置为小杜杜        <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>        <span class="token operator">&lt;</span>Button          color<span class="token operator">=</span><span class="token string">"primary"</span>          style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> marginLeft<span class="token operator">:</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>          onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Domesy'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token operator">></span>          设置为Domesy        <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> marginTop<span class="token operator">:</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>        <span class="token punctuation">&#123;</span><span class="token string">' '</span><span class="token punctuation">&#125;</span>        对布尔值进行操作：<span class="token punctuation">&#123;</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>flag<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>div        style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>          margin<span class="token operator">:</span> <span class="token string">'8px 0'</span><span class="token punctuation">,</span>          display<span class="token operator">:</span> <span class="token string">'flex'</span><span class="token punctuation">,</span>          justifyContent<span class="token operator">:</span> <span class="token string">'flex-start'</span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>        <span class="token operator">&lt;</span>Button color<span class="token operator">=</span><span class="token string">"primary"</span> onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token operator">!</span>state<span class="token punctuation">.</span>flag<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token operator">></span>          切换状态        <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> marginTop<span class="token operator">:</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>        <span class="token punctuation">&#123;</span><span class="token string">' '</span><span class="token punctuation">&#125;</span>        对数组进行操作：<span class="token punctuation">&#123;</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>arr<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>div        style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>          margin<span class="token operator">:</span> <span class="token string">'8px 0'</span><span class="token punctuation">,</span>          display<span class="token operator">:</span> <span class="token string">'flex'</span><span class="token punctuation">,</span>          justifyContent<span class="token operator">:</span> <span class="token string">'flex-start'</span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>        <span class="token operator">&lt;</span>Button          color<span class="token operator">=</span><span class="token string">"primary"</span>          onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> state<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token operator">></span>          push        <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>        <span class="token operator">&lt;</span>Button          color<span class="token operator">=</span><span class="token string">"primary"</span>          style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> marginLeft<span class="token operator">:</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>          onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> state<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token operator">></span>          pop        <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>        <span class="token operator">&lt;</span>Button          color<span class="token operator">=</span><span class="token string">"primary"</span>          style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> marginLeft<span class="token operator">:</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>          onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> state<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token operator">></span>          shift        <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>        <span class="token operator">&lt;</span>Button          color<span class="token operator">=</span><span class="token string">"primary"</span>          style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> marginLeft<span class="token operator">:</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>          onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> state<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token operator">></span>          unshift        <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>        <span class="token operator">&lt;</span>Button          color<span class="token operator">=</span><span class="token string">"primary"</span>          style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> marginLeft<span class="token operator">:</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>          onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> state<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token operator">></span>          reverse        <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>        <span class="token operator">&lt;</span>Button          color<span class="token operator">=</span><span class="token string">"primary"</span>          style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> marginLeft<span class="token operator">:</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>          onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> state<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token operator">></span>          sort        <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> fontWeight<span class="token operator">:</span> <span class="token string">'bold'</span><span class="token punctuation">,</span> marginTop<span class="token operator">:</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>计算属性：<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> marginTop<span class="token operator">:</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>数量：<span class="token punctuation">&#123;</span>state<span class="token punctuation">.</span>bugsCount<span class="token punctuation">&#125;</span> 个<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> margin<span class="token operator">:</span> <span class="token string">'8px 0'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>        <span class="token operator">&lt;</span>form          onSubmit<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            state<span class="token punctuation">.</span>bug <span class="token operator">?</span> state<span class="token punctuation">.</span><span class="token function">addBug</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>bug<span class="token punctuation">)</span> <span class="token operator">:</span> state<span class="token punctuation">.</span><span class="token function">addBug</span><span class="token punctuation">(</span><span class="token string">'domesy'</span><span class="token punctuation">)</span>            state<span class="token punctuation">.</span>bug <span class="token operator">=</span> <span class="token string">''</span>            e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>          <span class="token operator">&lt;</span>input            type<span class="token operator">=</span><span class="token string">"text"</span>            value<span class="token operator">=</span><span class="token punctuation">&#123;</span>state<span class="token punctuation">.</span>bug<span class="token punctuation">&#125;</span>            onChange<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span>bug <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>          <span class="token operator">/</span><span class="token operator">></span>          <span class="token operator">&lt;</span>button type<span class="token operator">=</span><span class="token string">"submit"</span> style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> marginLeft<span class="token operator">:</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>            增加          <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>          <span class="token operator">&lt;</span>Button            color<span class="token operator">=</span><span class="token string">"primary"</span>            style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> marginLeft<span class="token operator">:</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>            onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> state<span class="token punctuation">.</span>bugs<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token operator">></span>            删除          <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>ul<span class="token operator">></span>        <span class="token punctuation">&#123;</span>state<span class="token punctuation">.</span>bugs<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>bug<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> index<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>          <span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token punctuation">&#123;</span>index<span class="token punctuation">&#125;</span><span class="token operator">></span><span class="token punctuation">&#123;</span>bug<span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>      <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> Index<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9571ffdbb94c478bbb34e8b37d9c454f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="useuse.gif"></p><h2 id="案例-2-useEventListener"><a href="#案例-2-useEventListener" class="headerlink" title="案例 2: useEventListener"></a>案例 2: useEventListener</h2><p>缘由：我们监听各种事件的时候需要做监听，如：监听点击事件、键盘事件、滚动事件等，我们将其统一封装起来，方便后续调用</p><p>说白了就是在<code>addEventListener</code>的基础上进行封装，我们先来想想在此基础上需要什么？</p><p>首先，<code>useEventListener</code>的入参可分为三个</p><ul><li>第一个<code>event</code>是事件（如：click、keydown）</li><li>第二个回调函数（所以不需要出参）</li><li>第三个就是目标（是某个节点还是全局）</li></ul><p>在这里需要注意一点就是在<strong>销毁的时候需要移除对应的监听事件</strong></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useEffect <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">const</span> <span class="token function-variable function">useEventListener</span> <span class="token operator">=</span> <span class="token punctuation">(</span>  event<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>  <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token operator">...</span>e<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">,</span>  target<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> window<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> targetElement <span class="token operator">=</span> <span class="token string">'current'</span> <span class="token keyword">in</span> target <span class="token operator">?</span> target<span class="token punctuation">.</span>current <span class="token operator">:</span> window    <span class="token keyword">const</span> <span class="token function-variable function">useEventListener</span> <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token operator">:</span> Event<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token function">handler</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    targetElement<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> useEventListener<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      targetElement<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> useEventListener<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> useEventListener<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：这里把<code>target</code>默认设置成了<code>window</code>，至于为什么要这么写：<code>&#39;current&#39; in target</code>是因为我们用<code>useRef</code>拿到的值都是 <code>ref.current</code></p><h3 id="支持-SSR（优化）"><a href="#支持-SSR（优化）" class="headerlink" title="支持 SSR（优化）"></a>支持 SSR（优化）</h3><p>在原本的 ahooks 代码中，会用到<code>useEffectWithTarget</code>，一开搞错了，以为这个是类似于<code>useCreation</code>的优化作用，其实不是，这么做的目的是为了支持<code>SSR</code></p><p>因为<code>SSR</code>的类型是 <code>() =&gt; HTMLElement</code>， 如果将这个作为<code>useEffect</code>的参数，那么就相当于<code>deps</code>不存在，也就是有其他变量改变时，<code>useEffect</code>都会执行，所以为了全面支持<code>target</code>动态变化，才会有这个<code>useEffectWithTarget</code>的诞生～</p><h3 id="详细代码"><a href="#详细代码" class="headerlink" title="详细代码"></a>详细代码</h3><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useEffect <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> DependencyList <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useRef <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> useLatest <span class="token keyword">from</span> <span class="token string">'../useLatest'</span><span class="token keyword">import</span> useUnmount <span class="token keyword">from</span> <span class="token string">'../useUnmount'</span><span class="token keyword">const</span> depsAreSame <span class="token operator">=</span> <span class="token punctuation">(</span>  oldDeps<span class="token operator">:</span> DependencyList<span class="token punctuation">,</span>  deps<span class="token operator">:</span> DependencyList<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> oldDeps<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Object<span class="token punctuation">.</span><span class="token keyword">is</span><span class="token punctuation">(</span>oldDeps<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> deps<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token function-variable function">useEffectTarget</span> <span class="token operator">=</span> <span class="token punctuation">(</span>  <span class="token function-variable function">effect</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">,</span>  deps<span class="token operator">:</span> DependencyList<span class="token punctuation">,</span>  target<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> hasInitRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment">// 一开始设置初始化</span>  <span class="token keyword">const</span> elementRef <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token punctuation">(</span>Element <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 存储具体的值</span>  <span class="token keyword">const</span> depsRef <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span>DependencyList<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 存储传递的deps</span>  <span class="token keyword">const</span> unmountRef <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 存储对应的effect</span>  <span class="token comment">// 初始化 组件的初始化和更新都会执行</span>  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> targetElement <span class="token operator">=</span> <span class="token string">'current'</span> <span class="token keyword">in</span> target <span class="token operator">?</span> target<span class="token punctuation">.</span>current <span class="token operator">:</span> window    <span class="token comment">// 第一遍赋值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasInitRef<span class="token punctuation">.</span>current<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      hasInitRef<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token boolean">true</span>      elementRef<span class="token punctuation">.</span>current <span class="token operator">=</span> targetElement      depsRef<span class="token punctuation">.</span>current <span class="token operator">=</span> deps      unmountRef<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 校验变值: 目标的值不同， 依赖值改变</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>      elementRef<span class="token punctuation">.</span>current <span class="token operator">!==</span> targetElement <span class="token operator">||</span>      <span class="token operator">!</span><span class="token function">depsAreSame</span><span class="token punctuation">(</span>deps<span class="token punctuation">,</span> depsRef<span class="token punctuation">.</span>current<span class="token punctuation">)</span>    <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//先执行对应的函数</span>      unmountRef<span class="token punctuation">.</span>current<span class="token operator">?.</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment">//重新进行赋值</span>      elementRef<span class="token punctuation">.</span>current <span class="token operator">=</span> targetElement      depsRef<span class="token punctuation">.</span>current <span class="token operator">=</span> deps      unmountRef<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token function">useUnmount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    unmountRef<span class="token punctuation">.</span>current<span class="token operator">?.</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    hasInitRef<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token boolean">false</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token function-variable function">useEventListener</span> <span class="token operator">=</span> <span class="token punctuation">(</span>  event<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>  <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token operator">...</span>e<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">,</span>  target<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> window<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> handlerRef <span class="token operator">=</span> <span class="token function">useLatest</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span>  <span class="token function">useEffectTarget</span><span class="token punctuation">(</span>    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> targetElement <span class="token operator">=</span> <span class="token string">'current'</span> <span class="token keyword">in</span> target <span class="token operator">?</span> target<span class="token punctuation">.</span>current <span class="token operator">:</span> window      <span class="token comment">//  防止没有 addEventListener 这个属性</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>targetElement<span class="token operator">?.</span>addEventListener<span class="token punctuation">)</span> <span class="token keyword">return</span>      <span class="token keyword">const</span> <span class="token function-variable function">useEventListener</span> <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token operator">:</span> Event<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> handlerRef<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>      targetElement<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> useEventListener<span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        targetElement<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> useEventListener<span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">,</span>    target  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> useEventListener<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在这里只用<code>useEffect</code>是因为，在更新和初始化的情况下都需要使用</li><li>必须要防止没有 <code>addEventListener</code>这个属性的情况，监听的目标有可能没有加载出来</li></ul><h3 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h3><p>验证一下<code>useEventListener</code>是否能够正常的使用，顺变验证一下初始化、卸载的，代码：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> useState<span class="token punctuation">,</span> useRef <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useEventListener <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@/components'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Button <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'antd-mobile'</span><span class="token keyword">const</span> Index<span class="token operator">:</span> React<span class="token punctuation">.</span><span class="token constant">FC</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>flag<span class="token punctuation">,</span> setFlag<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">boolean</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> setKey<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token function">useEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">=></span> v <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ref<span class="token punctuation">)</span>  <span class="token function">useEventListener</span><span class="token punctuation">(</span><span class="token string">'keydown'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>ev<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setKey</span><span class="token punctuation">(</span>ev<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> padding<span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>      <span class="token operator">&lt;</span>Button        color<span class="token operator">=</span><span class="token string">"primary"</span>        onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>          <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token operator">!</span>v<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>        切换 <span class="token punctuation">&#123;</span>flag <span class="token operator">?</span> <span class="token string">'unmount'</span> <span class="token operator">:</span> <span class="token string">'mount'</span><span class="token punctuation">&#125;</span>      <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>      <span class="token punctuation">&#123;</span>flag <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>        <span class="token operator">&lt;</span>div<span class="token operator">></span>          <span class="token operator">&lt;</span>div<span class="token operator">></span>数字：<span class="token punctuation">&#123;</span>count<span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>          <span class="token operator">&lt;</span>button ref<span class="token operator">=</span><span class="token punctuation">&#123;</span>ref<span class="token punctuation">&#125;</span><span class="token operator">></span>加<span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>          <span class="token operator">&lt;</span>div<span class="token operator">></span>监听键盘事件：<span class="token punctuation">&#123;</span>key<span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token punctuation">)</span><span class="token punctuation">&#125;</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> Index<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dbb36ddad2d41f9917b8db7355d283a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="useEvent.gif"></p><p>我们可以利用<code>useEventListener</code>这个钩子去封装其他钩子，如 鼠标悬停，长按事件，鼠标位置等，在这里在举一个鼠标悬停的小例子</p><h3 id="小例子-useHover"><a href="#小例子-useHover" class="headerlink" title="小例子 useHover"></a>小例子 useHover</h3><p><strong>useHover</strong>：监听 DOM 元素是否有鼠标悬停</p><p>这个就很简单了，只需要通过 <code>useEventListener</code>来监听<code>mouseenter</code>和<code>mouseleave</code>即可，在返回布尔值就行了：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useState <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> useEventListener <span class="token keyword">from</span> <span class="token string">'../useEventListener'</span><span class="token keyword">interface</span> <span class="token class-name">Options</span> <span class="token punctuation">&#123;</span>  onEnter<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span>  onLeave<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> useHover <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> options<span class="token operator">?</span><span class="token operator">:</span> Options<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>flag<span class="token punctuation">,</span> setFlag<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">boolean</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> onEnter<span class="token punctuation">,</span> onLeave <span class="token punctuation">&#125;</span> <span class="token operator">=</span> options <span class="token operator">||</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token function">useEventListener</span><span class="token punctuation">(</span>    <span class="token string">'mouseenter'</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      onEnter<span class="token operator">?.</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    target  <span class="token punctuation">)</span>  <span class="token function">useEventListener</span><span class="token punctuation">(</span>    <span class="token string">'mouseleave'</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      onLeave<span class="token operator">?.</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    target  <span class="token punctuation">)</span>  <span class="token keyword">return</span> flag<span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> useHover<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d77611b1d33647e689398e380f1fdb16~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="useHover.gif"></p><h2 id="案例-3-有关时间的-Hooks"><a href="#案例-3-有关时间的-Hooks" class="headerlink" title="案例 3: 有关时间的 Hooks"></a>案例 3: 有关时间的 Hooks</h2><p>在这里主要介绍有关时间的三个 hooks,分别是：<code>useTimeout</code>、<code>useInterval</code>和<code>useCountDown</code></p><h3 id="useTimeout"><a href="#useTimeout" class="headerlink" title="useTimeout"></a>useTimeout</h3><p><strong>useTimeout</strong>：一段时间内，执行一次</p><p>传递参数只要函数和延迟时间即可，需要注意的是卸载的时候将定时器清除下就 OK 了</p><p>详细代码：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useEffect <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> useLatest <span class="token keyword">from</span> <span class="token string">'../useLatest'</span><span class="token keyword">const</span> useTimeout <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">,</span> delay<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> fnRef <span class="token operator">=</span> <span class="token function">useLatest</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>delay <span class="token operator">||</span> delay <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span>    <span class="token keyword">const</span> timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      fnRef<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>delay<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> useTimeout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果展示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38ea46cb005e4b7e92979bc56ffb76f9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="img3.gif"></p><h3 id="useInterval"><a href="#useInterval" class="headerlink" title="useInterval"></a>useInterval</h3><p><strong>useInterval</strong>: 每过一段时间内一直执行</p><p>大体上与<code>useTimeout</code>一样，多了一个是否要首次渲染的参数<code>immediate</code></p><p>详细代码：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useEffect <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> useLatest <span class="token keyword">from</span> <span class="token string">'../useLatest'</span><span class="token keyword">const</span> useInterval <span class="token operator">=</span> <span class="token punctuation">(</span>  <span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">,</span>  delay<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>  immediate<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> fnRef <span class="token operator">=</span> <span class="token function">useLatest</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>delay <span class="token operator">||</span> delay <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>immediate<span class="token punctuation">)</span> fnRef<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      fnRef<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token function">clearInterval</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>delay<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> useInterval<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果展示： <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47b323c0e8b04546a5a30f51b9eb3488~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="img4.gif"></p><h3 id="useCountDown"><a href="#useCountDown" class="headerlink" title="useCountDown"></a>useCountDown</h3><p><strong>useCountDown</strong>：简单控制倒计时的钩子</p><p>跟之前一样我们先来想想这个钩子需要什么：</p><ul><li>我们要做倒计时的钩子首先需要一个目标时间（targetDate），控制时间变化的秒数（interval 默认为 1s），然后就是倒计时完成后所触发的函数（onEnd）</li><li>返参就更加一目了然了，返回的是两个时间差的数值（time），再详细点可以换算成对应的天、时、分等（formattedRes）</li></ul><h4 id="详细代码-1"><a href="#详细代码-1" class="headerlink" title="详细代码"></a>详细代码</h4><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useState<span class="token punctuation">,</span> useEffect<span class="token punctuation">,</span> useMemo <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> useLatest <span class="token keyword">from</span> <span class="token string">'../useLatest'</span><span class="token keyword">import</span> dayjs <span class="token keyword">from</span> <span class="token string">'dayjs'</span><span class="token keyword">type</span> <span class="token class-name">DTime</span> <span class="token operator">=</span> Date <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token keyword">interface</span> <span class="token class-name">Options</span> <span class="token punctuation">&#123;</span>  targetDate<span class="token operator">?</span><span class="token operator">:</span> DTime  interval<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span>  onEnd<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">FormattedRes</span> <span class="token punctuation">&#123;</span>  days<span class="token operator">:</span> <span class="token builtin">number</span>  hours<span class="token operator">:</span> <span class="token builtin">number</span>  minutes<span class="token operator">:</span> <span class="token builtin">number</span>  seconds<span class="token operator">:</span> <span class="token builtin">number</span>  milliseconds<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token function-variable function">calcTime</span> <span class="token operator">=</span> <span class="token punctuation">(</span>time<span class="token operator">:</span> DTime<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>time<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">dayjs</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//计算差值</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>  <span class="token keyword">return</span> res<span class="token punctuation">&#125;</span><span class="token keyword">const</span> parseMs <span class="token operator">=</span> <span class="token punctuation">(</span>milliseconds<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> FormattedRes <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>    days<span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>milliseconds <span class="token operator">/</span> <span class="token number">86400000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    hours<span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>milliseconds <span class="token operator">/</span> <span class="token number">3600000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">24</span><span class="token punctuation">,</span>    minutes<span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>milliseconds <span class="token operator">/</span> <span class="token number">60000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">60</span><span class="token punctuation">,</span>    seconds<span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>milliseconds <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">60</span><span class="token punctuation">,</span>    milliseconds<span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>milliseconds<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token function-variable function">useCountDown</span> <span class="token operator">=</span> <span class="token punctuation">(</span>options<span class="token operator">?</span><span class="token operator">:</span> Options<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> targetDate<span class="token punctuation">,</span> interval <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">,</span> onEnd <span class="token punctuation">&#125;</span> <span class="token operator">=</span> options <span class="token operator">||</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>time<span class="token punctuation">,</span> setTime<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">calcTime</span><span class="token punctuation">(</span>targetDate<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> onEndRef <span class="token operator">=</span> <span class="token function">useLatest</span><span class="token punctuation">(</span>onEnd<span class="token punctuation">)</span>  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>targetDate<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">setTime</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">setTime</span><span class="token punctuation">(</span><span class="token function">calcTime</span><span class="token punctuation">(</span>targetDate<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token function">calcTime</span><span class="token punctuation">(</span>targetDate<span class="token punctuation">)</span>      <span class="token function">setTime</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">clearInterval</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>        onEndRef<span class="token punctuation">.</span>current<span class="token operator">?.</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> interval<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>targetDate<span class="token punctuation">,</span> interval<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> formattedRes <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">parseMs</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>time<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">[</span>time<span class="token punctuation">,</span> formattedRes<span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token keyword">const</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> useCountDown<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="验证-2"><a href="#验证-2" class="headerlink" title="验证"></a>验证</h4><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> useState <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useCountDown <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@/components'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Button<span class="token punctuation">,</span> Toast <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'antd-mobile'</span><span class="token keyword">const</span> Index<span class="token operator">:</span> React<span class="token punctuation">.</span><span class="token constant">FC</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>_<span class="token punctuation">,</span> formattedRes<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useCountDown</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    targetDate<span class="token operator">:</span> <span class="token string">'2022-12-31 24:00:00'</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> days<span class="token punctuation">,</span> hours<span class="token punctuation">,</span> minutes<span class="token punctuation">,</span> seconds<span class="token punctuation">,</span> milliseconds <span class="token punctuation">&#125;</span> <span class="token operator">=</span> formattedRes  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>countdown<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useCountDown</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    targetDate<span class="token operator">:</span> count<span class="token punctuation">,</span>    <span class="token function-variable function">onEnd</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      Toast<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token string">'结束'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> padding<span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>        <span class="token punctuation">&#123;</span><span class="token string">' '</span><span class="token punctuation">&#125;</span>        距离 <span class="token number">2022</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">31</span> <span class="token number">24</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> 还有 <span class="token punctuation">&#123;</span>days<span class="token punctuation">&#125;</span> 天 <span class="token punctuation">&#123;</span>hours<span class="token punctuation">&#125;</span> 时 <span class="token punctuation">&#123;</span>minutes<span class="token punctuation">&#125;</span> 分 <span class="token punctuation">&#123;</span>          seconds        <span class="token punctuation">&#125;</span> 秒 <span class="token punctuation">&#123;</span>milliseconds<span class="token punctuation">&#125;</span> 毫秒      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> marginTop<span class="token operator">:</span> <span class="token number">12</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span>动态变化：<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>        <span class="token operator">&lt;</span>Button          color<span class="token operator">=</span><span class="token string">"primary"</span>          disabled<span class="token operator">=</span><span class="token punctuation">&#123;</span>countdown <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">&#125;</span>          onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token operator">></span>          <span class="token punctuation">&#123;</span>countdown <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">'开始'</span> <span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">还有 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>countdown <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">s</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">&#125;</span>        <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>        <span class="token operator">&lt;</span>Button style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> marginLeft<span class="token operator">:</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token operator">></span>          停止        <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> Index<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="效果展示："><a href="#效果展示：" class="headerlink" title="效果展示："></a>效果展示：</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f41eaef407564c86b27aac51c4539da2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="img5.gif"></p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://ahooks.js.org/zh-CN/hooks/use-request/index" title="https://ahooks.js.org/zh-CN/hooks/use-request/index">ahooks</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单的做下总结：</p><ul><li>一个优秀的 hooks 一定会具备<code>useMemo</code>、<code>useCallback</code>等 api 优化</li><li>制作自定义 hooks 遇到传递过来的值，优先考虑使用<code>useRef</code>，再考虑用<code>useState</code>，可以直接使用<code>useLatest</code>，防止拿到的值不是最新值</li><li>在封装的时候，应该将存放的值放入 <code>useRef</code>中，通过一个状态去设置他的初始化，在判断什么情况下来更新所对应的值，明确入参与出参的具体意义，如<code>useCreation</code>和<code>useEventListener</code></li></ul><h2 id="盘点"><a href="#盘点" class="headerlink" title="盘点"></a>盘点</h2><p>本文一共讲解了 12 个自定义 hooks，分别是：<code>usePow</code>、<code>useLatest</code>、<code>useCreation</code>、<code>useMount</code>、<code>useUnmount</code>、<code>useUpdate</code>、<code>useReactive</code>、<code>useEventListener</code>、<code>useHover</code>、<code>useTimeout</code>、<code>useInterval</code>、<code>useCountDown</code></p><p>这里的素材来源为 ahooks，但与 ahooks 的不是完全一样，有兴趣的小伙伴可以结合<code>ahooks</code>源码对比来看，自己动手敲敲，加深理解</p><p><code>react</code>其他好文：</p><ul><li><a href="https://juejin.cn/post/7103345085089054727" title="https://juejin.cn/post/7103345085089054727">作为一名 React，我是这样理解 HOC 的！</a></li><li><a href="https://juejin.cn/post/7116326409961734152" title="https://juejin.cn/post/7116326409961734152">「React 深入」一文吃透虚拟 DOM 和 diff 算法</a></li><li><a href="https://juejin.cn/post/7121551701731409934" title="https://juejin.cn/post/7121551701731409934">花三个小时，完全掌握分片渲染和虚拟列表～</a></li><li><a href="https://juejin.cn/post/7124486630483689485" title="https://juejin.cn/post/7124486630483689485">「React 深入」一文吃透 React v18 全部 Api（1.3w+）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> React相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.开篇：用正确的方式学习 TypeScript</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/1.%E5%BC%80%E7%AF%87%EF%BC%9A%E7%94%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%20TypeScript/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/1.%E5%BC%80%E7%AF%87%EF%BC%9A%E7%94%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%20TypeScript/</url>
      
        <content type="html"><![CDATA[<p>最近，软件开发设计公司 The Software House 针对 2022 年前端市场状态的调查显示，84% 的受访者都在使用 TypeScript，43% 的受访者甚至认为 TypeScript 将超越 JavaScript 成为前端开发的主要语言。</p><p>无论 TypeScript 是否会超越 JavaScript，可以肯定的是，TypeScript 已被开发人员普遍接受，和 ES6 语法以及前端框架一起，被视为前端开发领域的基础工具。但是，关于 TypeScript 的质疑却一直没有减少，比如：</p><ul><li>TypeScript 限制了 JavaScript 的灵活性；</li><li>TypeScript 并不能提高应用程序的性能；</li><li>TypeScript 开发需要更多额外的类型代码。</li></ul><p>这些质疑其实可以归纳为一点：<strong>TypeScript 会影响实际项目的开发效率</strong>。事实真的是这样吗？</p><h2 id="为什么说-TypeScript-可能超越-JavaScript？"><a href="#为什么说-TypeScript-可能超越-JavaScript？" class="headerlink" title="为什么说 TypeScript 可能超越 JavaScript？"></a>为什么说 TypeScript 可能超越 JavaScript？</h2><p>我们知道，JavaScript 一直以灵活性著称。在实际开发时，我们不需要确定一个变量的类型，就能直接访问可能并不存在的属性，所以无需为每一步操作都定义类型。在小型项目中，这种灵活性可以有效提高开发效率，帮助我们掌控全局。</p><p>但随着项目规模的增大，这些变量类型的数量也会成倍增加，你总有记错、遗漏的时候。此时，灵活性就变成了埋在项目内的定时炸弹。在《<a href="https://link.juejin.cn/?target=https%3A%2F%2Frollbar.com%2Fblog%2Ftop-10-javascript-errors%2F">Top 10 JavaScript errors from 1000+ projects</a>》 中，最常见的错误就是 <code>Cannot read property &#39;xxx&#39; of undefined</code>、<code>undefined is not a function</code> 等。这些错误就是我们过度依赖灵活性的后果，一旦它们被触发，就会导致你的页面白屏、卡死，甚至崩溃。</p><p><strong>要解决灵活性带来的隐患，我们需要的是类型。更准确地说，是项目开发时的类型检查能力。</strong> TypeScript 通过易上手且功能强大的类型系统，为 JavaScript 提供了强大的类型检查能力。在类型的帮助下，我们无需实际运行代码，就能通过类型的流转观察到变量的值是如何改变的。同时，类型的标记也能帮助我们确保每一处访问、赋值与操作的类型是符合预期的，有效减少我们需要承受的心智负担。</p><p>由于类型的引入，<strong>TypeScript 的确限制了 JavaScript 的灵活性，但也增强了项目代码的健壮性</strong>，并且对于其他同属于灵活性的代表特性，如 this、原型链、闭包以及函数等，TypeScript 丝毫没有限制。</p><p>但是，想要获得类型的帮助，我们需要额外的类型代码。这会影响开发效率吗？会有影响，但更多是正向的。</p><p>首先，要实现类型的精确标注，我们并不一定需要大量的类型代码。就像你给变量 A 新增一些属性得到变量 B，你会完全重新声明这两个变量的值吗？不会。在类型层面也是一样，变量 B 的类型会基于变量 A 的类型派生得到，它们并不是两个完全独立的类型。基于这一方式，我们就能让类型之间存在紧密的关联，减少冗余的类型代码。</p><p>其次，当项目规模增大到某一阈值后，这些类型代码会是你开发时最得力的助手，让你有底气大胆地进行各种逻辑操作，不需要先把这些值都打印出来确认一遍。同时，由于 TypeScript 强大的类型推导能力，随着你对变量进行各种操作，TypeScript 就会自动地推导出变量最终的类型。你只需要确保类型符合，最终的结果就是符合你预期的。而在你敲击下 <code>.</code> 来访问一个变量的属性时，TypeScript 也会将所有的属性展示出来供你挑选。这就是类型代码对开发效率的提升所在。</p><p>而在最终编译时，TypeScript 又会将这些类型代码抹除，还给你可以直接放进浏览器里跑的、纯粹的 JavaScript 代码。因此，TypeScript 确实不能提高应用程序的性能，因为最终运行的仍然是 JavaScript。</p><p>总的来说，TypeScript 对开发效率的影响和项目的规模息息相关。在小项目中，TypeScript 确实不可避免地降低了项目的开发效率。但如果我们放眼于项目的整个生命周期，得益于严密的类型检查与如臂使指的类型推导，TypeScript 不仅避免了 JavaScript 灵活性可能会带来的隐患，还能让你在面对 Bug 时更快地定位问题，让程序跑得更稳定一些！从这个方面来说，TypeScript 对开发效率的提升是终身制的。</p><h2 id="如何系统学习-TypeScript？"><a href="#如何系统学习-TypeScript？" class="headerlink" title="如何系统学习 TypeScript？"></a>如何系统学习 TypeScript？</h2><p>随着越来越多的前端开发者开始尝试学习和使用 TypeScript，理论上 TypeScript 应该已经完全取代 JavaScript 了，但实际上并没有。一方面，就像我们前面所说，项目规模较小或部分开发者仍然更偏爱灵活的 JavaScript 。另一方面，作为 JavaScript 中不存在的概念，类型能力相关的学习成本让很多开发者停留在入门阶段，无法前进。</p><p>许多时候，<strong>高昂的学习成本往往来自于我们对 TypeScript 不正确的认知，以及错误的学习路径</strong>。比如说，有人认为“把类型相关的概念学习完就算掌握 TypeScript 了”，有人过了一遍文档和社区文章，简单地上手使用一下，就觉得自己的 TypeScript 水平已经相当不错了。</p><p>首先，通过社区资源自学并没有什么问题，但好内容太少，找起来也需要很多时间。其次，任何知识点都不能孤立地学习。不然在实际开发时，遇到一个复杂点的类型编程场景，我们就束手无策了。</p><p>那么，我们到底该怎么学习 TypeScript 呢？<strong>学习没有捷径，最好的学习方法就是先建立起对事物的全面认知，然后由浅入深地系统学习。</strong> 这里的“全面”如何理解？我们首先要了解 TypeScript 是由哪些部分组成的。相对严谨来说，TypeScript 由三个部分组成：<strong>类型、语法与工程</strong>。我们可以从这三个部分入手，来建立起一个全面、系统的学习路径。</p><p>首先是<strong>类型能力</strong>。它是最核心的部分，也是学习成本最高的部分。它为 JavaScript 中的变量、函数等概念提供了类型的标注，同时内置了一批类型工具，基于这些类型工具我们就能实现更复杂的类型描述，将类型关联起来。你可以从最简单的类型开始，每学到一个新的类型能力就添加上去，思考它和已掌握部分的交相融合，以此一步步掌握整个类型系统。</p><p>接着是<strong>语法部分</strong>。TypeScript 提前支持了一些已经到达 Stage 3 / 4 阶段，或是比较重要的 TC39 提案，比如使用最多的可选链（<code>?.</code>）、空值合并（<code>??</code>）、装饰器等，这些语法都已经或即将成为 ECMAScript Next 的新成员。在 TypeScript 中使用这些新语法时，你只需要简单的配置就能实现语法的降级，让编译后的代码可以运行在更低的浏览器或 Node 版本下。这一部分几乎没有学习成本，他们就像语言的 API，你只需要多提醒自己去使用，及时查询官方文档就能熟悉了。</p><p>类型能力与新语法确实很棒，但浏览器不认怎么办？TypeScript 会在构建时被抹除类型代码与语法的降级。这一能力就是通过 TypeScript Compiler（tsc）实现的。tsc 以及 tsc 配置（TSConfig）是 TypeScript 工程层面的重要部分。除此以外，TypeScript 工程能力的另一重要体现就是，我们可以通过类型声明的方式，在 TypeScript 中愉快地使用 JavaScript 社区的大量 npm 包。</p><p>类型、语法、工程其实也代表了三个不同阶段使用 TypeScript 目的：<strong>为 JavaScript 代码添加类型与类型检查来确保健壮性，提前使用新语法或新特性来简化代码，以及最终获得可用的 JavaScript 代码。因此，类型-语法-工程，也是学习 TypeScript 的最佳路径。</strong></p><h2 id="这门课程是如何设计的？"><a href="#这门课程是如何设计的？" class="headerlink" title="这门课程是如何设计的？"></a>这门课程是如何设计的？</h2><p>按照我们上面讲到的学习路径，这门课程也将分为<strong>类型能力篇、语法篇和工程实践篇</strong>。从下图中也能看出，我们会将重点更多地放在类型部分。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/214c20c9e0314b8ca2a6c9cecc45e7bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>我们会从 TypeScript 的类型基础开始学习，然后到泛型、条件类型等这些首次见面的类型工具。在这些类型工具的学习与使用中，我们会遇到许多困惑。这时不妨转换下方向，来了解 TypeScript 的类型系统，包括它是如何进行类型比较的，以及整个类型世界的运行规则是怎样的。这一步将帮助你从根源上理解 TypeScript 的类型能力设计与底层运行规则。</p><p>掌握了类型工具与类型系统后，我们才会学习类型能力最复杂的概念：类型编程。这部分我们会从内置工具类型讲解到内置工具类型进阶，带你循序渐进地掌握类型编程中的 4 大范式。</p><p>通过这一路线，你将建立起全面的 TypeScript 类型能力知识体系，懂得如何结合使用各种类型工具来进行类型编程，如何独立解决各种类型报错，以及最重要的能力——理解类型世界的基本规则与运行规律。</p><p>迈过了类型这座大山以后，我们将面对新朋友：语法，它们比类型部分轻松友好多了。我们会从 TypeScript 与 ECMAScript 的关系开始说起，介绍这些新语法的使用，对其中的重量级角色装饰器，我们更会搭配实战。</p><p>在最后的工程部分，除了我们已经提到的 tsc 以及 TSConfig ，我们还会有更多的工程场景实战，类型声明与类型指令，与 React / ESLint 等框架或工具的紧密结合，开发并部署一个基于 TypeScript 的 Node API 。就像这本小册的名字《 TypeScript 全面进阶指南 》一样，我们的目标是全方位、无死角地掌握 TypeScript 。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>无论你处于哪个阶段，只要想开始学习 TypeScript，这门课程就是适合你的。只要你沿着课程中给出的路线，完成这一路上的各种任务，就一定能从新手成功迈向高级玩家。</p><p>同时我也希望，你可以把它当作一本备忘手册，时常回顾和翻阅。比如说，当你忘记了 never 类型的具体意义，当你忘记了 tsconfig 的某一个配置具体作用，当你忘记了某一类工具类型的实现原理，你都可以回来在小册中找到答案。</p><p>最后，也欢迎你在交流群或 GitHub 仓库的 issue 区，与我交流 TypeScript 学习路上的问题。除了与其他读者互相交流解惑以外，我也会安排固定的答疑时间来统一解决问题，期待与你一同进步。</p><blockquote><h2 id="课程中的代码"><a href="#课程中的代码" class="headerlink" title="课程中的代码"></a>课程中的代码</h2><p>小册中的所有代码都会存放在 <strong><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book">TypeScript-Tiny-Book</a></strong> 这个仓库里，基于 Monorepo 架构来隔离了各个不同部分的示例代码，同时在每一节也会给出对应代码的地址。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10.结构化类型系统：类型兼容性判断的幕后</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/10.%E7%BB%93%E6%9E%84%E5%8C%96%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7%E5%88%A4%E6%96%AD%E7%9A%84%E5%B9%95%E5%90%8E/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/10.%E7%BB%93%E6%9E%84%E5%8C%96%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7%E5%88%A4%E6%96%AD%E7%9A%84%E5%B9%95%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<p>在 TypeScript 中，你可能遇见过以下这样“看起来不太对，但竟然能正常运行”的代码：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token punctuation">&#123;</span>  <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">&#123;</span>  <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">feedCat</span><span class="token punctuation">(</span>cat<span class="token operator">:</span> Cat<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token function">feedCat</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 <code>feedCat</code> 函数明明需要的是一只猫，可为什么上传一只狗也可以呢？实际上，这就是 TypeScript 的类型系统特性：<strong>结构化类型系统</strong>，也是我们这一节要学习的概念。我们会了解结构化类型系统的比较方式，对比另一种类型系统（<strong>标称类型系统</strong>）的工作方式，以及在 TypeScript 中去模拟另一种类型系统。</p><p>结构化类型系统的概念非常基础但十分重要，它不仅能让你明确类型比较的核心原理，从根上理解条件类型等类型工具，也能够在日常开发中帮你解决许多常见的类型报错。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F07-structual-type-system">Structual Type System</a></p></blockquote><h2 id="结构化类型系统"><a href="#结构化类型系统" class="headerlink" title="结构化类型系统"></a>结构化类型系统</h2><p>首先回到我们开头提出的问题，如果我们为 Cat 类新增一个独特的方法，这个时候的表现才是符合预期的，即我们只能用真实的 Cat 类来进行调用：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token punctuation">&#123;</span>  <span class="token function">meow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">&#123;</span>  <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">feedCat</span><span class="token punctuation">(</span>cat<span class="token operator">:</span> Cat<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 报错！</span><span class="token function">feedCat</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为，TypeScript 比较两个类型并非通过类型的名称（即 <code>feedCat</code> 函数只能通过 Cat 类型调用），而是比较这两个类型上实际拥有的属性与方法。也就是说，这里实际上是比较 Cat 类型上的属性是否都存在于 Dog 类型上。</p><p>在我们最初的例子里，Cat 与 Dog 类型上的方法是一致的，所以它们虽然是两个名字不同的类型，但仍然被视为结构一致，这就是结构化类型系统的特性。你可能听过结构类型的别称<strong>鸭子类型（*Duck Typing*）</strong>，这个名字来源于<strong>鸭子测试（*Duck Test*）</strong>。其核心理念是，<strong>如果你看到一只鸟走起来像鸭子，游泳像鸭子，叫得也像鸭子，那么这只鸟就是鸭子</strong>。</p><p>也就说，鸭子类型中两个类型的关系是通过对象中的属性方法来判断的。比如最开始的 Cat 类型和 Dog 类型被视为同一个类型，而为 Cat 类型添加独特的方法之后就不再能被视为一个类型。但如果为 Dog 类型添加一个独特方法呢？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token punctuation">&#123;</span>  <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">&#123;</span>  <span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">feedCat</span><span class="token punctuation">(</span>cat<span class="token operator">:</span> Cat<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token function">feedCat</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候为什么却没有类型报错了？这是因为，结构化类型系统认为 Dog 类型完全实现了 Cat 类型。至于额外的方法 <code>bark</code>，可以认为是 Dog 类型继承 Cat 类型后添加的新方法，即此时 Dog 类可以被认为是 Cat 类的子类。同样的，面向对象编程中的里氏替换原则也提到了鸭子测试：<strong><em>如果它看起来像鸭子，叫起来也像鸭子，但是却需要电池才能工作，那么你的抽象很可能出错了。</em></strong></p><p>更进一步，在比较对象类型的属性时，同样会采用结构化类型系统进行判断。而对结构中的函数类型（即方法）进行比较时，同样存在类型的兼容性比较：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token punctuation">&#123;</span>  <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">&#123;</span>  <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">599</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">feedCat</span><span class="token punctuation">(</span>cat<span class="token operator">:</span> Cat<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 报错！</span><span class="token function">feedCat</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>对于独立函数类型的进一步比较，我们会在后面的「函数类型的比较：类型系统中的协变与逆变」一节中深入讲解。</p></blockquote><p>这就是结构化类型系统的核心理念，即基于类型结构进行判断类型兼容性。结构化类型系统在 C#、Python、Objective-C 等语言中都被广泛使用或支持。</p><p>严格来说，鸭子类型系统和结构化类型系统并不完全一致，结构化类型系统意味着<strong>基于完全的类型结构来判断类型兼容性</strong>，而鸭子类型则只基于<strong>运行时访问的部分</strong>来决定。也就是说，如果我们调用了走、游泳、叫这三个方法，那么传入的类型只需要存在这几个方法即可（而不需要类型结构完全一致）。但由于 TypeScript 本身并不是在运行时进行类型检查（也做不到），同时官方文档中同样认为这两个概念是一致的（<strong><em>One of TypeScript’s core principles is that type checking focuses on the shape that values have. This is sometimes called “duck typing” or “structural typing”.</em></strong>）。因此在这里，我们可以直接认为鸭子类型与结构化类型是同一概念。</p><p>除了<strong>基于类型结构进行兼容性判断的结构化类型系统</strong>以外，还有一种<strong>基于类型名进行兼容性判断的类型系统</strong>，标称类型系统。</p><h2 id="标称类型系统"><a href="#标称类型系统" class="headerlink" title="标称类型系统"></a>标称类型系统</h2><p>标称类型系统（<strong>Nominal Typing System</strong>）要求，两个可兼容的类型，<strong>其名称必须是完全一致的</strong>，比如以下代码：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">USD</span></span> <span class="token operator">=</span> <span class="token builtin">number</span><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">CNY</span></span> <span class="token operator">=</span> <span class="token builtin">number</span><span class="token keyword">const</span> CNYCount<span class="token operator">:</span> <span class="token constant">CNY</span> <span class="token operator">=</span> <span class="token number">200</span><span class="token keyword">const</span> USDCount<span class="token operator">:</span> <span class="token constant">USD</span> <span class="token operator">=</span> <span class="token number">200</span><span class="token keyword">function</span> <span class="token function">addCNY</span><span class="token punctuation">(</span>source<span class="token operator">:</span> <span class="token constant">CNY</span><span class="token punctuation">,</span> input<span class="token operator">:</span> <span class="token constant">CNY</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> source <span class="token operator">+</span> input<span class="token punctuation">&#125;</span><span class="token function">addCNY</span><span class="token punctuation">(</span>CNYCount<span class="token punctuation">,</span> USDCount<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在结构化类型系统中，USD 与 CNY （分别代表美元单位与人民币单位）被认为是两个完全一致的类型，因此在 <code>addCNY</code> 函数中可以传入 USD 类型的变量。这就很离谱了，人民币与美元这两个单位实际的意义并不一致，怎么能进行相加？</p><p>在标称类型系统中，CNY 与 USD 被认为是两个完全不同的类型，因此能够避免这一情况发生。在《编程与类型系统》一书中提到，类型的重要意义之一是<strong>限制了数据的可用操作与实际意义</strong>，这一点在标称类型系统中的体现要更加明显。比如，上面我们可以通过类型的结构，来让结构化类型系统认为两个类型具有父子类型关系，而对于标称类型系统，父子类型关系只能通过显式的继承来实现，称为<strong>标称子类型（Nominal Subtyping）</strong>。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 实现一只短毛猫！</span><span class="token keyword">class</span> <span class="token class-name">ShorthairCat</span> <span class="token keyword">extends</span> <span class="token class-name">Cat</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>C++、Java、Rust 等语言中都主要使用标称类型系统。那么，我们是否可以在 TypeScript 中模拟出标称类型系统？</p><h2 id="在-TypeScript-中模拟标称类型系统"><a href="#在-TypeScript-中模拟标称类型系统" class="headerlink" title="在 TypeScript 中模拟标称类型系统"></a>在 TypeScript 中模拟标称类型系统</h2><p>再看一遍这句话：<strong>类型的重要意义之一是限制了数据的可用操作与实际意义</strong>。这往往是通过类型附带的<strong>额外信息</strong>来实现的（类似于元数据），要在 TypeScript 中实现，其实我们也只需要为类型额外附加元数据即可，比如 CNY 与 USD，我们分别附加上它们的单位信息即可，但同时又需要保留原本的信息（即原本的 number 类型）。</p><p>我们可以通过交叉类型的方式来实现信息的附加：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">declare</span> <span class="token keyword">class</span> <span class="token class-name">TagProtector<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">protected</span> __tag__<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Nominal<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">&amp;</span> TagProtector<span class="token operator">&lt;</span><span class="token constant">U</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里我们使用 TagProtector 声明了一个具有 <code>protected</code> 属性的类，使用它来携带额外的信息，并和原本的类型合并到一起，就得到了 Nominal 工具类型。</p><p>有了 Nominal 这个工具类型，我们可以尝试来改进下上面的例子了：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name"><span class="token constant">CNY</span></span> <span class="token operator">=</span> Nominal<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token string">'CNY'</span><span class="token operator">></span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name"><span class="token constant">USD</span></span> <span class="token operator">=</span> Nominal<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token string">'USD'</span><span class="token operator">></span><span class="token keyword">const</span> CNYCount <span class="token operator">=</span> <span class="token number">100</span> <span class="token keyword">as</span> <span class="token constant">CNY</span><span class="token keyword">const</span> USDCount <span class="token operator">=</span> <span class="token number">100</span> <span class="token keyword">as</span> <span class="token constant">USD</span><span class="token keyword">function</span> <span class="token function">addCNY</span><span class="token punctuation">(</span>source<span class="token operator">:</span> <span class="token constant">CNY</span><span class="token punctuation">,</span> input<span class="token operator">:</span> <span class="token constant">CNY</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>source <span class="token operator">+</span> input<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token constant">CNY</span><span class="token punctuation">&#125;</span><span class="token function">addCNY</span><span class="token punctuation">(</span>CNYCount<span class="token punctuation">,</span> CNYCount<span class="token punctuation">)</span><span class="token comment">// 报错了！</span><span class="token function">addCNY</span><span class="token punctuation">(</span>CNYCount<span class="token punctuation">,</span> USDCount<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一实现方式本质上只在类型层面做了数据的处理，在运行时无法进行进一步的限制。我们还可以从逻辑层面入手进一步确保安全性：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">CNY</span></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> __tag<span class="token operator">!</span><span class="token operator">:</span> <span class="token keyword">void</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> value<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">USD</span></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> __tag<span class="token operator">!</span><span class="token operator">:</span> <span class="token keyword">void</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> value<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相应的，现在使用方式也要进行变化：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> CNYCount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">CNY</span></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token keyword">const</span> USDCount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">USD</span></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">addCNY</span><span class="token punctuation">(</span>source<span class="token operator">:</span> <span class="token constant">CNY</span><span class="token punctuation">,</span> input<span class="token operator">:</span> <span class="token constant">CNY</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> source<span class="token punctuation">.</span>value <span class="token operator">+</span> input<span class="token punctuation">.</span>value<span class="token punctuation">&#125;</span><span class="token function">addCNY</span><span class="token punctuation">(</span>CNYCount<span class="token punctuation">,</span> CNYCount<span class="token punctuation">)</span><span class="token comment">// 报错了！</span><span class="token function">addCNY</span><span class="token punctuation">(</span>CNYCount<span class="token punctuation">,</span> USDCount<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过这种方式，我们可以在运行时添加更多的检查逻辑，同时在类型层面也得到了保障。</p><p>这两种方式的本质都是通过非公开（即 <code>private</code> / <code>protected</code> ）的额外属性实现了类型信息的附加，从而使得结构化类型系统将结构一致的两个类型也视为不兼容的。另外，在 type-fest 中也通过 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fcodemix.com%2Fopaque-types-in-javascript%2F">Opaque Type</a> 支持了类似的功能，其实现如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">const</span> tag<span class="token operator">:</span> unique <span class="token builtin">symbol</span><span class="token keyword">declare</span> <span class="token keyword">type</span> <span class="token class-name">Tagged<span class="token operator">&lt;</span>Token<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">readonly</span> <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token operator">:</span> Token<span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Opaque<span class="token operator">&lt;</span>Type<span class="token punctuation">,</span> Token <span class="token operator">=</span> <span class="token builtin">unknown</span><span class="token operator">></span></span> <span class="token operator">=</span> Type <span class="token operator">&amp;</span> Tagged<span class="token operator">&lt;</span>Token<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结一下，在 TypeScript 中我们可以通过类型或者逻辑的方式来模拟标称类型，这两种方式其实并没有非常明显的优劣之分，基于类型实现更加轻量，你的代码逻辑不会受到影响，但难以进行额外的逻辑检查工作。而使用逻辑实现稍显繁琐，但你能够进行更进一步或更细致的约束。</p><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节中，我们了解了 TypeScript 的结构化类型系统是<strong>基于类型结构进行比较</strong>的，而标称类型系统是<strong>基于类型名来进行比较</strong>的。以及在 TypeScript 中，如何通过<strong>为类型附加信息</strong>的方式，从<strong>类型层面</strong>或者<strong>逻辑层面</strong>出发去模拟标称类型系统。如果你在实际上的业务代码中遇到过单位转换这种类型问题，不妨考虑使用这种方式，来进一步提升项目中类型的安全性。</p><p>我想，这一节或许能够解答你曾经有过的，“为什么这两个类型竟然是能被视为兼容问题”，“为什么这两个类型明明是父子关系却说不兼容”等问题。同时在后面的条件类型、类型层级等内容中，也还会有结构化类型系统出场的部分。</p><p>下一节，我们要来了解一个 TypeScript 中常常被忽略的部分，也就是 TypeScript 的类型层级。我们都知道，变量的类型之间需要存在兼容性才能进行赋值，而按照这个兼容性一层层地扩展出来，我们就得到了 TypeScript 类型系统中的类型层级，了解类型层级以后再学习条件类型与工具类型，简直不要太 easy。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="类型、类型系统与类型检查"><a href="#类型、类型系统与类型检查" class="headerlink" title="类型、类型系统与类型检查"></a>类型、类型系统与类型检查</h3><p>对于类型、类型系统、类型检查，你可以认为它们是不同的概念。</p><ul><li>类型：限制了数据的可用操作、意义、允许的值的集合，总的来说就是<strong>访问限制</strong>与<strong>赋值限制</strong>。在 TypeScript 中即是原始类型、对象类型、函数类型、字面量类型等基础类型，以及类型别名、联合类型等经过类型编程后得到的类型。</li><li>类型系统：一组为变量、函数等结构分配、实施类型的规则，通过显式地指定或类型推导来分配类型。同时类型系统也定义了如何判断类型之间的兼容性：在 TypeScript 中即是结构化类型系统。</li><li>类型检查：确保<strong>类型遵循类型系统下的类型兼容性</strong>，对于静态类型语言，在<strong>编译时</strong>进行，而对于动态语言，则在<strong>运行时</strong>进行。TypeScript 就是在编译时进行类型检查的。</li></ul><p>一个需要注意的地方是，静态类型与动态类型指的是<strong>类型检查发生的时机</strong>，并不等于这门语言的类型能力。比如 JavaScript 实际上是动态类型语言，它的类型检查发生在运行时。</p><p>另外一个静态类型与动态类型的重要区别体现在变量赋值时，如在 TypeScript 中无法给一个声明为 number 的变量使用字符串赋值，因为这个变量在声明时的类型就已经确定了。而在 JavaScript 中则没有这样的限制，你可以随时切换一个变量的类型。</p><p>另外，在编程语言中还有强类型、弱类型的概念，它们体现在对变量类型检查的程度，如在 JavaScript 中可以实现 <code>&#39;1&#39; - 1</code> 这样神奇的运算（通过隐式转换），这其实就是弱类型语言的显著特点之一。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11.类型系统层级：从 Top Type 到 Bottom Type</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/11.%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%B1%82%E7%BA%A7%EF%BC%9A%E4%BB%8E%20Top%20Type%20%E5%88%B0%20Bottom%20Type/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/11.%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%B1%82%E7%BA%A7%EF%BC%9A%E4%BB%8E%20Top%20Type%20%E5%88%B0%20Bottom%20Type/</url>
      
        <content type="html"><![CDATA[<p>如果说类型系统是 TypeScript 中的重要基础知识，那么类型层级就是类型系统中的重要概念之一。对于没有类型语言经验学习的同学，说类型层级是最重要的基础概念也不为过。</p><p>类型层级一方面能帮助我们明确各种类型的层级与兼容性，而兼容性问题往往就是许多类型错误产生的原因。另一方面，类型层级也是我们后续学习条件类型必不可少的前置知识。我也建议你能同时学习这两篇内容，遇到不理解、不熟悉的地方可以多看几遍。</p><p>类型层级实际上指的是，<strong>TypeScript 中所有类型的兼容关系，从最上面一层的 any 类型，到最底层的 never 类型。那么，从上至下的类型兼容关系到底长什么样呢？</strong> 这一节，我们就从原始类型变量和字面量类型开始比较，分别向上、向下延伸，依次把这些类型串起来形成层级链，让你能够构建出 TypeScript 的整个类型体系。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F08-type-levels">Type Levels</a></p></blockquote><h2 id="判断类型兼容性的方式"><a href="#判断类型兼容性的方式" class="headerlink" title="判断类型兼容性的方式"></a>判断类型兼容性的方式</h2><p>在开始前，我们需要先了解一下如何直观地判断两个类型的兼容性。本节中我们主要使用条件类型来判断类型兼容性，类似这样：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Result</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果返回 1，则说明 <code>&#39;linbudu&#39;</code> 为 string 的子类型。否则，说明不成立。但注意，不成立并不意味着 string 就是 <code>&#39;linbudu&#39;</code> 的子类型了。还有一种备选的，通过赋值来进行兼容性检查的方式，其大致使用方式是这样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">let</span> source<span class="token operator">:</span> <span class="token builtin">string</span><span class="token keyword">declare</span> <span class="token keyword">let</span> anyType<span class="token operator">:</span> <span class="token builtin">any</span><span class="token keyword">declare</span> <span class="token keyword">let</span> neverType<span class="token operator">:</span> <span class="token builtin">never</span>anyType <span class="token operator">=</span> source<span class="token comment">// 不能将类型“string”分配给类型“never”。</span>neverType <span class="token operator">=</span> source<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于变量 a = 变量 b，如果成立，意味着 <code>&lt;变量 b 的类型&gt; extends &lt;变量 a 的类型&gt;</code> 成立，即 <strong>b 类型是 a 类型的子类型</strong>，在这里即是 <code>string extends never</code> ，这明显是不成立的。</p><p>觉得不好理解？那可以试着这么想，我们有一个“狗”类型的变量，还有两个分别是“柯基”类型与“橘猫”类型的变量。</p><ul><li>狗 = 柯基，意味着将柯基作为狗，这是没问题的。</li><li>狗 = 橘猫，很明显不对，程序对“狗”这个变量的使用，都建立在它是一个“狗”类型的基础上，你给个猫，让后面咋办？</li></ul><p>这两种判断方式并没有明显的区别，只在使用场景上略有差异。在需要判断多个类型的层级时，条件类型更为直观，而如果只是两个类型之间的兼容性判断时，使用类型声明则更好理解一些，你可以依据自己的习惯来进行选择。</p><h2 id="从原始类型开始"><a href="#从原始类型开始" class="headerlink" title="从原始类型开始"></a>从原始类型开始</h2><p>了解了类型兼容性判断的方式后，我们就可以开始探讨类型层级了。首先，我们从原始类型、对象类型（后文统称为基础类型）和它们对应的字面量类型开始。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Result1</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result2</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result3</span> <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">boolean</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result4</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#125;</span> <span class="token keyword">extends</span> <span class="token class-name">object</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result5</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'linbudu'</span> <span class="token punctuation">&#125;</span> <span class="token keyword">extends</span> <span class="token class-name">object</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result6</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">object</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显，一个基础类型和它们对应的字面量类型必定存在父子类型关系。严格来说，object 出现在这里并不恰当，因为它实际上代表着<strong>所有非原始类型的类型，即数组、对象与函数类型</strong>，所以这里 Result6 成立的原因即是<code>[]</code>这个字面量类型也可以被认为是 object 的字面量类型。我们将结论简记为，<strong>字面量类型 &lt; 对应的原始类型</strong>。</p><p>接下来，我们就从这个原始类型与字面量出发，向上、向下去探索类型层级。</p><h2 id="向上探索，直到穹顶之上"><a href="#向上探索，直到穹顶之上" class="headerlink" title="向上探索，直到穹顶之上"></a>向上探索，直到穹顶之上</h2><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>我们之前讲过，在联合类型中，只需要符合其中一个类型，我们就可以认为实现了这个联合类型，用条件类型表达是这样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Result7</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">extends</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result8</span> <span class="token operator">=</span> <span class="token string">'lin'</span> <span class="token keyword">extends</span> <span class="token string">'lin'</span> <span class="token operator">|</span> <span class="token string">'bu'</span> <span class="token operator">|</span> <span class="token string">'du'</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result9</span> <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token boolean">true</span></span> <span class="token operator">|</span> <span class="token boolean">false</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在这一层面上，并不需要联合类型的<strong>所有成员均为字面量类型</strong>，或者<strong>字面量类型来自于同一基础类型</strong>这样的前提，只需要这个类型存在于联合类型中。</p><p>对于原始类型，联合类型的比较其实也是一致的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Result10</span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">|</span> <span class="token boolean">false</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结论：<strong>字面量类型 &lt; 包含此字面量类型的联合类型，原始类型 &lt; 包含此原始类型的联合类型。</strong></p><p>而如果一个联合类型由同一个基础类型的类型字面量组成，那这个时候情况又有点不一样了。既然你的所有类型成员都是字符串字面量类型，那你岂不就是我 string 类型的小弟？如果你的所有类型成员都是对象、数组字面量类型或函数类型，那你岂不就是我 object 类型的小弟？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Result11</span> <span class="token operator">=</span> <span class="token string">'lin'</span> <span class="token operator">|</span> <span class="token string">'bu'</span> <span class="token operator">|</span> <span class="token string">'budu'</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result12</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">object</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结论：<strong>同一基础类型的字面量联合类型 &lt; 此基础类型。</strong></p><p>合并一下结论，去掉比较特殊的情况，我们得到了这个最终结论：<strong>字面量类型 &lt; 包含此字面量类型的联合类型（同一基础类型） &lt; 对应的原始类型</strong>，即：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 2</span><span class="token keyword">type</span> <span class="token class-name">Result13</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span> <span class="token keyword">extends</span> <span class="token string">'linbudu'</span> <span class="token operator">|</span> <span class="token string">'599'</span>  <span class="token operator">?</span> <span class="token string">'linbudu'</span> <span class="token operator">|</span> <span class="token string">'599'</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span>    <span class="token operator">?</span> <span class="token number">2</span>    <span class="token operator">:</span> <span class="token number">1</span>  <span class="token operator">:</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于这种嵌套的联合类型，我们这里直接观察最后一个条件语句的结果即可，因为如果所有条件语句都成立，那结果就是最后一个条件语句为真时的值。另外，由于联合类型实际上是一个比较特殊的存在，大部分类型都存在至少一个联合类型作为其父类型，因此在后面我们不会再体现联合类型。</p><p>现在，我们关注的类型变成了基础类型，即 string 与 object 这一类。</p><h3 id="装箱类型"><a href="#装箱类型" class="headerlink" title="装箱类型"></a>装箱类型</h3><p>在「原始类型与对象类型」一节中，我们已经讲到了 JavaScript 中装箱对象 String 在 TypeScript 中的体现： String 类型，以及在原型链顶端傲视群雄的 Object 对象与 Object 类型。</p><p>很明显，string 类型会是 String 类型的子类型，String 类型会是 Object 类型的子类型，那中间还有吗？还真有，而且你不一定能猜到。我们直接看从 string 到 Object 的类型层级：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Result14</span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token keyword">extends</span> <span class="token class-name">String</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result15</span> <span class="token operator">=</span> String <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result16</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">extends</span> <span class="token class-name">object</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result18</span> <span class="token operator">=</span> object <span class="token keyword">extends</span> <span class="token class-name">Object</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里看着像是混进来一个很奇怪的东西，<code>&#123;&#125;</code> 不是 object 的字面量类型吗？为什么能在这里比较，并且 String 还是它的子类型？</p><p>这时请回忆我们在结构化类型系统中一节学习到的概念，假设我们把 String 看作一个普通的对象，上面存在一些方法，如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">String</span> <span class="token punctuation">&#123;</span>  replace<span class="token operator">:</span> <span class="token comment">// ...</span>  replaceAll<span class="token operator">:</span> <span class="token comment">// ...</span>  startsWith<span class="token operator">:</span> <span class="token comment">// ...</span>  endsWith<span class="token operator">:</span> <span class="token comment">// ...</span>  includes<span class="token operator">:</span> <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候，是不是能看做 String 继承了 <code>&#123;&#125;</code> 这个空对象，然后自己实现了这些方法？当然可以！<strong>在结构化类型系统的比较下，String 会被认为是 <code>&#123;&#125;</code> 的子类型</strong>。这里从 <code>string &lt; &#123;&#125; &lt; object</code> 看起来构建了一个类型链，但实际上 <code>string extends object</code> 并不成立：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Tmp</span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token keyword">extends</span> <span class="token class-name">object</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于结构化类型系统这一特性的存在，我们能得到一些看起来矛盾的结论：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Result16</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">extends</span> <span class="token class-name">object</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token keyword">type</span> <span class="token class-name">Result18</span> <span class="token operator">=</span> object <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token keyword">type</span> <span class="token class-name">Result17</span> <span class="token operator">=</span> object <span class="token keyword">extends</span> <span class="token class-name">Object</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token keyword">type</span> <span class="token class-name">Result20</span> <span class="token operator">=</span> Object <span class="token keyword">extends</span> <span class="token class-name">object</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token keyword">type</span> <span class="token class-name">Result19</span> <span class="token operator">=</span> Object <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token keyword">type</span> <span class="token class-name">Result21</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>16-18 和 19-21 这两对，为什么无论如何判断都成立？难道说明 <code>&#123;&#125;</code> 和 object 类型相等，也和 <code>Object</code> 类型一致？</p><p>当然不，这里的 <code>&#123;&#125; extends</code>和 <code>extends &#123;&#125;</code> 实际上是两种完全不同的比较方式。<code>&#123;&#125; extends object</code> 和 <code>&#123;&#125; extends Object</code> 意味着， <code>&#123;&#125;</code> 是 object 和 Object 的字面量类型，是从<strong>类型信息的层面</strong>出发的，即<strong>字面量类型在基础类型之上提供了更详细的类型信息</strong>。<code>object extends &#123;&#125;</code> 和 <code>Object extends &#123;&#125;</code> 则是从<strong>结构化类型系统的比较</strong>出发的，即 <code>&#123;&#125;</code> 作为一个一无所有的空对象，几乎可以被视作是所有类型的基类，万物的起源。如果混淆了这两种类型比较的方式，就可能会得到 <code>string extends object</code> 这样的错误结论。</p><p>而 <code>object extends Object</code> 和 <code>Object extends object</code> 这两者的情况就要特殊一些，它们是因为“系统设定”的问题，Object 包含了所有除 Top Type 以外的类型（基础类型、函数类型等），object 包含了所有非原始类型的类型，即数组、对象与函数类型，这就导致了你中有我、我中有你的神奇现象。</p><p>在这里，我们暂时只关注从类型信息层面出发的部分，即结论为：<strong>原始类型 &lt; 原始类型对应的装箱类型 &lt; Object 类型。</strong></p><p>现在，我们关注的类型为 Object 。</p><h3 id="Top-Type"><a href="#Top-Type" class="headerlink" title="Top Type"></a>Top Type</h3><p>再往上，我们就到达了类型层级的顶端（是不是很快），这里只有 any 和 unknown 这两兄弟。我们在<a href="https://juejin.cn/book/7086408430491172901/section/7100487738020855811">探秘内置类型：any、unknown 与 never</a> 一节中已经了解，any 与 unknown 是系统中设定为 Top Type 的两个类型，它们无视一切因果律，是类型世界的规则产物。因此， Object 类型自然会是 any 与 unknown 类型的子类型。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Result22</span> <span class="token operator">=</span> Object <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result23</span> <span class="token operator">=</span> Object <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">unknown</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但如果我们把条件类型的两端对调一下呢？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Result24</span> <span class="token operator">=</span> <span class="token builtin">any</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1 | 2</span><span class="token keyword">type</span> <span class="token class-name">Result25</span> <span class="token operator">=</span> <span class="token builtin">unknown</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>你会发现，any 竟然调过来，值竟然变成了 <code>1 | 2</code>？我们再多试几个看看：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Result26</span> <span class="token operator">=</span> <span class="token builtin">any</span> <span class="token keyword">extends</span> <span class="token string">'linbudu'</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1 | 2</span><span class="token keyword">type</span> <span class="token class-name">Result27</span> <span class="token operator">=</span> <span class="token builtin">any</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1 | 2</span><span class="token keyword">type</span> <span class="token class-name">Result28</span> <span class="token operator">=</span> <span class="token builtin">any</span> <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1 | 2</span><span class="token keyword">type</span> <span class="token class-name">Result29</span> <span class="token operator">=</span> <span class="token builtin">any</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">never</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1 | 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>是不是感觉匪夷所思？实际上，还是因为“系统设定”的原因。any 代表了任何可能的类型，当我们使用 <code>any extends</code> 时，它包含了“<strong>让条件成立的一部分</strong>”，以及“<strong>让条件不成立的一部分</strong>”。而从实现上说，在 TypeScript 内部代码的条件类型处理中，如果接受判断的是 any，那么会直接<strong>返回条件类型结果组成的联合类型</strong>。</p><p>因此 <code>any extends string</code> 并不能简单地认为等价于以下条件类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Result30</span> <span class="token operator">=</span> <span class="token string">"I'm string!"</span> <span class="token operator">|</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种情况下，由于联合类型的成员并非均是字符串字面量类型，条件显然不成立。</p><p>在前面学习 any 类型时，你可能也感受到了奇怪之处，在赋值给其他类型时，any 来者不拒，而 unknown 则只允许赋值给 unknown 类型和 any 类型，这也是由于“系统设定”的原因，即 <strong>any 可以表达为任何类型</strong>。你需要我赋值给这个变量？那我现在就是这个变量的子类型了，我是不是很乖巧？</p><p>另外，any 类型和 unknown 类型的比较也是互相成立的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Result31</span> <span class="token operator">=</span> <span class="token builtin">any</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">unknown</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result32</span> <span class="token operator">=</span> <span class="token builtin">unknown</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>虽然还是存在系统设定的部分，但我们仍然只关注类型信息层面的层级，即结论为：<strong>Object &lt; any / unknown</strong>。而到这里，我们已经触及了类型世界的最高一层，接下来我们再回到字面量类型，只不过这一次我们要向下探索了。</p><h2 id="向下探索，直到万物虚无"><a href="#向下探索，直到万物虚无" class="headerlink" title="向下探索，直到万物虚无"></a>向下探索，直到万物虚无</h2><p>向下地探索其实就简单多了，首先我们能确认一定有个 never 类型，因为它代表了“虚无”的类型，一个根本不存在的类型。对于这样的类型，它会是任何类型的子类型，当然也包括字面量类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Result33</span> <span class="token operator">=</span> <span class="token builtin">never</span> <span class="token keyword">extends</span> <span class="token string">'linbudu'</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但你可能又想到了一些特别的部分，比如 null、undefined、void。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Result34</span> <span class="token operator">=</span> <span class="token keyword">undefined</span> <span class="token keyword">extends</span> <span class="token string">'linbudu'</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 2</span><span class="token keyword">type</span> <span class="token class-name">Result35</span> <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token keyword">extends</span> <span class="token string">'linbudu'</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 2</span><span class="token keyword">type</span> <span class="token class-name">Result36</span> <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token keyword">extends</span> <span class="token string">'linbudu'</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面三种情况当然不应该成立。别忘了在 TypeScript 中，void、undefined、null 都是<strong>切实存在、有实际意义的类型</strong>，它们和 string、number、object 并没有什么本质区别。</p><blockquote><p>我们在此前了解过，关闭 <code>--strictNullCheckes</code> 的情况下，null 会被视为 string 等类型的子类型。但正常情况下我们不会这么做，因此这里不做讨论，而是将其视为与 string 等类型同级的一个类型。</p></blockquote><p>因此，这里我们得到的结论是，<strong>never &lt; 字面量类型</strong>。这就是类型世界的最底层，有点像我的世界那样，当你挖穿地面后，出现的是一片茫茫的空白与虚无。</p><p>那现在，我们可以开始组合整个类型层级了。</p><h2 id="类型层级链"><a href="#类型层级链" class="headerlink" title="类型层级链"></a>类型层级链</h2><p>结合我们上面得到的结论，可以书写出这样一条类型层级链：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">TypeChain</span> <span class="token operator">=</span> <span class="token builtin">never</span> <span class="token keyword">extends</span> <span class="token string">'linbudu'</span>  <span class="token operator">?</span> <span class="token string">'linbudu'</span> <span class="token keyword">extends</span> <span class="token string">'linbudu'</span> <span class="token operator">|</span> <span class="token string">'599'</span>    <span class="token operator">?</span> <span class="token string">'linbudu'</span> <span class="token operator">|</span> <span class="token string">'599'</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span>      <span class="token operator">?</span> <span class="token builtin">string</span> <span class="token keyword">extends</span> <span class="token class-name">String</span>        <span class="token operator">?</span> String <span class="token keyword">extends</span> <span class="token class-name">Object</span>          <span class="token operator">?</span> Object <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span>            <span class="token operator">?</span> <span class="token builtin">any</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">unknown</span></span>              <span class="token operator">?</span> <span class="token builtin">unknown</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span>                <span class="token operator">?</span> <span class="token number">8</span>                <span class="token operator">:</span> <span class="token number">7</span>              <span class="token operator">:</span> <span class="token number">6</span>            <span class="token operator">:</span> <span class="token number">5</span>          <span class="token operator">:</span> <span class="token number">4</span>        <span class="token operator">:</span> <span class="token number">3</span>      <span class="token operator">:</span> <span class="token number">2</span>    <span class="token operator">:</span> <span class="token number">1</span>  <span class="token operator">:</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其返回的结果为 8 ，也就意味着所有条件均成立。当然，结合上面的结构化类型系统与类型系统设定，我们还可以构造出一条更长的类型层级链：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">VerboseTypeChain</span> <span class="token operator">=</span> <span class="token builtin">never</span> <span class="token keyword">extends</span> <span class="token string">'linbudu'</span>  <span class="token operator">?</span> <span class="token string">'linbudu'</span> <span class="token keyword">extends</span> <span class="token string">'linbudu'</span> <span class="token operator">|</span> <span class="token string">'budulin'</span>    <span class="token operator">?</span> <span class="token string">'linbudu'</span> <span class="token operator">|</span> <span class="token string">'budulin'</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span>      <span class="token operator">?</span> <span class="token builtin">string</span> <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token operator">?</span> <span class="token builtin">string</span> <span class="token keyword">extends</span> <span class="token class-name">String</span>          <span class="token operator">?</span> String <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>            <span class="token operator">?</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">extends</span> <span class="token class-name">object</span>              <span class="token operator">?</span> object <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>                <span class="token operator">?</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span>                  <span class="token operator">?</span> Object <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>                    <span class="token operator">?</span> object <span class="token keyword">extends</span> <span class="token class-name">Object</span>                      <span class="token operator">?</span> Object <span class="token keyword">extends</span> <span class="token class-name">object</span>                        <span class="token operator">?</span> Object <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span>                          <span class="token operator">?</span> Object <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">unknown</span></span>                            <span class="token operator">?</span> <span class="token builtin">any</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">unknown</span></span>                              <span class="token operator">?</span> <span class="token builtin">unknown</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span>                                <span class="token operator">?</span> <span class="token number">8</span>                                <span class="token operator">:</span> <span class="token number">7</span>                              <span class="token operator">:</span> <span class="token number">6</span>                            <span class="token operator">:</span> <span class="token number">5</span>                          <span class="token operator">:</span> <span class="token number">4</span>                        <span class="token operator">:</span> <span class="token number">3</span>                      <span class="token operator">:</span> <span class="token number">2</span>                    <span class="token operator">:</span> <span class="token number">1</span>                  <span class="token operator">:</span> <span class="token number">0</span>                <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span>              <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">2</span>            <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">3</span>          <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">4</span>        <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">5</span>      <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">6</span>    <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">7</span>  <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果仍然为 8 。</p><h2 id="其他比较场景"><a href="#其他比较场景" class="headerlink" title="其他比较场景"></a>其他比较场景</h2><p>除了我们上面提到的类型比较，其实还存在着一些比较情况，我们稍作补充。</p><ul><li><p>对于基类和派生类，通常情况下<strong>派生类会完全保留基类的结构</strong>，而只是自己新增新的属性与方法。在结构化类型的比较下，其类型自然会存在子类型关系。更不用说派生类本身就是 extends 基类得到的。</p></li><li><p>联合类型的判断，前面我们只是判断联合类型的单个成员，那如果是多个成员呢？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Result36</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token keyword">extends</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result37</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token keyword">extends</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result38</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">5</span> <span class="token keyword">extends</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 2</span><span class="token keyword">type</span> <span class="token class-name">Result39</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">5</span> <span class="token keyword">extends</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，对于联合类型地类型层级比较，我们只需要比较<strong>一个联合类型是否可被视为另一个联合类型的子集</strong>，即<strong>这个联合类型中所有成员在另一个联合类型中都能找到</strong>。</p></li><li><p>数组和元组</p><p>数组和元组是一个比较特殊的部分，我们直接来看例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Result40</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result41</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 2</span><span class="token keyword">type</span> <span class="token class-name">Result42</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result43</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result44</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">unknown</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result45</span> <span class="token operator">=</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result46</span> <span class="token operator">=</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Result47</span> <span class="token operator">=</span> <span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 2</span><span class="token keyword">type</span> <span class="token class-name">Result48</span> <span class="token operator">=</span> <span class="token builtin">never</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们一个个来讲解：</p><ul><li>40，这个元组类型实际上能确定其内部成员全部为 number 类型，因此是 <code>number[]</code> 的子类型。而 41 中混入了别的类型元素，因此认为不成立。</li><li>42 混入了别的类型，但其判断条件为 <code>(number | string)[]</code> ，即其成员需要为 number 或 string 类型。</li><li>43 的成员是未确定的，等价于 <code>never[] extends number[]</code>，44 同理。</li><li>45 类似于 41，即可能存在的元素类型是符合要求的。</li><li>46、47，还记得身化万千的 any 类型和小心谨慎的 unknown 类型嘛？</li><li>48，类似于 43、44，由于 never 类型本就位于最下方，这里显然成立。只不过 <code>never[]</code> 类型的数组也就无法再填充值了。</li></ul></li></ul><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节，我们从一个原始类型开始构造类型层级链，向上触及了 Top Type，向下也见到了 Bottom Type。而在构造过程中，除了父子类型，我们还了解了<strong>联合类型的子类型判定</strong>、<strong>基于结构化类型系统的子类型判定</strong>、<strong>基于类型系统基本规则</strong>的子类型判定，基本包括了会见到的各种特殊情况。</p><p>基础的类型层级可以用以下这张图表示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8459e958e581479faa284390e3c6a09c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>而学习了类型层级以后，下一节的条件类型学习起来就简单多了。但条件类型中可不仅仅是类型层级，我们还要见识 infer 关键字、分布式条件类型等新朋友，可别完全掉以轻心，它们同样是类型编程中具有一定难度的概念。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14.反方向类型推导：用好上下文相关类型</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/14.%E5%8F%8D%E6%96%B9%E5%90%91%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%9A%E7%94%A8%E5%A5%BD%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/14.%E5%8F%8D%E6%96%B9%E5%90%91%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%9A%E7%94%A8%E5%A5%BD%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>TypeScript 拥有非常强大的类型推导能力，不仅会在你声明一个变量时自动推导其类型，也会基于函数内部逻辑自动推导其返回值类型，还会在你使用 typeof 、instanceof 等工具时自动地收窄类型（可辨识联合类型）等等。这些类型推导其实有一个共同点：<strong>它们的推导依赖开发者的输入</strong>，比如变量声明、函数逻辑、类型保护都需要开发者的输入。实际上， TypeScript 中还存在着另一种类型推导，它默默无闻却又无处不在，它就是这一节的主角：<strong>上下文类型（Contextual Typing）</strong>。</p><p>这一节的内容比较短，因为上下文类型并不是一个多复杂、多庞大的概念（不涉及实现源码的情况下），但在实际开发中，我们经常会受益于上下文类型的推导能力，只不过你可能不知道背后是它得作用。学完这一节，以后感受到上下文类型存在时，你就可以在心里默默地说一句：“谢谢你，上下文类型”。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F11-contextual-typing">Contextual Typings</a></p></blockquote><h2 id="无处不在的上下文类型"><a href="#无处不在的上下文类型" class="headerlink" title="无处不在的上下文类型"></a>无处不在的上下文类型</h2><p>首先举一个最常见的例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">window<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token punctuation">,</span> source<span class="token punctuation">,</span> line<span class="token punctuation">,</span> col<span class="token punctuation">,</span> err<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这个例子里，虽然我们并没有为 onerror 的各个参数声明类型，但是它们也已经获得了正确的类型。</p><p>当然你肯定能猜到，这是因为 onerror 的类型声明已经内置了：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Handler</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 简化</span>  onerror<span class="token operator">:</span> OnErrorEventHandlerNonNull<span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">OnErrorEventHandlerNonNull</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">(</span>    event<span class="token operator">:</span> Event <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">,</span>    source<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>    lineno<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>    colno<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>    error<span class="token operator">?</span><span class="token operator">:</span> Error  <span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们自己实现一个函数签名，其实也是一样的效果：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">CustomHandler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">boolean</span><span class="token comment">// 也推导出了参数类型</span><span class="token keyword">const</span> handler<span class="token operator">:</span> <span class="token function-variable function">CustomHandler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>除了参数类型，返回值类型同样会纳入管控：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">const</span> struct<span class="token operator">:</span> <span class="token punctuation">&#123;</span>  handler<span class="token operator">:</span> CustomHandler<span class="token punctuation">&#125;</span><span class="token comment">// 不能将类型“void”分配给类型“boolean”。</span>struct<span class="token punctuation">.</span><span class="token function-variable function">handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，不仅是箭头函数，函数表达式也是一样的效果，这里就不做展开了。</p><p>在这里，参数的类型基于其上下文类型中的参数类型位置来进行匹配，arg1 对应到 name ，所以是 string 类型，arg2 对应到 age，所以是 number 类型。这就是上下文类型的核心理念：<strong>基于位置的类型推导</strong>。同时，相对于我们上面提到的基于开发者输入进行的类型推导，上下文类型更像是<strong>反方向的类型推导</strong>，也就是<strong>基于已定义的类型来规范开发者的使用</strong>。</p><p>在上下文类型中，我们实现的表达式可以只使用更少的参数，而不能使用更多，这还是因为上下文类型基于位置的匹配，一旦参数个数超过定义的数量，那就没法进行匹配了。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 正常</span>window<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 报错</span>window<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token punctuation">,</span> source<span class="token punctuation">,</span> line<span class="token punctuation">,</span> col<span class="token punctuation">,</span> err<span class="token punctuation">,</span> extra<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上下文类型也可以进行”嵌套“情况下的类型推导，如以下这个例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">let</span> <span class="token function-variable function">func</span><span class="token operator">:</span> <span class="token punctuation">(</span>raw<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">any</span><span class="token comment">// raw → number</span><span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token punctuation">(</span>raw<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// input → string</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在某些情况下，上下文类型的推导能力也会失效，比如这里我们使用一个由函数类型组成的联合类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  foo<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token keyword">extends</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  bar<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> f1<span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> Foo<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#125;</span> <span class="token operator">|</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> Bar<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#125;</span><span class="token comment">// 参数“input”隐式具有“any”类型。</span><span class="token function-variable function">f1</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// y :any</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们预期的结果是 input 被推导为 <code>Foo | Bar</code> 类型，也就是所有符合结构的函数类型的参数，但却失败了。这是因为 TypeScript 中的上下文类型目前暂时不支持这一判断方式（而不是这不属于上下文类型的能力范畴）。</p><p>你可以直接使用一个联合类型参数的函数签名：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">let</span> f2<span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> Foo <span class="token operator">|</span> Bar<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#125;</span><span class="token comment">// Foo | Bar</span><span class="token function-variable function">f2</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// y :any</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>而如果联合类型中将这两个类型再嵌套一层，此时上下文类型反而正常了：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">let</span> f3<span class="token operator">:</span>  <span class="token operator">|</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">(</span>raw<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> Foo<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">&#125;</span>  <span class="token operator">|</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">(</span>raw<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> Bar<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">&#125;</span><span class="token comment">// raw → number</span><span class="token function-variable function">f3</span> <span class="token operator">=</span> <span class="token punctuation">(</span>raw<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// input → Bar</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里被推导为 Bar 的原因，其实还和我们此前了解的协变、逆变有关。任何接收 Foo 类型参数的地方，都可以接收一个 Bar 类型参数，因此推导到 Bar 类型要更加安全。</p><h2 id="void-返回值类型下的特殊情况"><a href="#void-返回值类型下的特殊情况" class="headerlink" title="void 返回值类型下的特殊情况"></a>void 返回值类型下的特殊情况</h2><p>我们前面说到，上下文类型同样会推导并约束函数的返回值类型，但存在这么个特殊的情况，当内置函数类型的返回值类型为 void 时：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">CustomHandler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token keyword">const</span> handler1<span class="token operator">:</span> <span class="token function-variable function">CustomHandler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token boolean">true</span><span class="token keyword">const</span> handler2<span class="token operator">:</span> <span class="token function-variable function">CustomHandler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token string">'linbudu'</span><span class="token keyword">const</span> handler3<span class="token operator">:</span> <span class="token function-variable function">CustomHandler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">null</span><span class="token keyword">const</span> handler4<span class="token operator">:</span> <span class="token function-variable function">CustomHandler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你会发现这个时候，我们的函数实现返回值类型变成了五花八门的样子，而且还都不会报错？同样的，这也是一条世界底层的规则，<strong>上下文类型对于 void 返回值类型的函数，并不会真的要求它啥都不能返回</strong>。然而，虽然这些函数实现可以返回任意类型的值，但<strong>对于调用结果的类型，仍然是 void</strong>：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> result1 <span class="token operator">=</span> <span class="token function">handler1</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token number">599</span><span class="token punctuation">)</span> <span class="token comment">// void</span><span class="token keyword">const</span> result2 <span class="token operator">=</span> <span class="token function">handler2</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token number">599</span><span class="token punctuation">)</span> <span class="token comment">// void</span><span class="token keyword">const</span> result3 <span class="token operator">=</span> <span class="token function">handler3</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token number">599</span><span class="token punctuation">)</span> <span class="token comment">// void</span><span class="token keyword">const</span> result4 <span class="token operator">=</span> <span class="token function">handler4</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token number">599</span><span class="token punctuation">)</span> <span class="token comment">// void</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>看起来这是一种很奇怪的、错误的行为，但实际上，我们日常开发中的很多代码都需要这一“不正确的”行为才不会报错，比如以下这个例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> arr<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">const</span> list<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">=></span> arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这是我们常用的简写方式，然而，push 方法的返回值是一个 number 类型（push 后数组的长度），而 forEach 的上下文类型声明中要求返回值是 void 类型。如果此时 void 类型真的不允许任何返回值，那这里我们就需要多套一个代码块才能确保类型符合了。</p><p>但这真的是有必要的吗？对于一个 void 类型的函数，我们真的会去消费它的返回值吗？既然不会，那么它想返回什么，全凭它乐意就好了。我们还可以用另一种方式来描述这个概念：你可以<strong>将返回值非 void 类型的函数（<code>() =&gt; list.push()</code>）作为返回值类型为 void 类型（<code>arr.forEach</code>）的函数类型参数</strong>。</p><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节里，我们学习了上下文类型这“另一个方向”的类型推导，了解了它是基于位置进行类型匹配的，以及上下文类型中 void 类型返回值的特殊情况。</p><p>这一节比较轻松对吧？那在下一节，我们会学习一个稍微复杂点的概念：函数类型兼容性比较，以及其中的<strong>协变</strong>与<strong>逆变</strong>概念。我们在前面类型层级一节中，并没有提及函数类型地比较，这也是因为其中的概念相对复杂，需要更多的前置知识与更多的消化过程，因此我单独准备了一节内容。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="将更少参数的函数赋值给具有更多参数的函数类型"><a href="#将更少参数的函数赋值给具有更多参数的函数类型" class="headerlink" title="将更少参数的函数赋值给具有更多参数的函数类型"></a>将更少参数的函数赋值给具有更多参数的函数类型</h3><p>在上面的例子中，我们看到了这么一段代码：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> arr<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">const</span> list<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">=></span> arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 forEach 的函数中，我们会消费 list 的每一个成员。但我们有时也会遇到并不实际消费数组成员的情况：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>otherFactory<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个时候，我们实际上就是在<strong>将更少参数的函数赋值给具有更多参数的函数类型</strong>！</p><p>再看一个更明显的例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">useHandler</span><span class="token punctuation">(</span><span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span>arg1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> arg2<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">callback</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token number">599</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">useHandler</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>handler 函数的类型签名很明显与 useHandler 函数的 callback 类型签名并不一致，但这里却没有报错。从实用意义的角度来看，如果我们需要类型签名完全一致，那么就需要为 handler 再声明一个额外的对应到 arg2 的参数，然而我们的 handler 代码里实际上并没有去消费第二个参数。这实际上在 JavaScript 中也是我们经常使用的方式：<strong>即使用更少入参的函数来作为一个预期更多入参函数参数的实现</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>16.了解类型编程与类型体操的意义，找到平衡点</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/16.%E4%BA%86%E8%A7%A3%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%8C%E6%89%BE%E5%88%B0%E5%B9%B3%E8%A1%A1%E7%82%B9/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/16.%E4%BA%86%E8%A7%A3%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%8C%E6%89%BE%E5%88%B0%E5%B9%B3%E8%A1%A1%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>在学习 TypeScript 时，很多同学可能会遇到这些疑惑：</p><ul><li>这些额外的类型代码，以及类型编程，对实际项目开发的帮助在哪里？我真的需要精通它们吗？</li><li>这些工具类型看起来真的好烧脑，并且它们并不能让我的网页运行得更快，让我的 Node 服务并发更高，让我的网页 PV / UV 数据更喜人，我为什么需要了解它们？</li><li>TypeScript 的学习曲线是怎么样的？是否存在一个比较平衡的阶段，让我的投入产出比最大化？</li></ul><p>所以这一节，我们不学习代码，只是来聊一聊 TypeScript 类型编程的学习意义。因为此时你已经具备了深入学习类型编程的前置基础，又马上要进入工具类型进阶部分的学习。那在挑战这座最高的“山峰”之前，我们很有必要利用这几个问题带你走一些常见的误区，让你能心无旁骛地坚定向前。</p><h2 id="从类型编程到类型体操"><a href="#从类型编程到类型体操" class="headerlink" title="从类型编程到类型体操"></a>从类型编程到类型体操</h2><p>你可能会注意到，上面我用了“类型编程”和“类型体操”这两个不同的词。这是因为我通常把 TS 中的类型操作分为这两类。对于类型编程，它是<strong>对实际开发中真的有帮助的类型操作</strong>，下限非常之低，比如其实我们就是简单地用个泛型，这也属于类型编程。而它的上限也很高，比如底层框架中让人眼花缭乱的操作。但我们不需要用一个具体的界限来进行划分，只需要知道，只要是真的对实际开发有帮助的类型操作，无论实现多么复杂，都能被归类于类型编程当中。</p><p>那么类型体操又是什么样的？在此之前，你可能看到过基于 TypeScript 类型实现的四则远算、斐波那契数列、象棋、Lisp 编译器这一类令人叹为观止的操作，这些就属于类型体操。但请注意，这个词并不是贬义的，相反，大部分类型体操的作者都是编程功底十分深厚的大牛，他们发明这些体操的意图并不是为了炫技，只是为了展示给萌新们新世界的大门，我个人也非常佩服能写出如此高阶类型运算的大佬们。这些体操虽然对实际项目开发的意义非常有限，但却可以从另外一个角度让你认识到 TypeScript 类型系统的图灵完备，以及在高手手里所表现出来的精妙技巧。</p><p>但是，如果你因为看不懂这些体操，或者想不出更炫酷的体操而感到焦虑，那就需要警醒一下了——<strong>类型体操绝不代表你的 TS 水平</strong>。我看到过很多因为掌握了各种类型体操表演引以为豪的同学，其中有相当一部分人在实际业务开发中，仍然是各种 any 与复制粘贴。这就是非常严重的本末倒置，你学习 TypeScript ，是为了帅气的体操还是为了更高质量的代码呢？</p><p>如果你掌握了所有的类型体操，你就能写好所有的业务代码吗？答案显然是否定的。类型体操就像是五年高考三年模拟，只要你愿意花时间，对着答案总是能看明白的，但你看完就能保证做出数学压轴题的最后一小问吗？类型体操绝不应当被作为 TS 水平的度量衡，在绝大多数情况下，我们对于 TypeScript 相关的技巧，都应该秉持着从实用性出发的角度来看待。类似的，还有盯着 TypeScript 源码读，类型编程还没入门就去刷 Type Challenges 等等误区，当你发现学习进度慢得感人，掉发进度快得吓人，真的不会怀疑人生吗？</p><p>我个人更偏向于实用主义，就像这本小册一直到现在，以及接下来的内容都是接地气的，不存在你学了却无处可用的知识。这也是我认为在学习一门编程语言/工具/框架时最应该先考虑的事情，<strong>一门技术，要么应当能够在当下或者可预见的未来给予你帮助，要么能够扩宽你的技术视野和知识边界（类型体操并不完全算）</strong>，而类型体操对于新人来说除了徒增焦虑并没有任何意义。</p><p>现在我们可以来回答下开始的问题了。</p><p>TypeScript 带来了哪些帮助？太多啦，我只讲一个社区中还没见过有人提的点。我们书写的类型实际上也是逻辑，只不过是类型世界的逻辑，并且不存在于运行时。在我们书写实际的代码逻辑时，这些类型逻辑就像是飞机起飞前的预检（preflight）一样，在你的代码还没运行时就能够发现其中隐藏的错误。稳定性、代码质量、严谨性、可读性等等，其实本质都是这一能力。它们的确不能让你的页面性能更好或是业务数据更棒，但却能避免潜在的严重问题，比如白屏和塞满错误监控的 <code>Cannot read property of undefined</code>。</p><p>对于 TypeScript 来说最重要的，其实是与 JavaScript 的紧密结合，类型能力是添加在 JavaScript 之上的，也就意味着我们不需要学习一门全新的编程语言来获得类型检查。同时，我们可以说它的学习曲线是相对平缓的，因为并不需要学习太长时间就能写出还过得去的 TypeScript 代码。但它的边际成本是明显递增的，也就是说，假如你最开始只需要花 3 个单位的精力和时间，就能提升 10 个单位的类型覆盖程度（用来衡量 TypeScript 代码质量的指标之一），后面可能需要花 10 个单位的精力和时间才能再提升 1 个单位的类型覆盖。</p><p>但你真的需要如此高的类型覆盖程度，以及愿意花如此多的精力时间吗？我的建议是，在你优化 TypeScript 代码的过程中，如果感到边际成本明显提升，重构工作开始有些吃力，那你很可能已经达到了一个临界值，也是该停下来的时候了。</p><p>而对于 TypeScript 的学习曲线，自然也存在着这么一个平衡点，它标志着你的投入精力和获得回报达成了相对的平衡，再继续投入更多精力也无法看到明显的效果。你是否要问，这本小册中是否也存在着这么个平衡点？当然也是，只不过是几乎全本的内容（笑）。相信我，这本小册中基本都是你现在或未来会需要的技能点。只有 Compiler API 部分稍显复杂，但我们也会讲得有趣好玩一些。而对你自己来说，这个平衡点其实可以非常灵活，随着你的学习深入，TypeScript 技能不断提升，将会越来越渴望更多的知识，那平衡点不就越来越高了？</p><p>无论如何记住一件事，不要逼自己学习，当你在某一节学习过程中感觉到容易分神时，那就是时候休息了，站起来活动下身体，打开窗户呼吸下新鲜空气，我会一直在这里等你回来。</p><h2 id="Type-Challenges"><a href="#Type-Challenges" class="headerlink" title="Type Challenges"></a>Type Challenges</h2><p>最后，我们再来说下如何进一步进阶类型编程能力。<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftype-challenges%2Ftype-challenges">Type Challenge </a>是 antfu （Vue 团队成员，以及 Vite、Vitest、Nuxt 等知名开源项目的团队成员或作者）的作品，其中搜集了许多类型编程的题目，并且贴心地按照难易程度分为了 easy、medium、hard 三个等级。</p><p>虽然我并没有把每一道题都完成，但我仍然推荐想要学习更高阶类型编程的同学去花上一定时间看看。当然，前提是你已经对整个类型能力有比较清晰认知的情况下，只有此时 Type Challenge 才能为你带来正面作用。这本小册中并不会有过于复杂的工具类型讲解，如果你学完之后感觉意犹未尽，还想尝试更多复杂的类型编程，此时就可以打开它来上那么几题了。</p><p>请务必牢记，Type Challenge 是在已有一定类型编程基础后，用来进一步提高水平的方式，而不是你用来学习类型编程与类型系统的方式，务必分清其中的因果关系。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13.内置工具类型基础：别再妖魔化工具类型了！</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/13.%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%88%AB%E5%86%8D%E5%A6%96%E9%AD%94%E5%8C%96%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E4%BA%86%EF%BC%81/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/13.%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%88%AB%E5%86%8D%E5%A6%96%E9%AD%94%E5%8C%96%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>在很多时候，工具类型其实都被妖魔化了。它仿佛是武林中人人追捧的武功秘籍，修炼难度极其苛刻，掌握它就能立刻类型编程功力大涨，成为武林盟主傲世群雄。然而，这是非常错误的想法。</p><p>首先，工具类型学起来不难，它的概念也不复杂。很多同学觉得难，是因为还没完全熟悉所有类型工具，对类型系统还懵懵懂懂的情况下，就直接一头扎进各种复杂的类型编程源码中去。其实只要我们熟悉了类型工具的使用，了解类型系统的概念，再结合小册中对类型编程 4 大范式进行的分类解析，再复杂的类型编程也会被你所掌握的。</p><p>其次，<strong>工具类型和类型编程并不完全等价</strong>。虽然它是类型编程最常见的一种表现形式，但不能完全代表类型编程水平，如很多框架代码中，类型编程的复杂度也体现在<strong>函数的重载与泛型约束</strong>方面。但通过工具类型，我们能够更好地理解类型编程的本质。</p><p>此前我们已经了解了类型工具、类型系统的相关概念，那么这一节，我们就从内置工具类型解读开始，打开类型编程的新世界。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F10-builtin-tool-type">Builtin Tool Types</a></p></blockquote><h2 id="工具类型的分类"><a href="#工具类型的分类" class="headerlink" title="工具类型的分类"></a>工具类型的分类</h2><p>内置的工具类型按照类型操作的不同，其实也可以大致划分为这么几类：</p><ul><li>对属性的修饰，包括对象属性和数组元素的可选/必选、只读/可写。我们将这一类统称为<strong>属性修饰工具类型</strong>。</li><li>对既有类型的裁剪、拼接、转换等，比如使用对一个对象类型裁剪得到一个新的对象类型，将联合类型结构转换到交叉类型结构。我们将这一类统称为<strong>结构工具类型</strong>。</li><li>对集合（即联合类型）的处理，即交集、并集、差集、补集。我们将这一类统称为<strong>集合工具类型</strong>。</li><li>基于 infer 的模式匹配，即对一个既有类型特定位置类型的提取，比如提取函数类型签名中的返回值类型。我们将其统称为<strong>模式匹配工具类型</strong>。</li><li>模板字符串专属的工具类型，比如神奇地将一个对象类型中的所有属性名转换为大驼峰的形式。这一类当然就统称为<strong>模板字符串工具类型</strong>了。</li></ul><p>这一节我们要讲解的 TypeScript 内置工具类型，包括了访问性修饰、结构、集合以及模式匹配工具类型这四种，我们会讲解它们的具体实现，也就是使用了哪些类型操作以及操作背后的原理，再思考它们存在哪些不足，存在的扩展方向有哪些。在第 17 节内置工具类型进阶，我们会将这些扩展方向一一实现，进一步拓宽你的类型编程思路。</p><h2 id="属性修饰工具类型"><a href="#属性修饰工具类型" class="headerlink" title="属性修饰工具类型"></a>属性修饰工具类型</h2><p>这一部分的工具类型主要使用<strong>属性修饰</strong>、<strong>映射类型</strong>与<strong>索引类型</strong>相关（索引类型签名、索引类型访问、索引类型查询均有使用，因此这里直接用索引类型指代）。</p><p>在内置工具类型中，访问性修饰工具类型包括以下三位：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Partial<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">Required<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">Readonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，Partial 与 Required 可以认为是一对工具类型，它们的功能是相反的，而在实现上，它们的唯一差异是在索引类型签名处的可选修饰符，Partial 是 <code>?</code>，即标记属性为可选，而 Required 则是 <code>-?</code>，相当于在原本属性上如果有 <code>?</code> 这个标记，则移除它。</p><p>如果你觉得不好记，其实 Partial 也可以使用 <code>+?</code> 来显式的表示添加可选标记：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Partial<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要注意的是，可选标记不等于修改此属性类型为 <code>原类型 | undefined</code> ，如以下的接口结构：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  optional<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">undefined</span>  required<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果你声明一个对象去实现这个接口，它仍然会要求你提供 optional 属性：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  optional<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">undefined</span>  required<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token comment">// 类型 "&#123; required: string; &#125;" 中缺少属性 "optional"，但类型 "Foo" 中需要该属性。</span><span class="token keyword">const</span> foo1<span class="token operator">:</span> Foo <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  required<span class="token operator">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> foo2<span class="token operator">:</span> Foo <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  required<span class="token operator">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span>  optional<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为对于结构声明来说，一个属性是否必须提供仅取决于其是否携带可选标记。即使你使用 never 也无法标记这个属性为可选：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  optional<span class="token operator">:</span> <span class="token builtin">never</span>  required<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> foo<span class="token operator">:</span> Foo <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  required<span class="token operator">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span>  <span class="token comment">// 不能将类型“string”分配给类型“never”。</span>  optional<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反而你会惊喜地发现你没法为这个属性声明值了，毕竟除本身以外没有类型可以赋值给 never 类型。</p><p>而类似 <code>+?</code>，Readonly 中也可以使用 <code>+readonly</code>：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Readonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token operator">+</span><span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>虽然 TypeScript 中并没有提供它的另一半，但参考 Required 其实我们很容易想到这么实现一个工具类型 Mutable，来将属性中的 readonly 修饰移除：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Mutable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token operator">-</span><span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>现在我们了解了 Partial、Readonly 这一类属性修饰的工具类型，不妨想想它们是否能满足我们的需要？假设场景逐渐开始变得复杂，比如以下这些情况：</p><ul><li>现在的属性修饰是浅层的，如果我想将<strong>嵌套在里面的对象类型</strong>也进行修饰，需要怎么改进？</li><li>现在的属性修饰是全量的，如果我只想<strong>修饰部分属性</strong>呢？这里的部分属性，可能是<strong>基于传入已知的键名</strong>来确定（比如属性 a、b），也可能是<strong>基于属性类型</strong>来确定(比如所有函数类型的值)？</li></ul><h2 id="结构工具类型"><a href="#结构工具类型" class="headerlink" title="结构工具类型"></a>结构工具类型</h2><p>这一部分的工具类型主要使用<strong>条件类型</strong>以及<strong>映射类型</strong>、<strong>索引类型</strong>。</p><p>结构工具类型其实又可以分为两类，<strong>结构声明</strong>和<strong>结构处理</strong>。</p><p>结构声明工具类型即快速声明一个结构，比如内置类型中的 Record：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Record<span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，<code>K extends keyof any</code> 即为键的类型，这里使用 <code>extends keyof any</code> 标明，传入的 K 可以是单个类型，也可以是联合类型，而 T 即为属性的类型。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 键名均为字符串，键值类型未知</span><span class="token keyword">type</span> <span class="token class-name">Record1</span> <span class="token operator">=</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">unknown</span><span class="token operator">></span><span class="token comment">// 键名均为字符串，键值类型任意</span><span class="token keyword">type</span> <span class="token class-name">Record2</span> <span class="token operator">=</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">></span><span class="token comment">// 键名为字符串或数字，键值类型任意</span><span class="token keyword">type</span> <span class="token class-name">Record3</span> <span class="token operator">=</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，<code>Record&lt;string, unknown&gt;</code> 和 <code>Record&lt;string, any&gt;</code> 是日常使用较多的形式，通常我们使用这两者来代替 object 。</p><p>在一些工具类库源码中其实还存在类似的结构声明工具类型，如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Dictionary<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span>index<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">NumericDictionary<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span>index<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Dictionary （字典）结构只需要一个作为属性类型的泛型参数即可。</p><p>而对于结构处理工具类型，在 TypeScript 中主要是 Pick、Omit 两位选手：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">Omit<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token builtin">any</span><span class="token operator">></span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> Exclude<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">>></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先来看 Pick，它接受两个泛型参数，T 即是我们会进行结构处理的原类型（一般是对象类型），而 K 则被约束为 T 类型的键名联合类型。由于泛型约束是立即填充推导的，即你为第一个泛型参数传入 Foo 类型以后，K 的约束条件会立刻被填充，因此在你输入 K 时会获得代码提示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a4d98dda5fe424ba805f04793f4dd29~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  age<span class="token operator">:</span> <span class="token builtin">number</span>  job<span class="token operator">:</span> JobUnionType<span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">PickedFoo</span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span>Foo<span class="token punctuation">,</span> <span class="token string">'name'</span> <span class="token operator">|</span> <span class="token string">'age'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后 Pick 会将传入的联合类型作为需要保留的属性，使用这一联合类型配合映射类型，即上面的例子等价于：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token string">'name'</span> <span class="token operator">|</span> <span class="token string">'age'</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>联合类型的成员会被依次映射，并通过索引类型访问来获取到它们原本的类型。</p><p>而对于 Omit 类型，看名字其实能 get 到它就是 Pick 的反向实现：<strong>Pick 是保留这些传入的键</strong>，比如从一个庞大的结构中选择少数字段保留，需要的是这些少数字段，而 <strong>Omit 则是移除这些传入的键</strong>，也就是从一个庞大的结构中剔除少数字段，需要的是剩余的多数部分。</p><p>但它的实现看起来有些奇怪：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Omit<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token builtin">any</span><span class="token operator">></span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> Exclude<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">>></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先我们发现，Omit 是基于 Pick 实现的，这也是 TypeScript 中成对工具类型的另一种实现方式。上面的 Partial 与 Required 使用类似的结构，<strong>在关键位置使用一个相反操作来实现反向</strong>，而这里的 Omit 类型则是基于 Pick 类型实现，也就是<strong>反向工具类型基于正向工具类型实现</strong>。</p><p>首先接受的泛型参数类似，也是一个类型与联合类型（要剔除的属性），但是在将这个联合类型传入给 Pick 时多了一个 Exclude，这一工具类型属于工具类型，我们可以暂时理解为 <code>Exclude&lt;A, B&gt;</code> 的结果就是联合类型 A 中不存在于 B 中的部分：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Tmp1</span> <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">></span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Tmp2</span> <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">></span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Tmp3</span> <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token operator">></span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Tmp4</span> <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">4</span><span class="token operator">></span> <span class="token comment">// 1 | 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因此，在这里 <code>Exclude&lt;keyof T, K&gt;</code> 其实就是 T 的键名联合类型中剔除了 K 的部分，将其作为 Pick 的键名，就实现了剔除一部分类型的效果。</p><h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><ul><li>Pick 和 Omit 是基于键名的，如果我们需要<strong>基于键值类型</strong>呢？比如仅对函数类型的属性？</li><li>除了将一个对象结构拆分为多个子结构外，对这些子结构的<strong>互斥处理</strong>也是结构工具类型需要解决的问题之一。互斥处理指的是，假设你的对象存在三个属性 A、B、C ，其中 A 与 C 互斥，即 A 存在时不允许 C 存在。而 A 与 B 绑定，即 A 存在时 B 也必须存在，A 不存在时 B 也不允许存在。此时应该如何实现？</li></ul><p>另外，你可能发现 Pick 会约束第二个参数的联合类型来自于对象属性，而 Omit 并不这么要求？官方团队的考量是，可能存在这么一种情况：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Omit1<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">></span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> Exclude<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">>></span><span class="token keyword">type</span> <span class="token class-name">Omit2<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> Exclude<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">>></span><span class="token comment">// 这里就不能用严格 Omit 了</span><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">combineSpread</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T1</span><span class="token punctuation">,</span> <span class="token constant">T2</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>  obj<span class="token operator">:</span> <span class="token constant">T1</span><span class="token punctuation">,</span>  otherObj<span class="token operator">:</span> <span class="token constant">T2</span><span class="token punctuation">,</span>  rest<span class="token operator">:</span> Omit1<span class="token operator">&lt;</span><span class="token constant">T1</span><span class="token punctuation">,</span> <span class="token keyword">keyof</span> <span class="token constant">T2</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token keyword">type</span> <span class="token class-name">Point3d</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> z<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#125;</span><span class="token keyword">declare</span> <span class="token keyword">const</span> p1<span class="token operator">:</span> Point3d<span class="token comment">// 能够检测出错误，rest 中缺少了 y</span><span class="token function">combineSpread</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> x<span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> z<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们使用 <code>keyof Obj2</code> 去剔除 Obj1，此时如果声明约束反而不符合预期。</p><p>此前我在掘金发表过一篇详细介绍这一问题的文章，你可以参考 <a href="https://juejin.cn/post/7068947450714652709#comment">你的 Omit 类型还可以更严格一些</a>。</p><h2 id="集合工具类型"><a href="#集合工具类型" class="headerlink" title="集合工具类型"></a>集合工具类型</h2><p>这一部分的工具类型主要使用条件类型、条件类型分布式特性。</p><p>在开始集合类型前，我们不妨先聊一聊数学中的集合概念。对于两个集合来说，通常存在<strong>交集、并集、差集、补集</strong>这么几种情况，用图表示是这样的：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6fc9197877a41e1b017fe262b6191a8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>我们搭配上图来依次解释这些概念。</p><ul><li><strong>并集</strong>，两个集合的合并，合并时重复的元素只会保留一份（这也是联合类型的表现行为）。</li><li><strong>交集</strong>，两个集合的相交部分，即同时存在于这两个集合内的元素组成的集合。</li><li><strong>差集</strong>，对于 A、B 两个集合来说，A 相对于 B 的差集即为 <strong>A 中独有而 B 中不存在的元素</strong> 的组成的集合，或者说 <strong>A 中剔除了 B 中也存在的元素以后剩下的部分</strong>。</li><li><strong>补集</strong>，补集是差集的特殊情况，此时<strong>集合 B 为集合 A 的子集</strong>，在这种情况下 <strong>A 相对于 B 的补集</strong> + <strong>B</strong> = <strong>完整的集合 A</strong>。</li></ul><p>内置工具类型中提供了交集与差集的实现：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Extract<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span> <span class="token operator">?</span> <span class="token constant">T</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token keyword">type</span> <span class="token class-name">Exclude<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">T</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的具体实现其实就是条件类型的分布式特性，即当 T、U 都是联合类型（视为一个集合）时，T 的成员会依次被拿出来进行 <code>extends U ? T1 : T2</code>的计算，然后将最终的结果再合并成联合类型。</p><p>比如对于交集 Extract ，其运行逻辑是这样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">AExtractB</span> <span class="token operator">=</span> Extract<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">4</span><span class="token operator">></span> <span class="token comment">// 1 | 2</span><span class="token keyword">type</span> <span class="token class-name">_AExtractB</span> <span class="token operator">=</span>  <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">extends</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>  <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">extends</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">)</span> <span class="token comment">// 2</span>  <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token keyword">extends</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">?</span> <span class="token number">3</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">)</span> <span class="token comment">// never</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而差集 Exclude 也是类似，但需要注意的是，差集存在相对的概念，即 A 相对于 B 的差集与 B 相对于 A 的差集并不一定相同，而交集则一定相同。</p><p>为了便于理解，我们也将差集展开：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">SetA</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">5</span><span class="token keyword">type</span> <span class="token class-name">SetB</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">4</span><span class="token keyword">type</span> <span class="token class-name">AExcludeB</span> <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span>SetA<span class="token punctuation">,</span> SetB<span class="token operator">></span> <span class="token comment">// 3 | 5</span><span class="token keyword">type</span> <span class="token class-name">BExcludeA</span> <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span>SetB<span class="token punctuation">,</span> SetA<span class="token operator">></span> <span class="token comment">// 0 | 4</span><span class="token keyword">type</span> <span class="token class-name">_AExcludeB</span> <span class="token operator">=</span>  <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">extends</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// never</span>  <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">extends</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// never</span>  <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token keyword">extends</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">// 3</span>  <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">5</span> <span class="token keyword">extends</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">// 5</span><span class="token keyword">type</span> <span class="token class-name">_BExcludeA</span> <span class="token operator">=</span>  <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token keyword">extends</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">5</span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 0</span>  <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">extends</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">5</span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// never</span>  <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">extends</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">5</span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// never</span>  <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token keyword">extends</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">5</span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">// 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了差集和交集，我们也可以很容易实现并集与补集，为了更好地建立印象，这里我们使用集合相关的命名：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 并集</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Concurrence<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token operator">|</span> <span class="token constant">B</span><span class="token comment">// 交集</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Intersection<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">?</span> <span class="token constant">A</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token comment">// 差集</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Difference<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">A</span><span class="token comment">// 补集</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Complement<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span> <span class="token keyword">extends</span> <span class="token constant">A</span><span class="token operator">></span></span> <span class="token operator">=</span> Difference<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>补集基于差集实现，我们只需要约束<strong>集合 B 为集合 A 的子集</strong>即可。</p><p>内置工具类型中还有一个场景比较明确的集合工具类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">NonNullable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">null</span></span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token keyword">type</span> <span class="token class-name">_NonNullable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> Difference<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>很明显，它的本质就是集合 T 相对于 <code>null | undefined</code> 的差集，因此我们可以用之前的差集来进行实现。</p><p>在基于分布式条件类型的工具类型中，其实也存在着正反工具类型，但<strong>并不都是简单地替换条件类型结果的两端</strong>，如交集与补集就只是简单调换了结果，但二者作用却<strong>完全不同</strong>。</p><p>联合类型中会自动合并相同的元素，因此我们可以默认这里指的类型集合全部都是类似 Set 那样的结构，不存在重复元素。</p><h3 id="思考-2"><a href="#思考-2" class="headerlink" title="思考"></a>思考</h3><ul><li>目前为止我们的集合类型都停留在一维的层面，即联合类型之间的集合运算。如果现在我们要处理<strong>对象类型结构的集合运算</strong>呢？</li><li>在处理对象类型结构运算时，可能存在不同的需求，比如合并时，我们可能希望<strong>保留原属性或替换原属性</strong>，可能希望<strong>替换原属性的同时并不追加新的属性</strong>进来（即仅使用新的对象类型中的属性值覆盖原本对象类型中的同名属性值），此时要如何灵活地处理这些情况？</li></ul><h2 id="模式匹配工具类型"><a href="#模式匹配工具类型" class="headerlink" title="模式匹配工具类型"></a>模式匹配工具类型</h2><p>这一部分的工具类型主要使用<strong>条件类型</strong>与 <strong>infer 关键字</strong>。</p><p>在条件类型一节中我们已经差不多了解了 infer 关键字的使用，而更严格地说 infer 其实代表了一种 <strong>模式匹配（pattern matching）</strong> 的思路，如正则表达式、Glob 中等都体现了这一概念。</p><p>首先是对函数类型签名的模式匹配：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">FunctionType</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">any</span><span class="token keyword">type</span> <span class="token class-name">Parameters<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> FunctionType<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">P</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">any</span>  <span class="token operator">?</span> <span class="token constant">P</span>  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token keyword">type</span> <span class="token class-name">ReturnType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> FunctionType<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">infer</span> <span class="token constant">R</span>  <span class="token operator">?</span> <span class="token constant">R</span>  <span class="token operator">:</span> <span class="token builtin">any</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据 infer 的位置不同，我们就能够获取到不同位置的类型，在函数这里则是参数类型与返回值类型。</p><p>我们还可以更进一步，比如只匹配第一个参数类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">FirstParameter<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> FunctionType<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span>  arg<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">P</span><span class="token punctuation">,</span>  <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">any</span>  <span class="token operator">?</span> <span class="token constant">P</span>  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token keyword">type</span> <span class="token class-name">FuncFoo</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token keyword">type</span> <span class="token class-name">FuncBar</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token keyword">type</span> <span class="token class-name">FooFirstParameter</span> <span class="token operator">=</span> FirstParameter<span class="token operator">&lt;</span>FuncFoo<span class="token operator">></span> <span class="token comment">// number</span><span class="token keyword">type</span> <span class="token class-name">BarFirstParameter</span> <span class="token operator">=</span> FirstParameter<span class="token operator">&lt;</span>FuncBar<span class="token operator">></span> <span class="token comment">// string</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了对函数类型进行模式匹配，内置工具类型中还有一组对 Class 进行模式匹配的工具类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ClassType</span> <span class="token operator">=</span> <span class="token keyword">abstract</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">any</span><span class="token keyword">type</span> <span class="token class-name">ConstructorParameters<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> ClassType<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">abstract</span></span> <span class="token keyword">new</span> <span class="token punctuation">(</span>  <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">P</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">any</span>  <span class="token operator">?</span> <span class="token constant">P</span>  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token keyword">type</span> <span class="token class-name">InstanceType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> ClassType<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">abstract</span></span> <span class="token keyword">new</span> <span class="token punctuation">(</span>  <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">infer</span> <span class="token constant">R</span>  <span class="token operator">?</span> <span class="token constant">R</span>  <span class="token operator">:</span> <span class="token builtin">any</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Class 的通用类型签名可能看起来比较奇怪，但实际上它就是声明了可实例化（new）与可抽象（abstract）罢了。我们也可以使用接口来进行声明：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">ClassType<span class="token operator">&lt;</span>TInstanceType <span class="token operator">=</span> <span class="token builtin">any</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> TInstanceType<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对 Class 的模式匹配思路类似于函数，或者说这是一个通用的思路，即基于放置位置的匹配。放在参数部分，那就是构造函数的参数类型，放在返回值部分，那当然就是 Class 的实例类型了。</p><h3 id="思考-3"><a href="#思考-3" class="headerlink" title="思考"></a>思考</h3><ul><li>infer 和条件类型的搭配看起来会有奇效，比如在哪些场景？比如随着条件类型的嵌套每个分支会提取不同位置的 infer ？</li><li>infer 在某些特殊位置下应该如何处理？比如上面我们写了第一个参数类型，不妨试着来写写<strong>最后一个参数类型</strong>？</li></ul><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节，我们对 TypeScript 内置的工具类型进行了全面地讲解，从它们的原理、使用的类型操作、使用场景，到对它们进行扩展的可能方向。在学习完毕本节内容以后，你可能会发现某些工具类型很好地解决了曾困扰你的问题，也可能发现某些工具类型离解决问题还差上那么一些？</p><p>这个时候，不妨回想下我们前面学到的这么多类型工具，条件类型、索引类型、映射类型等以及各种关键字，思考下如果把泛型当成函数参数，你要如何写一个函数才能实现自己想要的效果？然后尝试将函数的逻辑迁移到类型编程中，或许你会恍然大悟。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="infer-约束"><a href="#infer-约束" class="headerlink" title="infer 约束"></a>infer 约束</h3><p>在某些时候，我们可能对 infer 提取的类型值有些要求，比如我只想要数组第一个为字符串的成员，如果第一个成员不是字符串，那我就不要了。</p><p>先写一个提取数组第一个成员的工具类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">FirstArrayItemType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token keyword">infer</span> <span class="token constant">P</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token operator">?</span> <span class="token constant">P</span>  <span class="token operator">:</span> <span class="token builtin">never</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>加上对提取字符串的条件类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">FirstArrayItemType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token keyword">infer</span> <span class="token constant">P</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token operator">?</span> <span class="token constant">P</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span>    <span class="token operator">?</span> <span class="token constant">P</span>    <span class="token operator">:</span> <span class="token builtin">never</span>  <span class="token operator">:</span> <span class="token builtin">never</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>试用一下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Tmp1</span> <span class="token operator">=</span> FirstArrayItemType<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token number">599</span><span class="token punctuation">,</span> <span class="token string">'linbudu'</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token comment">// never</span><span class="token keyword">type</span> <span class="token class-name">Tmp2</span> <span class="token operator">=</span> FirstArrayItemType<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token number">599</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token comment">// 'linbudu'</span><span class="token keyword">type</span> <span class="token class-name">Tmp3</span> <span class="token operator">=</span> FirstArrayItemType<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token string">'linbudu'</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token comment">// 'linbudu'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>看起来好像能满足需求，但程序员总是精益求精的。泛型可以声明约束，只允许传入特定的类型，那 infer 中能否也添加约束，只提取特定的类型？</p><p>TypeScript 4.7 就支持了 infer 约束功能来实现<strong>对特定类型地提取</strong>，比如上面的例子可以改写为这样：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">FirstArrayItemType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span>  <span class="token keyword">infer</span> <span class="token constant">P</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span><span class="token punctuation">,</span>  <span class="token operator">...</span><span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token operator">?</span> <span class="token constant">P</span>  <span class="token operator">:</span> <span class="token builtin">never</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，infer + 约束的场景是非常常见的，尤其是在某些连续嵌套的情况下，一层层的 infer 提取再筛选会严重地影响代码的可读性，而 infer 约束这一功能无疑带来了更简洁直观的类型编程代码。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>12.类型里的逻辑运算：条件类型与 infer</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/12.%E7%B1%BB%E5%9E%8B%E9%87%8C%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%EF%BC%9A%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%20infer/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/12.%E7%B1%BB%E5%9E%8B%E9%87%8C%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%EF%BC%9A%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%20infer/</url>
      
        <content type="html"><![CDATA[<p>在完成类型层级一节的学习后，这一节学习条件类型对你来说已经没有什么困难了，因为你已经完全理解了它的判断逻辑！那我们直接开始这一节的学习吧！</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F09-conditional-types">Conditional Types</a></p></blockquote><h2 id="条件类型基础"><a href="#条件类型基础" class="headerlink" title="条件类型基础"></a>条件类型基础</h2><p>条件类型的语法类似于我们平时常用的三元表达式，它的基本语法如下（伪代码）：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">ValueA <span class="token operator">===</span> ValueB <span class="token operator">?</span> Result1 <span class="token operator">:</span> Result2<span class="token punctuation">;</span>TypeA <span class="token keyword">extends</span> <span class="token class-name">TypeB</span> <span class="token operator">?</span> Result1 <span class="token operator">:</span> Result2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但需要注意的是，条件类型中使用 extends 判断类型的兼容性，而非判断类型的全等性。这是因为在类型层面中，对于能够进行赋值操作的两个变量，我们<strong>并不需要它们的类型完全相等，只需要具有兼容性</strong>，而两个完全相同的类型，其 extends 自然也是成立的。</p><p>条件类型绝大部分场景下会和泛型一起使用，我们知道，泛型参数的实际类型会在实际调用时才被填充（类型别名中显式传入，或者函数中隐式提取），而条件类型在这一基础上，可以基于填充后的泛型参数做进一步的类型操作，比如这个例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">LiteralType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token string">'string'</span> <span class="token operator">:</span> <span class="token string">'other'</span><span class="token keyword">type</span> <span class="token class-name">Res1</span> <span class="token operator">=</span> LiteralType<span class="token operator">&lt;</span><span class="token string">'linbudu'</span><span class="token operator">></span> <span class="token comment">// "string"</span><span class="token keyword">type</span> <span class="token class-name">Res2</span> <span class="token operator">=</span> LiteralType<span class="token operator">&lt;</span><span class="token number">599</span><span class="token operator">></span> <span class="token comment">// "other"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同三元表达式可以嵌套一样，条件类型中也常见多层嵌套，如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">LiteralType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span>  <span class="token operator">?</span> <span class="token string">'string'</span>  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span>  <span class="token operator">?</span> <span class="token string">'number'</span>  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">boolean</span></span>  <span class="token operator">?</span> <span class="token string">'boolean'</span>  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">null</span></span>  <span class="token operator">?</span> <span class="token string">'null'</span>  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">undefined</span></span>  <span class="token operator">?</span> <span class="token string">'undefined'</span>  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token keyword">type</span> <span class="token class-name">Res1</span> <span class="token operator">=</span> LiteralType<span class="token operator">&lt;</span><span class="token string">'linbudu'</span><span class="token operator">></span> <span class="token comment">// "string"</span><span class="token keyword">type</span> <span class="token class-name">Res2</span> <span class="token operator">=</span> LiteralType<span class="token operator">&lt;</span><span class="token number">599</span><span class="token operator">></span> <span class="token comment">// "number"</span><span class="token keyword">type</span> <span class="token class-name">Res3</span> <span class="token operator">=</span> LiteralType<span class="token operator">&lt;</span><span class="token boolean">true</span><span class="token operator">></span> <span class="token comment">// "boolean"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而在函数中，条件类型与泛型的搭配同样很常见。考考你，以下这个函数，我们应该如何标注它的返回值类型？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">universalAdd</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">number</span> <span class="token operator">|</span> bigint <span class="token operator">|</span> <span class="token builtin">string</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token punctuation">(</span>y <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当我们调用这个函数时，由于两个参数都引用了泛型参数 T ，因此泛型会被填充为一个联合类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token function">universalAdd</span><span class="token punctuation">(</span><span class="token number">599</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// T 填充为 599 | 1</span><span class="token function">universalAdd</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token string">'599'</span><span class="token punctuation">)</span> <span class="token comment">// T 填充为 linbudu | 599</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么此时的返回值类型就需要从这个字面量联合类型中推导回其原本的基础类型。在类型层级一节中，我们知道<strong>同一基础类型的字面量联合类型，其可以被认为是此基础类型的子类型</strong>，即 <code>599 | 1</code> 是 number 的子类型。</p><p>因此，我们可以使用嵌套的条件类型来进行字面量类型到基础类型地提取：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">universalAdd</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">number</span> <span class="token operator">|</span> bigint <span class="token operator">|</span> <span class="token builtin">string</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>  x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span>  y<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> LiteralToPrimitive<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token punctuation">(</span>y <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">LiteralToPrimitive<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span>  <span class="token operator">?</span> <span class="token builtin">number</span>  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">bigint</span>  <span class="token operator">?</span> bigint  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span>  <span class="token operator">?</span> <span class="token builtin">string</span>  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token function">universalAdd</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token string">'599'</span><span class="token punctuation">)</span> <span class="token comment">// string</span><span class="token function">universalAdd</span><span class="token punctuation">(</span><span class="token number">599</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// number</span><span class="token function">universalAdd</span><span class="token punctuation">(</span><span class="token number">10n</span><span class="token punctuation">,</span> <span class="token number">10n</span><span class="token punctuation">)</span> <span class="token comment">// bigint</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>条件类型还可以用来对更复杂的类型进行比较，比如函数类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Func</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">any</span><span class="token keyword">type</span> <span class="token class-name">FunctionConditionType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> Func<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span>  <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">string</span>  <span class="token operator">?</span> <span class="token string">'A string return func!'</span>  <span class="token operator">:</span> <span class="token string">'A non-string return func!'</span><span class="token comment">//  "A string return func!"</span><span class="token keyword">type</span> <span class="token class-name">StringResult</span> <span class="token operator">=</span> FunctionConditionType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">string</span><span class="token operator">></span><span class="token comment">// 'A non-string return func!';</span><span class="token keyword">type</span> <span class="token class-name">NonStringResult1</span> <span class="token operator">=</span> FunctionConditionType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">boolean</span><span class="token operator">></span><span class="token comment">// 'A non-string return func!';</span><span class="token keyword">type</span> <span class="token class-name">NonStringResult2</span> <span class="token operator">=</span> FunctionConditionType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">number</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，我们的条件类型用于判断两个函数类型是否具有兼容性，而条件中并不限制参数类型，仅比较二者的返回值类型。</p><p>与此同时，存在泛型约束和条件类型两个 extends 可能会让你感到疑惑，但它们产生作用的时机完全不同，泛型约束要求你传入符合结构的类型参数，相当于<strong>参数校验</strong>。而条件类型使用类型参数进行条件判断（就像 if else），相当于<strong>实际内部逻辑</strong>。</p><p>我们上面讲到的这些条件类型，本质上就是在泛型基于调用填充类型信息的基础上，新增了<strong>基于类型信息的条件判断</strong>。看起来很不错，但你可能也发现了一个无法满足的场景：提取传入的类型信息。</p><h2 id="infer-关键字"><a href="#infer-关键字" class="headerlink" title="infer 关键字"></a>infer 关键字</h2><p>在上面的例子中，假如我们不再比较填充的函数类型是否是 <code>(...args: any[]) =&gt; string</code> 的子类型，而是要拿到其返回值类型呢？或者说，我们希望拿到填充的类型信息的一部分，而不是只是用它来做条件呢？</p><p>TypeScript 中支持通过 infer 关键字来<strong>在条件类型中提取类型的某一部分信息</strong>，比如上面我们要提取函数返回值类型的话，可以这么放：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">FunctionReturnType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> Func<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">infer</span> <span class="token constant">R</span>  <span class="token operator">?</span> <span class="token constant">R</span>  <span class="token operator">:</span> <span class="token builtin">never</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>看起来是新朋友，其实还是老伙计。上面的代码其实表达了，当传入的类型参数满足 <code>T extends (...args: any[] ) =&gt; infer R</code> 这样一个结构（不用管 <code>infer R</code>，当它是 any 就行），返回 <code>infer R</code>位置的值，即 R。否则，返回 never。</p><p><code>infer</code>是 <code>inference</code> 的缩写，意为推断，如 <code>infer R</code> 中 <code>R</code> 就表示 <strong>待推断的类型</strong>。 <code>infer</code> 只能在条件类型中使用，因为我们实际上仍然需要<strong>类型结构是一致的</strong>，比如上例中类型信息需要是一个函数类型结构，我们才能提取出它的返回值类型。如果连函数类型都不是，那我只会给你一个 never 。</p><p>这里的<strong>类型结构</strong>当然并不局限于函数类型结构，还可以是数组：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Swap<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token keyword">infer</span> <span class="token constant">A</span><span class="token punctuation">,</span> <span class="token keyword">infer</span> <span class="token constant">B</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token keyword">type</span> <span class="token class-name">SwapResult1</span> <span class="token operator">=</span> Swap<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token comment">// 符合元组结构，首尾元素替换[2, 1]</span><span class="token keyword">type</span> <span class="token class-name">SwapResult2</span> <span class="token operator">=</span> Swap<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token comment">// 不符合结构，没有发生替换，仍是 [1, 2, 3]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于我们声明的结构是一个仅有两个元素的元组，因此三个元素的元组就被认为是不符合类型结构了。但我们可以使用 rest 操作符来处理任意长度的情况：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 提取首尾两个</span><span class="token keyword">type</span> <span class="token class-name">ExtractStartAndEnd<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span>  <span class="token keyword">infer</span> Start<span class="token punctuation">,</span>  <span class="token operator">...</span><span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token keyword">infer</span> End<span class="token punctuation">]</span>  <span class="token operator">?</span> <span class="token punctuation">[</span>Start<span class="token punctuation">,</span> End<span class="token punctuation">]</span>  <span class="token operator">:</span> <span class="token constant">T</span><span class="token comment">// 调换首尾两个</span><span class="token keyword">type</span> <span class="token class-name">SwapStartAndEnd<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span>  <span class="token keyword">infer</span> Start<span class="token punctuation">,</span>  <span class="token operator">...</span><span class="token keyword">infer</span> Left<span class="token punctuation">,</span>  <span class="token keyword">infer</span> End<span class="token punctuation">]</span>  <span class="token operator">?</span> <span class="token punctuation">[</span>End<span class="token punctuation">,</span> <span class="token operator">...</span>Left<span class="token punctuation">,</span> Start<span class="token punctuation">]</span>  <span class="token operator">:</span> <span class="token constant">T</span><span class="token comment">// 调换开头两个</span><span class="token keyword">type</span> <span class="token class-name">SwapFirstTwo<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span>  <span class="token keyword">infer</span> Start1<span class="token punctuation">,</span>  <span class="token keyword">infer</span> Start2<span class="token punctuation">,</span>  <span class="token operator">...</span><span class="token keyword">infer</span> Left<span class="token punctuation">]</span>  <span class="token operator">?</span> <span class="token punctuation">[</span>Start2<span class="token punctuation">,</span> Start1<span class="token punctuation">,</span> <span class="token operator">...</span>Left<span class="token punctuation">]</span>  <span class="token operator">:</span> <span class="token constant">T</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是的，infer 甚至可以和 rest 操作符一样同时提取一组不定长的类型，而 <code>...any[]</code> 的用法是否也让你直呼神奇？上面的输入输出仍然都是数组，而实际上我们完全可以进行结构层面的转换。比如从数组到联合类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ArrayItemType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token keyword">infer</span> ElementType<span class="token operator">></span></span> <span class="token operator">?</span> ElementType <span class="token operator">:</span> <span class="token builtin">never</span><span class="token keyword">type</span> <span class="token class-name">ArrayItemTypeResult1</span> <span class="token operator">=</span> ArrayItemType<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token comment">// never</span><span class="token keyword">type</span> <span class="token class-name">ArrayItemTypeResult2</span> <span class="token operator">=</span> ArrayItemType<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token comment">// string</span><span class="token keyword">type</span> <span class="token class-name">ArrayItemTypeResult3</span> <span class="token operator">=</span> ArrayItemType<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token comment">// string | number</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原理即是这里的 <code>[string, number]</code> 实际上等价于 <code>(string | number)[]</code>。</p><p>除了数组，infer 结构也可以是接口：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 提取对象的属性类型</span><span class="token keyword">type</span> <span class="token class-name">PropType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">[</span>Key <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">R</span> <span class="token punctuation">&#125;</span>  <span class="token operator">?</span> <span class="token constant">R</span>  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token keyword">type</span> <span class="token class-name">PropTypeResult1</span> <span class="token operator">=</span> PropType<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token operator">></span> <span class="token comment">// string</span><span class="token keyword">type</span> <span class="token class-name">PropTypeResult2</span> <span class="token operator">=</span> PropType<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">'name'</span> <span class="token operator">|</span> <span class="token string">'age'</span><span class="token operator">></span> <span class="token comment">// string | number</span><span class="token comment">// 反转键名与键值</span><span class="token keyword">type</span> <span class="token class-name">ReverseKeyValue<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">unknown</span><span class="token operator">>></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">Record<span class="token operator">&lt;</span>  <span class="token keyword">infer</span> <span class="token constant">K</span><span class="token punctuation">,</span>  <span class="token keyword">infer</span> <span class="token constant">V</span><span class="token operator">></span></span>  <span class="token operator">?</span> Record<span class="token operator">&lt;</span><span class="token constant">V</span> <span class="token operator">&amp;</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">></span>  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token keyword">type</span> <span class="token class-name">ReverseKeyValueResult1</span> <span class="token operator">=</span> ReverseKeyValue<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span> key<span class="token operator">:</span> <span class="token string">'value'</span> <span class="token punctuation">&#125;</span><span class="token operator">></span> <span class="token comment">// &#123; "value": "key" &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，为了体现 infer 作为类型工具的属性，我们结合了索引类型与映射类型，以及使用 <code>&amp; string</code> 来确保属性名为 string 类型的小技巧。</p><p>为什么需要这个小技巧，如果不使用又会有什么问题呢？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 类型“V”不满足约束“string | number | symbol”。</span><span class="token keyword">type</span> <span class="token class-name">ReverseKeyValue<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token operator">>></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">Record<span class="token operator">&lt;</span>  <span class="token keyword">infer</span> <span class="token constant">K</span><span class="token punctuation">,</span>  <span class="token keyword">infer</span> <span class="token constant">V</span><span class="token operator">></span></span>  <span class="token operator">?</span> Record<span class="token operator">&lt;</span><span class="token constant">V</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">></span>  <span class="token operator">:</span> <span class="token builtin">never</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>明明约束已经声明了 V 的类型是 string，为什么还是报错了？</p><p>这是因为，泛型参数 V 的来源是从键值类型推导出来的，TypeScript 中这样对键值类型进行 infer 推导，将导致类型信息丢失，而不满足索引签名类型只允许 <code>string | number | symbol</code> 的要求。</p><p>还记得映射类型的判断条件吗？需要同时满足其两端的类型，我们使用 <code>V &amp; string</code> 这一形式，就确保了最终符合条件的类型参数 V 一定会满足 <code>string | never</code> 这个类型，因此可以被视为合法的索引签名类型。</p><p>infer 结构还可以是 Promise 结构！</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">PromiseValue<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">V</span><span class="token operator">></span></span> <span class="token operator">?</span> <span class="token constant">V</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token keyword">type</span> <span class="token class-name">PromiseValueResult1</span> <span class="token operator">=</span> PromiseValue<span class="token operator">&lt;</span><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">>></span> <span class="token comment">// number</span><span class="token keyword">type</span> <span class="token class-name">PromiseValueResult2</span> <span class="token operator">=</span> PromiseValue<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">></span> <span class="token comment">// number，但并没有发生提取</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>就像条件类型可以嵌套一样，infer 关键字也经常被使用在嵌套的场景中，包括对类型结构深层信息地提取，以及对提取到类型信息的筛选等。比如上面的 PromiseValue，如果传入了一个嵌套的 Promise 类型就失效了：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">PromiseValueResult3</span> <span class="token operator">=</span> PromiseValue<span class="token operator">&lt;</span><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">boolean</span><span class="token operator">>>></span> <span class="token comment">// Promise&lt;boolean>，只提取了一层</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种时候我们就需要进行嵌套地提取了：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">PromiseValue<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">V</span><span class="token operator">></span></span>  <span class="token operator">?</span> <span class="token constant">V</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">N</span><span class="token operator">></span></span>    <span class="token operator">?</span> <span class="token constant">N</span>    <span class="token operator">:</span> <span class="token constant">V</span>  <span class="token operator">:</span> <span class="token constant">T</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，在这时应该使用递归来处理任意嵌套深度：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">PromiseValue<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">V</span><span class="token operator">></span></span> <span class="token operator">?</span> PromiseValue<span class="token operator">&lt;</span><span class="token constant">V</span><span class="token operator">></span> <span class="token operator">:</span> <span class="token constant">T</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>条件类型在泛型的基础上支持了基于类型信息的动态条件判断，但无法直接消费填充类型信息，而 infer 关键字则为它补上了这一部分的能力，让我们可以进行更多奇妙的类型操作。TypeScript 内置的工具类型中还有一些基于 infer 关键字的应用，我们会在内置工具类型讲解一章中了解它们的具体实现。而我们上面了解的 rest infer（<code>...any[]</code>），结合其他类型工具、递归 infer 等，都是日常比较常用的操作，这些例子应当能让你再一次意识到“类型编程”的真谛。</p><h2 id="分布式条件类型"><a href="#分布式条件类型" class="headerlink" title="分布式条件类型"></a>分布式条件类型</h2><p>分布式条件类型听起来真的很高级，但这里和分布式和分布式服务并不是一回事。<strong>分布式条件类型（*Distributive Conditional Type*），也称条件类型的分布式特性</strong>，只不过是条件类型在满足一定情况下会执行的逻辑而已。我们来看一个例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Condition<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">?</span> <span class="token constant">T</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token comment">// 1 | 2 | 3</span><span class="token keyword">type</span> <span class="token class-name">Res1</span> <span class="token operator">=</span> Condition<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">5</span><span class="token operator">></span><span class="token comment">// never</span><span class="token keyword">type</span> <span class="token class-name">Res2</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">5</span> <span class="token keyword">extends</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">5</span> <span class="token operator">:</span> <span class="token builtin">never</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子可能让你感觉充满了疑惑，某些地方似乎和我们学习的知识并不一样？先不说这两个理论上应该执行结果一致的类型别名，为什么在 Res1 中诡异地返回了一个联合类型？</p><p>仔细观察这两个类型别名的差异你会发现，唯一的差异就是在 Res1 中，进行判断的联合类型被作为泛型参数传入给另一个独立的类型别名，而 Res2 中直接对这两者进行判断。</p><p>记住第一个差异：<strong>是否通过泛型参数传入</strong>。我们再看一个例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Naked<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">boolean</span></span> <span class="token operator">?</span> <span class="token string">'Y'</span> <span class="token operator">:</span> <span class="token string">'N'</span><span class="token keyword">type</span> <span class="token class-name">Wrapped<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token builtin">boolean</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token string">'Y'</span> <span class="token operator">:</span> <span class="token string">'N'</span><span class="token comment">// "N" | "Y"</span><span class="token keyword">type</span> <span class="token class-name">Res3</span> <span class="token operator">=</span> Naked<span class="token operator">&lt;</span><span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token operator">></span><span class="token comment">// "N"</span><span class="token keyword">type</span> <span class="token class-name">Res4</span> <span class="token operator">=</span> Wrapped<span class="token operator">&lt;</span><span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们都是通过泛型参数传入了，但诡异的事情又发生了，为什么第一个还是个联合类型？第二个倒是好理解一些，元组的成员有可能是数字类型，显然不兼容于 <code>[boolean]</code>。再仔细观察这两个例子你会发现，它们唯一的差异是条件类型中的<strong>泛型参数是否被数组包裹</strong>了。</p><p>同时，你会发现在 Res3 的判断中，其联合类型的两个分支，恰好对应于分别使用 number 和 boolean 去作为条件类型判断时的结果。</p><p>把上面的线索理一下，其实我们就大致得到了条件类型分布式起作用的条件。首先，你的类型参数需要是一个联合类型 。其次，类型参数需要通过泛型参数的方式传入，而不能直接在外部进行判断（如 Res2 中）。最后，条件类型中的泛型参数不能被包裹。</p><p>而条件类型分布式特性会产生的效果也很明显了，即将这个联合类型拆开来，每个分支分别进行一次条件类型判断，再将最后的结果合并起来（如 Naked 中）。如果再严谨一些，其实我们就得到了官方的解释：</p><p><strong>对于属于裸类型参数的检查类型，条件类型会在实例化时期自动分发到联合类型上。</strong>（<strong><em>Conditional types in which the checked type is a naked type parameter are called distributive conditional types. Distributive conditional types are automatically distributed over union types during instantiation.</em></strong>）</p><p>这里的自动分发，我们可以这么理解：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Naked<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">boolean</span></span> <span class="token operator">?</span> <span class="token string">'Y'</span> <span class="token operator">:</span> <span class="token string">'N'</span><span class="token comment">// (number extends boolean ? "Y" : "N") | (boolean extends boolean ? "Y" : "N")</span><span class="token comment">// "N" | "Y"</span><span class="token keyword">type</span> <span class="token class-name">Res3</span> <span class="token operator">=</span> Naked<span class="token operator">&lt;</span><span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写成伪代码其实就是这样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> Res3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> input <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">boolean</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>input <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">boolean</span></span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Res3<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"Y"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    Res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"N"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而这里的裸类型参数，其实指的就是泛型参数是否完全裸露，我们上面使用数组包裹泛型参数只是其中一种方式，比如还可以这么做：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">NoDistribute<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">&amp;</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">Wrapped<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> NoDistribute<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token builtin">boolean</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token string">'Y'</span> <span class="token operator">:</span> <span class="token string">'N'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要注意的是，我们并不是只会通过裸露泛型参数，来确保分布式特性能够发生。在某些情况下，我们也会需要包裹泛型参数来禁用掉分布式特性。最常见的场景也许还是联合类型的判断，即我们不希望进行联合类型成员的分布判断，而是希望直接判断这两个联合类型的兼容性判断，就像在最初的 Res2 中那样：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">CompareUnion<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token constant">U</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token keyword">type</span> <span class="token class-name">CompareRes1</span> <span class="token operator">=</span> CompareUnion<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token operator">></span> <span class="token comment">// true</span><span class="token keyword">type</span> <span class="token class-name">CompareRes2</span> <span class="token operator">=</span> CompareUnion<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">></span> <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过将参数与条件都包裹起来的方式，我们对联合类型的比较就变成了数组成员类型的比较，在此时就会严格遵守类型层级一文中联合类型的类型判断了（子集为其子类型）。</p><p>另外一种情况则是，当我们想判断一个类型是否为 never 时，也可以通过类似的手段：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">IsNever<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token builtin">never</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token keyword">type</span> <span class="token class-name">IsNeverRes1</span> <span class="token operator">=</span> IsNever<span class="token operator">&lt;</span><span class="token builtin">never</span><span class="token operator">></span> <span class="token comment">// true</span><span class="token keyword">type</span> <span class="token class-name">IsNeverRes2</span> <span class="token operator">=</span> IsNever<span class="token operator">&lt;</span><span class="token string">'linbudu'</span><span class="token operator">></span> <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里的原因其实并不是因为分布式条件类型。我们此前在类型层级中了解过，当条件类型的判断参数为 any，会直接返回条件类型两个结果的联合类型。而在这里其实类似，当通过泛型传入的参数为 never，则会直接返回 never。</p><p>需要注意的是这里的 never 与 any 的情况并不完全相同，any 在直接<strong>作为判断参数时</strong>、<strong>作为泛型参数时</strong>都会产生这一效果：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 直接使用，返回联合类型</span><span class="token keyword">type</span> <span class="token class-name">Tmp1</span> <span class="token operator">=</span> <span class="token builtin">any</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1 | 2</span><span class="token keyword">type</span> <span class="token class-name">Tmp2<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token comment">// 通过泛型参数传入，同样返回联合类型</span><span class="token keyword">type</span> <span class="token class-name">Tmp2Res</span> <span class="token operator">=</span> Tmp2<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span> <span class="token comment">// 1 | 2</span><span class="token comment">// 如果判断条件是 any，那么仍然会进行判断</span><span class="token keyword">type</span> <span class="token class-name">Special1</span> <span class="token operator">=</span> <span class="token builtin">any</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Special2<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token keyword">type</span> <span class="token class-name">Special2Res</span> <span class="token operator">=</span> Special2<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而 never 仅在作为泛型参数时才会产生：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 直接使用，仍然会进行判断</span><span class="token keyword">type</span> <span class="token class-name">Tmp3</span> <span class="token operator">=</span> <span class="token builtin">never</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Tmp4<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token comment">// 通过泛型参数传入，会跳过判断</span><span class="token keyword">type</span> <span class="token class-name">Tmp4Res</span> <span class="token operator">=</span> Tmp4<span class="token operator">&lt;</span><span class="token builtin">never</span><span class="token operator">></span> <span class="token comment">// never</span><span class="token comment">// 如果判断条件是 never，还是仅在作为泛型参数时才跳过判断</span><span class="token keyword">type</span> <span class="token class-name">Special3</span> <span class="token operator">=</span> <span class="token builtin">never</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">never</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Special4<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">never</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token keyword">type</span> <span class="token class-name">Special4Res</span> <span class="token operator">=</span> Special4<span class="token operator">&lt;</span><span class="token builtin">never</span><span class="token operator">></span> <span class="token comment">// never</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 any、never 两种情况都不会实际地执行条件类型，而在这里我们通过包裹的方式让它不再是一个孤零零的 never，也就能够去执行判断了。</p><p>之所以分布式条件类型要这么设计，我个人理解主要是为了处理联合类型这种情况。就像我们到现在为止的伪代码都一直使用数组来表达联合类型一样，在类型世界中联合类型就像是一个集合一样。通过使用分布式条件类型，我们能轻易地进行集合之间的运算，比如交集：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Intersection<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">?</span> <span class="token constant">A</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token keyword">type</span> <span class="token class-name">IntersectionRes</span> <span class="token operator">=</span> Intersection<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">4</span><span class="token operator">></span> <span class="token comment">// 2 | 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>进一步的，当联合类型的组成是一个对象的属性名（<code>keyof IObject</code>），此时对这样的两个类型集合进行处理，得到属性名的交集，那我们就可以在此基础上获得两个对象类型结构的交集。除此以外，还有许多相对复杂的场景可以降维到类型集合，即联合类型的层面，然后我们就可以愉快地使用分布式条件类型进行各种处理了。关于类型层面的集合运算、对象结构集合运算，我们都会在小册的后续章节有详细的讲解。</p><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节，我们详细地解读了条件类型这一重要类型工具的使用方式、使用场景、分布式特性以及 infer 关键字。对于条件类型最核心的部分，即 extends 所代表的类型兼容性，由于在上一节我们已经了解了整个 TypeScript 类型系统的类型层级，因此在实际学习时其实基本没有什么压力，毕竟你已经参透了它最基础的运行规则。而对于 infer 关键字的使用，除了我们已经了解的，在函数结构、对象结构、数组结构等不同结构中的使用以外，请你不妨再试试它在更复杂场景下的使用，感受一下模式匹配的魅力。</p><p>在下一节，我们会开始探秘 TypeScript 内置的工具类型，看看它们是如何设计，以及又是用来解决什么问题的，并且思考如何让它们变得更完善。而在更后面，我们会了解更多类型系统的知识与更复杂的工具类型实现，欢迎与我一起深入类型编程的世界。</p><h2 id="扩展阅读：IsAny-与-IsUnknown"><a href="#扩展阅读：IsAny-与-IsUnknown" class="headerlink" title="扩展阅读：IsAny 与 IsUnknown"></a>扩展阅读：IsAny 与 IsUnknown</h2><p>上面我们通过比较 hack 的手段得到了 IsNever，那你一定会想是否能实现 IsAny 与 IsUnknown ？当然可以，只不过它们的实现稍微复杂一些，并且并不完全依赖分布式条件类型。</p><p>首先是 IsAny，上面已经提到我们并不能通过 <code>any extends Type</code> 这样的形式来判断一个类型是否是 any 。而是要利用 any 的另一个特性：身化万千：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">IsAny<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">extends</span> <span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token constant">T</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>0 extends 1</code> 必然是不成立的，而交叉类型 <code>1 &amp; T</code> 也非常奇怪，它意味着同时符合字面量类型 1 和另一个类型 T 。在学习交叉类型时我们已经了解，对于 1 这样的字面量类型，只有传入其本身、对应的原始类型、包含其本身的联合类型，才能得到一个有意义的值，并且这个值一定只可能是它本身：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Tmp1</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Tmp2</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token builtin">number</span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name">Tmp3</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">1</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是因为交叉类型<strong>就像短板效应一样，其最终计算的类型是由最短的那根木板</strong>，也就是最精确的那个类型决定的。这样看，无论如何 <code>0 extends 1</code> 都不会成立。</p><p>但作为代表任意类型的 any ，它的存在就像是开天辟地的基本规则一样，如果交叉类型的其中一个成员是 any，那短板效应就失效了，此时最终类型必然是 any 。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Tmp4</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token builtin">any</span> <span class="token comment">// any</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而对于 unknown 并不能享受到这个待遇，因为它并不是“身化万千”的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Tmp5</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token builtin">unknown</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此，我们并不能用这个方式来写 IsUnknown。其实现过程要更复杂一些，我们需要过滤掉其他全部的类型来只剩下 unknown 。这里直接看实现：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">IsUnknown<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> IsNever<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token boolean">false</span></span>  <span class="token operator">?</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">unknown</span></span>    <span class="token operator">?</span> <span class="token builtin">unknown</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">T</span></span>      <span class="token operator">?</span> IsAny<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token boolean">false</span></span>        <span class="token operator">?</span> <span class="token boolean">true</span>        <span class="token operator">:</span> <span class="token boolean">false</span>      <span class="token operator">:</span> <span class="token boolean">false</span>    <span class="token operator">:</span> <span class="token boolean">false</span>  <span class="token operator">:</span> <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先过滤掉 never 类型，然后对于 <code>T extends unknown</code> 和 <code>unknown extends T</code>，只有 any 和 unknown 类型能够同时符合（还记得我们在类型层级一节进行的尝试吗？），如果再过滤掉 any，那肯定就只剩下 unknown 类型啦。</p><p>更新：感谢评论区 <a href="https://juejin.cn/user/4459274891701224">红花绿叶肉夹馍</a> 同学的指出，这里的 IsUnknown 类型其实可以使用更简单的方式实现。利用 <code>unknown extends T</code> 时仅有 T 为 any 或 unknown 时成立这一点，我们可以直接将类型收窄到 any 与 unknown，然后在去掉 any 类型时，我们仍然可以利用上面的身化万千特性：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">IsUnknown<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token builtin">unknown</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">T</span></span>  <span class="token operator">?</span> IsAny<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token boolean">true</span></span>    <span class="token operator">?</span> <span class="token boolean">false</span>    <span class="token operator">:</span> <span class="token boolean">true</span>  <span class="token operator">:</span> <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>17.内置工具类型进阶：类型编程进阶</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/17.%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E8%BF%9B%E9%98%B6%EF%BC%9A%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/17.%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E8%BF%9B%E9%98%B6%EF%BC%9A%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>此前，我们已经了解了 TypeScript 中内置工具类型的实现原理，以及它们的扩展方向。这一节，我们会在这些基础上逐一实现这些扩展方向。</p><p>需要说明的是，本节中的工具类型会更加复杂和烧脑一些，你需要确保已经完全掌握了这一节前的绝大部分知识再来学习本节内容。如果在学习过程中发现有知识点的缺失，可以先回到前面的章节复习、巩固，再学不迟。</p><p>另外，这一节中介绍的工具类型绝大部分是具有实际应用场景的，如果你发现某一个工具类型恰好匹配了你的需求，不妨在自己的项目中复制一份。随着不断的积累，你会发现，你拥有了一个最适合自己的工具类型合集！</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F13-advanced-builtin-tool-types">Advanced Builtin Tool Types</a></p></blockquote><h2 id="属性修饰进阶"><a href="#属性修饰进阶" class="headerlink" title="属性修饰进阶"></a>属性修饰进阶</h2><p>在内置工具类型一节中，对属性修饰工具类型的进阶主要分为这么几个方向：</p><ul><li>深层的属性修饰；</li><li>基于已知属性的部分修饰，以及基于属性类型的部分修饰。</li></ul><p>首先是深层属性修饰，还记得我们在 infer 关键字一节首次接触到递归的工具类型吗？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">PromiseValue<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">V</span><span class="token operator">></span></span> <span class="token operator">?</span> PromiseValue<span class="token operator">&lt;</span><span class="token constant">V</span><span class="token operator">></span> <span class="token operator">:</span> <span class="token constant">T</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到，此时我们只是在条件类型成立时，再次调用了这个工具类型而已。在某一次递归到条件类型不成立时，就会直接返回这个类型值。那么对于 Partial、Required，其实我们也可以进行这样地处理：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">DeepPartial<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">object</span> <span class="token operator">?</span> DeepPartial<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>简单起见，我们直接使用了 object 作为泛型约束与条件，这意味着也有可能传入函数、数组等类型。但毕竟我们对这个类型知根知底，就可以假设只会传入对象结构，因此也只需要对对象类型进行处理了。</p><p>为了更直观地验证它的效果，我们使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ftsd">tsd</a> 这一工具类型单元测试库来进行验证，效果大概是这样：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> expectType <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'tsd'</span><span class="token keyword">type</span> <span class="token class-name">DeepPartialStruct</span> <span class="token operator">=</span> DeepPartial<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span>  foo<span class="token operator">:</span> <span class="token builtin">string</span>  nested<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    nestedFoo<span class="token operator">:</span> <span class="token builtin">string</span>    nestedBar<span class="token operator">:</span> <span class="token punctuation">&#123;</span>      nestedBarFoo<span class="token operator">:</span> <span class="token builtin">string</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">></span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>DeepPartialStruct<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  foo<span class="token operator">:</span> <span class="token string">'bar'</span><span class="token punctuation">,</span>  nested<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>DeepPartialStruct<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  nested<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    nestedBar<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>DeepPartialStruct<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  nested<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    nestedBar<span class="token operator">:</span> <span class="token punctuation">&#123;</span>      nestedBarFoo<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 expectType 的泛型坑位中传入一个类型，然后再传入一个值，就可以验证这个值是否符合泛型类型了。</p><p>类似的，我们还可以实现其他进行递归属性修饰的工具类型，展示如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">DeepPartial<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">object</span> <span class="token operator">?</span> DeepPartial<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">DeepRequired<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">object</span> <span class="token operator">?</span> DeepRequired<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token comment">// 也可以记作 DeepImmutable</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">DeepReadonly<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">object</span> <span class="token operator">?</span> DeepReadonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">DeepMutable<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token operator">-</span><span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">object</span> <span class="token operator">?</span> DeepMutable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，在内置工具类型一节的结构工具类型中，存在一个从联合类型中剔除 <code>null | undefined</code> 的工具类型 NonNullable：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">NonNullable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">null</span></span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">T</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在对象结构中我们也常声明类型为 <code>string | null</code> 的形式，代表了“<strong>这里有值，但可能是空值</strong>”。此时，我们也可以将其等价为一种属性修饰（Nullable 属性，前面则是 Optional / Readonly 属性）。因此，我们也可以像访问性修饰工具类型那样，实现一个 DeepNonNullable 来递归剔除所有属性的 null 与 undefined：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">NonNullable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">null</span></span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">DeepNonNullable<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">object</span>    <span class="token operator">?</span> DeepNonNullable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">></span>    <span class="token operator">:</span> NonNullable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，就像 Partial 与 Required 的关系一样，DeepNonNullable 也有自己的另一半：DeepNullable：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Nullable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">DeepNullable<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">object</span> <span class="token operator">?</span> DeepNullable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token operator">:</span> Nullable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>需要注意的是，DeepNullable 和 DeepNonNullable 需要在开启 <code>--strictNullChecks</code> 下才能正常工作。</p></blockquote><p>搞定了递归属性修饰，接着就是<strong>基于已知属性进行部分修饰了</strong>。这其实也很简单。你想，如果我们要让一个对象的三个已知属性为可选的，那只要把这个对象拆成 A、B 两个对象结构，分别由三个属性和其他属性组成。然后让对象 A 的属性全部变为可选的，和另外一个对象 B 组合起来，不就行了吗？</p><p>拆开来描述一下这句话，看看这里都用到了哪些知识：</p><ul><li>拆分对象结构，那不就是内置工具类型一节中讲到的<strong>结构工具类型</strong>，即 Pick 与 Omit？</li><li>三个属性的对象全部变为可选，那不就是属性修饰？岂不是可以直接用上面刚学到的<strong>递归属性修饰</strong>？</li><li>组合两个对象类型，也就意味着得到一个同时符合这两个对象类型的新结构，那不就是<strong>交叉类型</strong>？</li></ul><p>分析出了需要用到的工具和方法，那执行起来就简单多了。这也是使用最广泛的一种类型编程思路：<strong>将复杂的工具类型，拆解为由基础工具类型、类型工具的组合</strong>。</p><p>直接来看基于已知属性的部分修饰，MarkPropsAsOptional 会将一个对象的部分属性标记为可选：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">MarkPropsAsOptional<span class="token operator">&lt;</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span>  <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> Partial<span class="token operator">&lt;</span>Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">>></span> <span class="token operator">&amp;</span> Omit<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>T 为需要处理的对象类型，而 K 为需要标记为可选的属性。由于此时 K 必须为 T 内部的属性，因此我们将其约束为 keyof T，即对象属性组成的字面量联合类型。同时为了让它能够直接代替掉 Partial，我们为其指定默认值也为 keyof T，这样在不传入第二个泛型参数时，它的表现就和 Partial 一致，即全量的属性可选。</p><p>而其组成中，<code>Partial&lt;Pick&lt;T, K&gt;&gt;</code> 为需要标记为可选的属性组成的对象子结构，<code>Omit&lt;T, K&gt;</code> 则为不需要处理的部分，使用交叉类型将其组合即可。我们验证下效果：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">MarkPropsAsOptionalStruct</span> <span class="token operator">=</span> MarkPropsAsOptional<span class="token operator">&lt;</span>  <span class="token punctuation">&#123;</span>    foo<span class="token operator">:</span> <span class="token builtin">string</span>    bar<span class="token operator">:</span> <span class="token builtin">number</span>    baz<span class="token operator">:</span> <span class="token builtin">boolean</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token string">'bar'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25c9cbf92f7f4e6db685f61fdc6dd608~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>啊哦，这可不好看出来具体效果。此时我们可以引入一个辅助的工具类型，我称其为 Flatten，对于这种交叉类型的结构，Flatten 能够将它展平为单层的对象结构。而它的实现也很简单，就是复制一下结构罢了：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Flatten<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">MarkPropsAsOptional<span class="token operator">&lt;</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span>  <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> Flatten<span class="token operator">&lt;</span>Partial<span class="token operator">&lt;</span>Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">>></span> <span class="token operator">&amp;</span> Omit<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">>></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4800d32ded6f4b45bdc72f70c05df0d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>现在它就直观多了，那我们也就无需再进行实际验证了。</p><blockquote><p>在这里你其实也可以使用 <code>DeepPartial&lt;Pick&lt;T, K&gt;&gt;</code>，来把这些属性标记为深层的可选状态。</p></blockquote><p>我们来实现其它类型的部分修饰：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">MarkPropsAsRequired<span class="token operator">&lt;</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span>  <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> Flatten<span class="token operator">&lt;</span>Omit<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">></span> <span class="token operator">&amp;</span> Required<span class="token operator">&lt;</span>Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">>>></span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">MarkPropsAsReadonly<span class="token operator">&lt;</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span>  <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> Flatten<span class="token operator">&lt;</span>Omit<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">></span> <span class="token operator">&amp;</span> Readonly<span class="token operator">&lt;</span>Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">>>></span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">MarkPropsAsMutable<span class="token operator">&lt;</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span>  <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> Flatten<span class="token operator">&lt;</span>Omit<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">></span> <span class="token operator">&amp;</span> Mutable<span class="token operator">&lt;</span>Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">>>></span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">MarkPropsAsNullable<span class="token operator">&lt;</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span>  <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> Flatten<span class="token operator">&lt;</span>Omit<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">></span> <span class="token operator">&amp;</span> Nullable<span class="token operator">&lt;</span>Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">>>></span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">MarkPropsAsNonNullable<span class="token operator">&lt;</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span>  <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> Flatten<span class="token operator">&lt;</span>Omit<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">></span> <span class="token operator">&amp;</span> NonNullable<span class="token operator">&lt;</span>Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">>>></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而对于按照值类型的部分修饰，比如标记所有函数类型属性为可选，其实和这里是一样的思路：<strong>拆分-处理-组合</strong>，只不过我们此前使用基于键名裁剪的 Pick、Omit，现在我们需要基于键值类型裁剪的 PickByValueType、OmitByValueType 了。而在接下来的结构工具类型进阶中，我们会了解到如何<strong>基于键值类型去裁剪结构</strong>。</p><p>这一节介绍的属性修饰工具类型在日常开发中也是非常常用的，如一个结构，在被用作多个 React 组件的属性类型时，可能存在一些属性修饰的差异。此时就可以基于这些工具类型，基于源头的接口结构做定制处理，避免多次声明基本重复的类型结构。</p><h2 id="结构工具类型进阶"><a href="#结构工具类型进阶" class="headerlink" title="结构工具类型进阶"></a>结构工具类型进阶</h2><p>前面对结构工具类型主要给出了两个进阶方向：</p><ul><li>基于键值类型的 Pick 与 Omit；</li><li>子结构的互斥处理。</li></ul><p>首先是基于键值类型的 Pick 与 Omit，我们就称之为 PickByValueType 好了。它的实现方式其实还是类似部分属性修饰中那样，将对象拆分为两个部分，处理完毕再组装。只不过，现在我们无法预先确定要拆分的属性了，而是需要<strong>基于期望的类型去拿到所有此类型的属性名</strong>，如想 Pick 出所有函数类型的值，那就要先拿到所有的函数类型属性名。先来一个 FunctionKeys 工具类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">FuncStruct</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">any</span><span class="token keyword">type</span> <span class="token class-name">FunctionKeys<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">FuncStruct</span> <span class="token operator">?</span> <span class="token constant">K</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>&#123;&#125;[keyof T]</code> 这个写法我们是第一次见，但我们可以拆开来看，先看看前面的 <code>&#123; [K in keyof T]: T[K] extends FuncStruct ? K : never; &#125;</code> 部分，为何在条件类型成立时它返回了键名 K，而非索引类型查询 <code>T[K]</code> ？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Tmp<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">FuncStruct</span> <span class="token operator">?</span> <span class="token constant">K</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">Res</span> <span class="token operator">=</span> Tmp<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span>  <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span>  <span class="token function-variable function">bar</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">number</span>  baz<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token operator">></span><span class="token keyword">type</span> <span class="token class-name">ResEqual</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  foo<span class="token operator">:</span> <span class="token string">'foo'</span>  bar<span class="token operator">:</span> <span class="token string">'bar'</span>  baz<span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Res（等价于 ResEqual）中，我们获得了一个<strong>属性名-属性名字面量类型</strong>的结构，对于非函数类型的属性，其值为 never。然后，我们加上 <code>[keyof T]</code> 这一索引类型查询 + keyof 操作符的组合：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">WhatWillWeGet</span> <span class="token operator">=</span> Res<span class="token punctuation">[</span><span class="token keyword">keyof</span> Res<span class="token punctuation">]</span> <span class="token comment">// "foo" | "bar"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们神奇地获得了所有函数类型的属性名！这又是如何实现的呢？其实就是我们此前学习过的，当索引类型查询中使用了一个联合类型时，它会使用类似分布式条件类型的方式，将这个联合类型的成员依次进行访问，然后再最终组合起来，上面的例子可以这么简化：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">WhatWillWeGetEqual1</span> <span class="token operator">=</span> Res<span class="token punctuation">[</span><span class="token string">'foo'</span> <span class="token operator">|</span> <span class="token string">'bar'</span> <span class="token operator">|</span> <span class="token string">'baz'</span><span class="token punctuation">]</span><span class="token keyword">type</span> <span class="token class-name">WhatWillWeGetEqual2</span> <span class="token operator">=</span> Res<span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">]</span> <span class="token operator">|</span> Res<span class="token punctuation">[</span><span class="token string">'bar'</span><span class="token punctuation">]</span> <span class="token operator">|</span> Res<span class="token punctuation">[</span><span class="token string">'baz'</span><span class="token punctuation">]</span><span class="token keyword">type</span> <span class="token class-name">WhatWillWeGetEqual3</span> <span class="token operator">=</span> <span class="token string">'foo'</span> <span class="token operator">|</span> <span class="token string">'bar'</span> <span class="token operator">|</span> <span class="token builtin">never</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过这一方式，我们就能够获取到符合预期类型的属性名了。如果希望抽象“基于键值类型查找属性”名这么个逻辑，我们就需要对 FunctionKeys 的逻辑进行封装，即<strong>将预期类型也作为泛型参数</strong>，由外部传入：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ExpectedPropKeys<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span> ValueType<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span>Key <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span>Key<span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">ValueType</span> <span class="token operator">?</span> Key <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token keyword">type</span> <span class="token class-name">FunctionKeys<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">></span></span> <span class="token operator">=</span> ExpectedPropKeys<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> FuncStruct<span class="token operator">></span>expectType<span class="token operator">&lt;</span>  FunctionKeys<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span>    <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span>    <span class="token function-variable function">bar</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">number</span>    baz<span class="token operator">:</span> <span class="token builtin">number</span>  <span class="token punctuation">&#125;</span><span class="token operator">></span><span class="token operator">></span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>expectType<span class="token operator">&lt;</span>  FunctionKeys<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span>    <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span>    <span class="token function-variable function">bar</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">number</span>    baz<span class="token operator">:</span> <span class="token builtin">number</span>  <span class="token punctuation">&#125;</span><span class="token operator">></span>  <span class="token comment">// 报错，因为 baz 不是函数类型属性</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token string">'baz'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，为了避免可选属性对条件类型语句造成干扰，这里我们使用 <code>-?</code> 移除了所有可选标记。</p><p>既然我们现在可以拿到对应类型的属性名，那么把这些属性交给 Pick，不就可以得到由这些属性组成的子结构了？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">PickByValueType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span> ValueType<span class="token operator">></span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span>  <span class="token constant">T</span><span class="token punctuation">,</span>  ExpectedPropKeys<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> ValueType<span class="token operator">></span><span class="token operator">></span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>PickByValueType<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span> foo<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> bar<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  foo<span class="token operator">:</span> <span class="token string">'linbudu'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>  PickByValueType<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span> foo<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> bar<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> baz<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">></span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  foo<span class="token operator">:</span> <span class="token string">'linbudu'</span><span class="token punctuation">,</span>  bar<span class="token operator">:</span> <span class="token number">599</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>OmitByValueType 也是类似的，我们只需要一个和 ExpectedPropKeys 作用相反的工具类型即可，比如来个 FilteredPropKeys，只需要调换条件类型语句结果的两端即可：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">FilteredPropKeys<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span> ValueType<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span>Key <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span>Key<span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">ValueType</span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> Key<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">OmitByValueType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span> ValueType<span class="token operator">></span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span>  <span class="token constant">T</span><span class="token punctuation">,</span>  FilteredPropKeys<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> ValueType<span class="token operator">></span><span class="token operator">></span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>OmitByValueType<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span> foo<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> bar<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  bar<span class="token operator">:</span> <span class="token number">599</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>  OmitByValueType<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span> foo<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> bar<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> baz<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">></span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  baz<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者，如果你想把 ExpectedPropKeys 和 FilteredPropKeys 合并在一起，其实也很简单，只是需要引入第三个泛型参数来控制返回结果：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Conditional<span class="token operator">&lt;</span>Value<span class="token punctuation">,</span> Condition<span class="token punctuation">,</span> Resolved<span class="token punctuation">,</span> Rejected<span class="token operator">></span></span> <span class="token operator">=</span> Value <span class="token keyword">extends</span> <span class="token class-name">Condition</span>  <span class="token operator">?</span> Resolved  <span class="token operator">:</span> Rejected<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">ValueTypeFilter<span class="token operator">&lt;</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span>  ValueType<span class="token punctuation">,</span>  Positive <span class="token keyword">extends</span> <span class="token builtin">boolean</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span>Key <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span>Key<span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">ValueType</span>    <span class="token operator">?</span> Conditional<span class="token operator">&lt;</span>Positive<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> Key<span class="token punctuation">,</span> <span class="token builtin">never</span><span class="token operator">></span>    <span class="token operator">:</span> Conditional<span class="token operator">&lt;</span>Positive<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token builtin">never</span><span class="token punctuation">,</span> Key<span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">PickByValueType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span> ValueType<span class="token operator">></span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span>  <span class="token constant">T</span><span class="token punctuation">,</span>  ValueTypeFilter<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> ValueType<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token operator">></span><span class="token operator">></span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">OmitByValueType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span> ValueType<span class="token operator">></span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span>  <span class="token constant">T</span><span class="token punctuation">,</span>  ValueTypeFilter<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> ValueType<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看起来好像很完美，但这里基于条件类型的比较是否让你想到了某个特殊情况？即在联合类型的情况下，<code>1 | 2 extends 1 | 2 | 3</code>（通过泛型参数传入） 会被视为是合法的，这是由于分布式条件类型的存在。而有时我们希望对联合类型的比较是全等的比较，还记得我们说怎么禁用分布式条件类型吗？让它不满足裸类型参数这一条即可：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Wrapped<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token builtin">boolean</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token string">'Y'</span> <span class="token operator">:</span> <span class="token string">'N'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这里我们也只需要简单进行改动即可：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">StrictConditional<span class="token operator">&lt;</span>Value<span class="token punctuation">,</span> Condition<span class="token punctuation">,</span> Resolved<span class="token punctuation">,</span> Rejected<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">[</span>Value<span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span>  Condition<span class="token punctuation">]</span>  <span class="token operator">?</span> Resolved  <span class="token operator">:</span> Rejected<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看起来好像没问题，但这里其实不够完美！比如下面这种情况：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Res1</span> <span class="token operator">=</span> StrictConditional<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">></span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当条件不再是一个简单的单体类型，而是一个联合类型时，我们使用数组的方式就产生问题了。因为 <code>Array&lt;1 | 2&gt; extends Array&lt;1 | 2 | 3&gt;</code> 就是合法的，<strong>第一个数组中的可能元素类型均被第二个数组的元素类型包含了，无论如何都是其子类型</strong>。</p><p>那么现在应该怎么办？其实只要反过来看，既然 <code>Array&lt;1 | 2&gt; extends Array&lt;1 | 2 | 3&gt;</code> 成立，那么 <code>Array&lt;1 | 2 | 3&gt; extends Array&lt;1 | 2&gt;</code> 肯定是不成立的，我们只要再加一个反方向的比较即可：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">StrictConditional<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">,</span> Resolved<span class="token punctuation">,</span> Rejected<span class="token punctuation">,</span> Fallback <span class="token operator">=</span> <span class="token builtin">never</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token constant">A</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token constant">B</span><span class="token punctuation">]</span>  <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token constant">B</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token constant">A</span><span class="token punctuation">]</span>    <span class="token operator">?</span> Resolved    <span class="token operator">:</span> Rejected  <span class="token operator">:</span> Fallback<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下 Value 和 Condition 的界限就比较模糊了，我们只是在比较两个类型是否严格相等，并没有值和表达式的概念了，因此就使用 A、B 来简称。</p><p>此时结果就符合预期了，需要联合类型完全一致：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Res1</span> <span class="token operator">=</span> StrictConditional<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">></span> <span class="token comment">// false</span><span class="token keyword">type</span> <span class="token class-name">Res2</span> <span class="token operator">=</span> StrictConditional<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">></span> <span class="token comment">// false</span><span class="token keyword">type</span> <span class="token class-name">Res3</span> <span class="token operator">=</span> StrictConditional<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">></span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>应用到 TypeFilter 中：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">StrictValueTypeFilter<span class="token operator">&lt;</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span>  ValueType<span class="token punctuation">,</span>  Positive <span class="token keyword">extends</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span>Key <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">?</span><span class="token operator">:</span> StrictConditional<span class="token operator">&lt;</span>    ValueType<span class="token punctuation">,</span>    <span class="token constant">T</span><span class="token punctuation">[</span>Key<span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token comment">// 为了避免嵌套太多工具类型，这里就不使用 Conditional 了</span>    Positive <span class="token keyword">extends</span> <span class="token class-name"><span class="token boolean">true</span></span> <span class="token operator">?</span> Key <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">,</span>    Positive <span class="token keyword">extends</span> <span class="token class-name"><span class="token boolean">true</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> Key<span class="token punctuation">,</span>    Positive <span class="token keyword">extends</span> <span class="token class-name"><span class="token boolean">true</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> Key  <span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">StrictPickByValueType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span> ValueType<span class="token operator">></span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span>  <span class="token constant">T</span><span class="token punctuation">,</span>  StrictValueTypeFilter<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> ValueType<span class="token operator">></span><span class="token operator">></span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>  StrictPickByValueType<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span> foo<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> bar<span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span><span class="token punctuation">;</span> baz<span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span><span class="token operator">></span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  bar<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">StrictOmitByValueType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span> ValueType<span class="token operator">></span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span>  <span class="token constant">T</span><span class="token punctuation">,</span>  StrictValueTypeFilter<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> ValueType<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">></span><span class="token operator">></span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>  StrictOmitByValueType<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span> foo<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> bar<span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span><span class="token punctuation">;</span> baz<span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span><span class="token operator">></span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  foo<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  baz<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，由于 StrictOmitByValueType 需要的是<strong>不符合类型的属性</strong>，因此这里 StrictConditional 的 Fallback 泛型参数也需要传入 Key （即第五个参数中的 <code>Positive extends true ? never : Key</code>），同时整体应当基于 Pick 来实现。</p><p>对于基于属性类型的结构工具类型就到这里，这一部分可能需要你先稍微放慢速度，好好理解一番。因为并不完全是我们此前了解到的知识，比如分布式条件类型中，我们并没有说到条件为联合类型时可能出现的问题。这是因为脱离实际使用去讲，很难建立并加深你对这一场景的印象，但我想现在你已经深刻记住它了。</p><p>接下来是基于结构的互斥工具类型。想象这样一个场景，假设我们有一个用于描述用户信息的对象结构，除了共有的一些基础结构以外，VIP 用户和普通用户、游客这三种类型的用户各自拥有一些独特的字段，如 vipExpires 代表 VIP 过期时间，仅属于 VIP 用户，promotionUsed 代表已领取过体验券，属于普通用户，而 refererType 代表跳转来源，属于游客。</p><p>先来看看如何声明一个接口，它要么拥有 vipExpires，要么拥有 promotionUsed 字段，而不能同时拥有这两个字段。你可能会首先想到使用联合类型？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">VIP</span></span> <span class="token punctuation">&#123;</span>  vipExpires<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">CommonUser</span> <span class="token punctuation">&#123;</span>  promotionUsed<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token operator">=</span> <span class="token constant">VIP</span> <span class="token operator">|</span> CommonUser<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很遗憾，这种方式并不会约束“不能同时拥有”这个条件：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> user1<span class="token operator">:</span> User <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  vipExpires<span class="token operator">:</span> <span class="token number">599</span><span class="token punctuation">,</span>  promotionUsed<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为了表示不能同时拥有，实际上我们应该使用 never 类型来标记一个属性。这里我们直接看完整的实现：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Without<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> Exclude<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token keyword">keyof</span> <span class="token constant">U</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">never</span> <span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name"><span class="token constant">XOR</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>Without<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span> <span class="token operator">&amp;</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>Without<span class="token operator">&lt;</span><span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">></span> <span class="token operator">&amp;</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token keyword">type</span> <span class="token class-name">XORUser</span> <span class="token operator">=</span> <span class="token constant">XOR</span><span class="token operator">&lt;</span><span class="token constant">VIP</span><span class="token punctuation">,</span> CommonUser<span class="token operator">></span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>XORUser<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  vipExpires<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>XORUser<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  promotionUsed<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 报错，至少需要一个</span><span class="token comment">// @ts-expect-error</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>XORUser<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 报错，不允许同时拥有</span><span class="token comment">// @ts-expect-error</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>XORUser<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  promotionUsed<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  vipExpires<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对 Without 做进一步展开可以看到，它其实就是将声明了一个不变的原属性+为 never 的其他属性的接口：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// &#123;</span><span class="token comment">//    vipExpires?: never;</span><span class="token comment">// &#125;</span><span class="token keyword">type</span> <span class="token class-name">Tmp1</span> <span class="token operator">=</span> Flatten<span class="token operator">&lt;</span>Without<span class="token operator">&lt;</span><span class="token constant">VIP</span><span class="token punctuation">,</span> CommonUser<span class="token operator">>></span><span class="token comment">// &#123;</span><span class="token comment">//    vipExpires?: never;</span><span class="token comment">//    promotionUsed: boolean;</span><span class="token comment">// &#125;</span><span class="token keyword">type</span> <span class="token class-name">Tmp2</span> <span class="token operator">=</span> Flatten<span class="token operator">&lt;</span>Tmp1 <span class="token operator">&amp;</span> CommonUser<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再通过联合类型的合并，这样一来 XORUser 就满足了“至少实现 VIP / CommonUser 这两个接口中的一个”，“不能同时实现 VIP / CommonUser ”这两个条件。如果加上游客类型实现三个互斥属性，也只需要额外嵌套一层：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Visitor</span> <span class="token punctuation">&#123;</span>  refererType<span class="token operator">:</span> RefererType<span class="token punctuation">&#125;</span><span class="token comment">// 联合类型会自动合并重复的部分</span><span class="token keyword">type</span> <span class="token class-name">XORUser</span> <span class="token operator">=</span> <span class="token constant">XOR</span><span class="token operator">&lt;</span><span class="token constant">VIP</span><span class="token punctuation">,</span> <span class="token constant">XOR</span><span class="token operator">&lt;</span>CommonUser<span class="token punctuation">,</span> Visitor<span class="token operator">>></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还可以使用互斥类型实现绑定效果，即要么同时拥有 A、B 属性，要么一个属性都没有：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">XORStruct</span> <span class="token operator">=</span> <span class="token constant">XOR</span><span class="token operator">&lt;</span>  <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>    foo<span class="token operator">:</span> <span class="token builtin">string</span>    bar<span class="token operator">:</span> <span class="token builtin">number</span>  <span class="token punctuation">&#125;</span><span class="token operator">></span><span class="token comment">// 没有 foo、bar</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>XORStruct<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 同时拥有 foo、bar</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>XORStruct<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  foo<span class="token operator">:</span> <span class="token string">'linbudu'</span><span class="token punctuation">,</span>  bar<span class="token operator">:</span> <span class="token number">599</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>互斥工具类型在很多实战场景下都有重要意义，它在联合类型的基础上添加了属性间的互斥逻辑，现在你可以让你的接口结构更加精确了！</p><h2 id="集合工具类型进阶"><a href="#集合工具类型进阶" class="headerlink" title="集合工具类型进阶"></a>集合工具类型进阶</h2><p>在集合工具类型中我们给到的进阶方向，其实就是从一维原始类型集合，扩展二维的对象类型，在对象类型之间进行交并补差集的运算，以及对同名属性的各种处理情况。</p><p>对于对象类型的交并补差集，我们仍然沿用“降级”的处理思路，把它简化为可以用基础工具类型处理的问题即可。在这里，对象类型的交并补差集基本上可以降维到对象属性名集合的交并补差集问题，比如交集就是两个对象属性名的交集，使用属性名的交集访问其中一个对象，就可以获得对象之间的交集结构（不考虑同名属性冲突下）。</p><p>复习一下前面的一维集合：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 并集</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Concurrence<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token operator">|</span> <span class="token constant">B</span><span class="token comment">// 交集</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Intersection<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">?</span> <span class="token constant">A</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token comment">// 差集</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Difference<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">A</span><span class="token comment">// 补集</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Complement<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span> <span class="token keyword">extends</span> <span class="token constant">A</span><span class="token operator">></span></span> <span class="token operator">=</span> Difference<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00425dd09153488ca22b08c2c94a27c4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>我们对应地实现对象属性名的版本：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 使用更精确的对象类型描述结构</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">PlainObjectType</span> <span class="token operator">=</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">></span><span class="token comment">// 属性名并集</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">ObjectKeysConcurrence<span class="token operator">&lt;</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> PlainObjectType<span class="token punctuation">,</span>  <span class="token constant">U</span> <span class="token keyword">extends</span> PlainObjectType<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">keyof</span> <span class="token constant">U</span><span class="token comment">// 属性名交集</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">ObjectKeysIntersection<span class="token operator">&lt;</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> PlainObjectType<span class="token punctuation">,</span>  <span class="token constant">U</span> <span class="token keyword">extends</span> PlainObjectType<span class="token operator">></span></span> <span class="token operator">=</span> Intersection<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token keyword">keyof</span> <span class="token constant">U</span><span class="token operator">></span><span class="token comment">// 属性名差集</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">ObjectKeysDifference<span class="token operator">&lt;</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> PlainObjectType<span class="token punctuation">,</span>  <span class="token constant">U</span> <span class="token keyword">extends</span> PlainObjectType<span class="token operator">></span></span> <span class="token operator">=</span> Difference<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token keyword">keyof</span> <span class="token constant">U</span><span class="token operator">></span><span class="token comment">// 属性名补集</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">ObjectKeysComplement<span class="token operator">&lt;</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token constant">U</span><span class="token punctuation">,</span>  <span class="token constant">U</span> <span class="token keyword">extends</span> PlainObjectType<span class="token operator">></span></span> <span class="token operator">=</span> Complement<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token keyword">keyof</span> <span class="token constant">U</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于交集、补集、差集，我们可以直接使用属性名的集合来实现对象层面的版本：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">ObjectIntersection<span class="token operator">&lt;</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> PlainObjectType<span class="token punctuation">,</span>  <span class="token constant">U</span> <span class="token keyword">extends</span> PlainObjectType<span class="token operator">></span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> ObjectKeysIntersection<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">>></span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">ObjectDifference<span class="token operator">&lt;</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> PlainObjectType<span class="token punctuation">,</span>  <span class="token constant">U</span> <span class="token keyword">extends</span> PlainObjectType<span class="token operator">></span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> ObjectKeysDifference<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">>></span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">ObjectComplement<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">U</span> <span class="token keyword">extends</span> PlainObjectType<span class="token operator">></span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span>  <span class="token constant">T</span><span class="token punctuation">,</span>  ObjectKeysComplement<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是在 ObjectKeysComplement 与 ObjectComplement 中，<code>T extends U</code> 意味着 T 是 U 的子类型，但在属性组成的集合类型中却相反，<strong>U 的属性联合类型是 T 的属性联合类型的子类型</strong>，因为既然 T 是 U 的子类型，那很显然 T 所拥有的的属性会更多嘛。</p><p>而对于并集，就不能简单使用属性名并集版本了，因为使用联合类型实现，我们并不能控制<strong>同名属性的优先级</strong>，比如我到底是保持原对象属性类型呢，还是使用新对象属性类型？</p><p>还记得我们在 MarkPropsAsOptional、PickByValueType 中使用的方式吗？将一个对象拆分成数个子结构，处理各个子结构，再将它们合并。那么对于合并两个对象的情况，其实就是两个对象各自特有的部分加上同名属性组成的部分。</p><p>对于 T、U 两个对象，假设以 U 的同名属性类型优先，思路会是这样的：</p><ul><li>T 比 U 多的部分：T 相对于 U 的差集，<code>ObjectDifference&lt;T, U&gt;</code></li><li>U 比 T 多的部分：U 相对于 T 的差集，<code>ObjectDifference&lt;U, T&gt;</code></li><li>T 与 U 的交集，由于 U 的优先级更高，在交集处理中将 U 作为原集合， T 作为后传入的集合，<code>ObjectIntersection&lt;U, T&gt;</code></li></ul><p>我们就得到了 Merge：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Merge<span class="token operator">&lt;</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> PlainObjectType<span class="token punctuation">,</span>  <span class="token constant">U</span> <span class="token keyword">extends</span> PlainObjectType  <span class="token comment">// T 比 U 多的部分，加上 T 与 U 交集的部分(类型不同则以 U 优先级更高，再加上 U 比 T 多的部分即可</span><span class="token operator">></span></span> <span class="token operator">=</span> ObjectDifference<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span> <span class="token operator">&amp;</span> ObjectIntersection<span class="token operator">&lt;</span><span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">></span> <span class="token operator">&amp;</span> ObjectDifference<span class="token operator">&lt;</span><span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要保证原对象优先级更高，那么只需要在交集处理中将 T 视为原集合，U 作为后传入的集合：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Assign<span class="token operator">&lt;</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> PlainObjectType<span class="token punctuation">,</span>  <span class="token constant">U</span> <span class="token keyword">extends</span> PlainObjectType  <span class="token comment">// T 比 U 多的部分，加上 T 与 U 交集的部分(类型不同则以 T 优先级更高，再加上 U 比 T 多的部分即可</span><span class="token operator">></span></span> <span class="token operator">=</span> ObjectDifference<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span> <span class="token operator">&amp;</span> ObjectIntersection<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span> <span class="token operator">&amp;</span> ObjectDifference<span class="token operator">&lt;</span><span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了简单粗暴地完全合并以外，我们还可以实现不完全的并集，即使用对象 U 的属性类型覆盖对象 T 中的同名属性类型，但<strong>不会将 U 独特的部分</strong>合并过来：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Override<span class="token operator">&lt;</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> PlainObjectType<span class="token punctuation">,</span>  <span class="token constant">U</span> <span class="token keyword">extends</span> PlainObjectType  <span class="token comment">// T 比 U 多的部分，加上 T 与 U 交集的部分(类型不同则以 U 优先级更高（逆并集）)</span><span class="token operator">></span></span> <span class="token operator">=</span> ObjectDifference<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span> <span class="token operator">&amp;</span> ObjectIntersection<span class="token operator">&lt;</span><span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，我们完成了从一维集合到二维集合的跨越。你也可以探索更多样的情况，比如两个对象各自独有部分组成的新集合（<strong>即从并集中剔除掉交集</strong>）就是一个很适合自己动手巩固印象的好例子。</p><h2 id="模式匹配工具类型进阶"><a href="#模式匹配工具类型进阶" class="headerlink" title="模式匹配工具类型进阶"></a>模式匹配工具类型进阶</h2><p>在内置工具类型一节中，我们对模式匹配工具类型的进阶方向其实只有深层嵌套这么一种，特殊位置的 infer 处理其实大部分时候也是通过深层嵌套实现，比如此前我们实现了提取函数的首个参数类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">FirstParameter<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> FunctionType<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span>  arg<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">P</span><span class="token punctuation">,</span>  <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">any</span>  <span class="token operator">?</span> <span class="token constant">P</span>  <span class="token operator">:</span> <span class="token builtin">never</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要提取最后一个参数类型则可以这样：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">FunctionType</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">any</span><span class="token keyword">type</span> <span class="token class-name">LastParameter<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> FunctionType<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">P</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">any</span>  <span class="token operator">?</span> <span class="token constant">P</span>  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">R</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">any</span>  <span class="token operator">?</span> <span class="token constant">R</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token keyword">infer</span> <span class="token constant">Q</span><span class="token punctuation">]</span>    <span class="token operator">?</span> <span class="token constant">Q</span>    <span class="token operator">:</span> <span class="token builtin">never</span>  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token keyword">type</span> <span class="token class-name">FuncFoo</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token keyword">type</span> <span class="token class-name">FuncBar</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token keyword">type</span> <span class="token class-name">FuncBaz</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> arg2<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token keyword">type</span> <span class="token class-name">FooLastParameter</span> <span class="token operator">=</span> LastParameter<span class="token operator">&lt;</span>FuncFoo<span class="token operator">></span> <span class="token comment">// number</span><span class="token keyword">type</span> <span class="token class-name">BarLastParameter</span> <span class="token operator">=</span> LastParameter<span class="token operator">&lt;</span>FuncBar<span class="token operator">></span> <span class="token comment">// string</span><span class="token keyword">type</span> <span class="token class-name">BazLastParameter</span> <span class="token operator">=</span> LastParameter<span class="token operator">&lt;</span>FuncBaz<span class="token operator">></span> <span class="token comment">// boolean</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这也是模式匹配中常用的一种方法，通过 infer 提取到某一个结构，然后再对这个结构进行 infer 提取。</p><p>我们在此前曾经讲到一个提取 Promise 内部值类型的工具类型 PromiseValue， TypeScript 内置工具类型中也存在这么一个作用的工具类型，并且它的实现要更为严谨：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Awaited<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">null</span></span> <span class="token operator">|</span> <span class="token keyword">undefined</span>  <span class="token operator">?</span> <span class="token constant">T</span>  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">object</span> <span class="token operator">&amp;</span> <span class="token punctuation">&#123;</span> <span class="token function">then</span><span class="token punctuation">(</span>onfulfilled<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">F</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">&#125;</span>  <span class="token operator">?</span> <span class="token constant">F</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">V</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">any</span>    <span class="token operator">?</span> Awaited<span class="token operator">&lt;</span><span class="token constant">V</span><span class="token operator">></span>    <span class="token operator">:</span> <span class="token builtin">never</span>  <span class="token operator">:</span> <span class="token constant">T</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先你会发现，在这里 Awaited 并非通过 <code>Promise&lt;infer V&gt;</code> 来提取函数类型，而是通过 <code>Promise.then</code> 方法提取，首先提取到 then 方法中的函数类型，再通过这个函数类型的首个参数来提取出实际的值。</p><p>更严谨地来说，PromiseValue 和 Awaited 并不应该放在一起比较，前者就只想提取 <code>Promise&lt;void&gt;</code> 这样结构的内部类型，后者则像在类型的层面执行了 <code>await Promise.then()</code> 之后的返回值类型。同样的，这里也用到了 infer 伴随结构转化的例子。</p><p>对于<strong>内置模式匹配工具类型的进阶</strong>我们暂时只进行到这里，在后续的漫谈篇中，我们会不再拘束于“内置”，而是会更新更多复杂的模式匹配工具类型。</p><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>这一节我们了解了属性修饰、结构、集合、模式匹配这四大类的工具类型进阶，也通过这些进阶类型了解到了常用的类型编程方式，如<strong>对一个对象结构拆分为多个子结构再分别处理</strong>，将<strong>复杂类型降维到基础类型再逐个击破</strong>，以及<strong>在嵌套的条件类型中基于 infer 多次修改类型结构</strong>来提取最终需要的类型。最重要的是，这些思路不仅仅会用在这一节的工具类型实现里，当你以后面对更复杂的场景需要从头写一个工具类型时，也完全可以使用，不会再无从下手了。</p><p>至此，我们就完成了对 TypeScript 基本类型能力的学习。一路走来甚是不易，我们用了 16 节，总计约 7w 字的内容，来完成对 TypeScript 核心类型能力的入门、进阶、归纳与实战。从基本的类型标注到内置类型的使用，从掌握类型工具到类型系统的深入探索，从工具类型入门到进阶再到整理出类型编程的 4 大范式（访问性修饰、结构、集合以及模式匹配）。</p><p>对于类型编程部分，我想带给你的最重要收获其实就是，<strong>你不会再畏惧眼花缭乱的类型编程了</strong>。正如始终贯穿这几节的核心理念，<strong>无论多复杂的类型编程，最终都可以拆分为数个基础的工具类型来实现</strong>，你需要锻炼的就是拆分的思路。</p><p>下一节我们还要继续接触类型。先别激动，接下来的类型要更好玩有趣一些，它是 TypeScript 在 4.1 版本引入的重磅特性——模板字符串类型，我们会用两节的内容带你完成相关学习。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="RequiredKeys、OptionalKeys"><a href="#RequiredKeys、OptionalKeys" class="headerlink" title="RequiredKeys、OptionalKeys"></a>RequiredKeys、OptionalKeys</h3><p>在属性修饰工具类型中我们只实现了 FunctionKeys，它的实现相对简单，因为只需要判断类型即可。那如果，我们要获取一个接口中所有可选或必选的属性呢？现在没法通过类型判断，要怎么去收集属性？</p><p>这一部分的实际意义不大，因此我特意放在扩展阅读里，下面的 MutableKeys、ImmutableKeys 也是如此。</p><p>首先是 RequiredKeys ，我们可以通过一个很巧妙的方式判断一个属性是否是必选的，先看一个例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Tmp1</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span> prop<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#125;</span> <span class="token operator">?</span> <span class="token string">'Y'</span> <span class="token operator">:</span> <span class="token string">'N'</span> <span class="token comment">// "N"</span><span class="token keyword">type</span> <span class="token class-name">Tmp2</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span> prop<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#125;</span> <span class="token operator">?</span> <span class="token string">'Y'</span> <span class="token operator">:</span> <span class="token string">'N'</span> <span class="token comment">// "Y"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在类型层级一节中我们已经了解，此时 TypeScript 会使用基于结构化类型的比较，也就意味着由于 <code>&#123; prop: number &#125;</code> 可以视为继承自 <code>&#123;&#125;</code> ，<code>&#123;&#125; extends &#123; prop: number &#125;</code> 是不满足条件的。但是，如果这里的 prop 是可选的，那就不一样了！由于 <code>&#123; prop?: number &#125;</code> 也可以是一个空的接口结构，那么 <code>&#123;&#125; extends &#123; prop?: number &#125;</code> 就可以认为是满足的。</p><p>因此，我们可以这么实现：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">RequiredKeys<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">extends</span> <span class="token class-name">Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">></span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>OptionalKeys 也是类似：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">OptionalKeys<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">extends</span> <span class="token class-name">Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">></span></span> <span class="token operator">?</span> <span class="token constant">K</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="MutableKeys、ImmutableKeys"><a href="#MutableKeys、ImmutableKeys" class="headerlink" title="MutableKeys、ImmutableKeys"></a>MutableKeys、ImmutableKeys</h3><p>MutableKeys 和 ImmutableKeys 则要更加复杂一些，因为 readonly 修饰符无法简单地通过结构化类型比较，我们需要一个能对只读这一特性进行判断的辅助工具类型，直接看例子再讲解：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Equal<span class="token operator">&lt;</span><span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token punctuation">,</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token builtin">never</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">X</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">extends</span> <span class="token operator">&lt;</span>  <span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">Y</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span>  <span class="token operator">?</span> <span class="token constant">A</span>  <span class="token operator">:</span> <span class="token constant">B</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，<code>&lt;T&gt;() =&gt; T extends X ? 1 : 2</code> 和 <code>&lt;T&gt;() =&gt; T extends Y ? 1 : 2</code> 这两个函数结构实际上起辅助作用，内部的条件类型并不会真的进行运算。我们实际上是借助这一辅助结构判断类型 X 与 Y 的全等性，这一全等性就包括了 readonly 修饰符与可选性等。</p><p>我们基于其实现 MutableKeys 和 ImmutableKeys：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">MutableKeys<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">?</span><span class="token operator">:</span> Equal<span class="token operator">&lt;</span>    <span class="token punctuation">&#123;</span> <span class="token punctuation">[</span><span class="token constant">Q</span> <span class="token keyword">in</span> <span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token operator">-</span><span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">Q</span> <span class="token keyword">in</span> <span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token constant">P</span><span class="token punctuation">,</span>    <span class="token builtin">never</span>  <span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>MutableKeys<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token keyword">readonly</span> b<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#125;</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token generic-function"><span class="token function">expectNotType</span><span class="token generic class-name"><span class="token operator">&lt;</span>MutableKeys<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token keyword">readonly</span> b<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#125;</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">ImmutableKeys<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">?</span><span class="token operator">:</span> Equal<span class="token operator">&lt;</span>    <span class="token punctuation">&#123;</span> <span class="token punctuation">[</span><span class="token constant">Q</span> <span class="token keyword">in</span> <span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token operator">-</span><span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">Q</span> <span class="token keyword">in</span> <span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token builtin">never</span><span class="token punctuation">,</span>    <span class="token constant">P</span>  <span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>ImmutableKeys<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token keyword">readonly</span> b<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#125;</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token generic-function"><span class="token function">expectNotType</span><span class="token generic class-name"><span class="token operator">&lt;</span>ImmutableKeys<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token keyword">readonly</span> b<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#125;</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 MutableKeys 中，我们传入本次映射的单个属性组成的接口结构，以及这一结构去除了 readonly 的版本，如果前后两个接口结构被判定为全等，那就说明这一次映射的属性不是只读的。在 ImmutableKeys 中也是，但我们调换了符合条件类型时的正反结果位置。</p><p>Equal 这个工具类型在很多情况下还有特殊的妙用，不妨再试试各种类型都扔进来比一比？</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>15.数类型：协变与逆变的比较</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/15.%E6%95%B0%E7%B1%BB%E5%9E%8B%EF%BC%9A%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98%E7%9A%84%E6%AF%94%E8%BE%83/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/15.%E6%95%B0%E7%B1%BB%E5%9E%8B%EF%BC%9A%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<p>在 <a href="https://juejin.cn/book/7086408430491172901/section/7100488161263878177">全面梳理类型系统的层级关系：从 Top Type 到 Bottom Type</a> 一节中，我们分析了 TypeScript 类型系统自下而上的层级，比较了原始类型、联合类型、对象类型、内置类型等的层级关系。但是，如果你使用过 TypeScript 很容易就会想到，我们好像漏了一点什么：<strong>函数类型有类型层级吗？</strong> 如果有，它的类型层级又是怎么样的？比如，下面这几个函数类型之间的兼容性如何？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">FooFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">string</span><span class="token keyword">type</span> <span class="token class-name">BarFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token string">'literal types'</span><span class="token keyword">type</span> <span class="token class-name">BazFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">number</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>没什么头绪对吧？这一节，我们就来对比函数类型的类型层级，以及隐藏在这一比较幕后的理论——<strong>协变与逆变</strong>。这一篇文章中的概念我曾在此前的掘金文章中分享过，但大部分读者表示内容过于晦涩难懂，因此在这一节中我会换更接地气的方式来讲解。首先，我们通过逐步推导比较函数的类型层级，引出协变与逆变的概念，然后了解在 TypeScript 的内部定义是如何使用协变与逆变的，以及如何通过额外的配置启用这一检查。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F12-covariance-and-contravariance">Covariance and Contravariance</a></p></blockquote><h2 id="如何比较函数的签名类型？"><a href="#如何比较函数的签名类型？" class="headerlink" title="如何比较函数的签名类型？"></a>如何比较函数的签名类型？</h2><p>首先要明确的是，我们不会使用函数类型去和其他类型（如对象类型）比较，因为这并没有意义，本文中只会对两个函数类型进行比较。</p><p>来看示例，给出三个具有层级关系的类，分别代表动物、狗、柯基。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span>  <span class="token function">asPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span>  <span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Corgi</span> <span class="token keyword">extends</span> <span class="token class-name">Dog</span> <span class="token punctuation">&#123;</span>  <span class="token function">cute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于一个接受 Dog 类型并返回 Dog 类型的函数，我们可以这样表示：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">DogFactory</span> <span class="token operator">=</span> <span class="token punctuation">(</span>args<span class="token operator">:</span> Dog<span class="token punctuation">)</span> <span class="token operator">=></span> Dog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在本文中，我们进一步将其简化为：<code>Dog -&gt; Dog</code> 的表达形式。</p><p>对于函数类型比较，实际上我们要比较的即是参数类型与返回值类型（也只能是这俩位置的类型）。对于 Animal、Dog、Corgi 这三个类，如果将它们分别可重复地放置在参数类型与返回值类型处（相当于排列组合），就可以得到以下这些函数签名类型：</p><blockquote><p>这里的结果中不包括 <code>Dog -&gt; Dog</code>，因为我们要用它作为基础来<strong>被</strong>比较</p></blockquote><ul><li><code>Animal -&gt; Animal</code></li><li><code>Animal -&gt; Dog</code></li><li><code>Animal -&gt; Corgi</code></li><li><code>Dog -&gt; Dog</code></li><li><code>Dog -&gt; Animal</code></li><li><code>Dog -&gt; Corgi</code></li><li><code>Corgi -&gt; Animal</code></li><li><code>Corgi -&gt; Dog</code></li><li><code>Corgi -&gt; Corgi</code></li></ul><p>直接比较完整的函数类型并不符合我们的思维直觉，因此我们需要引入一个辅助函数：它接收一个 <code>Dog -&gt; Dog</code> 类型的参数：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">transformDogAndBark</span><span class="token punctuation">(</span>dogFactory<span class="token operator">:</span> DogFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> dog <span class="token operator">=</span> <span class="token function">dogFactory</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  dog<span class="token punctuation">.</span><span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对于函数参数，实际上类似于我们在类型系统层级时讲到的，<strong>如果一个值能够被赋值给某个类型的变量，那么可以认为这个值的类型为此变量类型的子类型</strong>。</p><p>如一个简单接受 Dog 类型参数的函数：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">makeDogBark</span><span class="token punctuation">(</span>dog<span class="token operator">:</span> Dog<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  dog<span class="token punctuation">.</span><span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它在调用时只可能接受 Dog 类型或 Dog 类型的子类型，而不能接受 Dog 类型的父类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 没问题</span><span class="token function">makeDogBark</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Corgi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 不行</span><span class="token function">makeDogBark</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>相对严谨地说，这是因为派生类（即子类）会保留基类的属性与方法，因此说其与基类兼容，但基类并不能未卜先知的拥有子类的方法。相对欢脱地说，因为我们要让这只狗汪汪两声，柯基、柴犬、德牧都会，但如果你传个牛进来，这我就很难办了啊。</p><blockquote><p><strong>里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能，子类型（subtype）必须能够替换掉他们的基类型（base type）。</strong></p></blockquote><p>回到这个函数，这个函数会实例化一只狗狗，并传入 Factory（就像宠物美容），然后让它叫唤两声。实际上，这个函数同时约束了此类型的参数与返回值。首先，我只会传入一只正常的狗狗，但它不一定是什么品种。其次，你返回的必须也是一只狗狗，我并不在意它是什么品种。</p><p>对于这两条约束依次进行检查：</p><ul><li>对于 <code>Animal/Dog/Corgi -&gt; Animal</code> 类型，无论它的参数类型是什么，它的返回值类型都是不满足条件的。因为它返回的不一定是合法的狗狗，即我们说它不是 <code>Dog -&gt; Dog</code> 的子类型。</li><li>对于 <code>Corgi -&gt; Corgi</code> 与 <code>Corgi -&gt; Dog</code>，其返回值满足了条件，但是参数类型又不满足了。这两个类型需要接受 Corgi 类型，可能内部需要它腿短的这个特性。但我们可没说一定会传入柯基，如果我们传个德牧，程序可能就崩溃了。</li><li>对于 <code>Dog -&gt; Corgi</code>、<code>Animal -&gt; Corgi</code>、<code>Animal -&gt; Dog</code>，首先它们的参数类型正确的满足了约束，能接受一只狗狗。其次，它们的返回值类型也一定会能汪汪汪。</li></ul><p>而实际上，如果我们去掉了包含 <code>Dog</code> 类型的例子，会发现只剩下 <code>Animal -&gt; Corgi</code> 了，也即是说，<code>(Animal → Corgi) ≼ (Dog → Dog)</code> 成立（<code>A ≼ B</code> 意为 A 为 B 的子类型）。</p><p>观察以上排除方式的结论：</p><ul><li>参数类型<strong>允许</strong>为 Dog 的父类型，<strong>不允许</strong>为 Dog 的子类型。</li><li>返回值类型<strong>允许</strong>为 Dog 的子类型，<strong>不允许</strong>为 Dog 的父类型。</li></ul><p>你是否 get 到了什么？这里用来比较的两个函数类型，其实就是把具有父子关系的类型放置在参数位置以及返回值位置上，<strong>最终函数类型的关系直接取决于类型的父子关系。</strong> “取决于”也就意味着，其中有规律可循。那么这个时候，我们就可以引入协变与逆变的概念了。</p><h2 id="协变与逆变"><a href="#协变与逆变" class="headerlink" title="协变与逆变"></a>协变与逆变</h2><p>我们上一节得到的结论是，考虑 <code>Corgi ≼ Dog ≼ Animal</code>，当有函数类型 <code>Dog -&gt; Dog</code>，仅有 <code>(Animal → Corgi) ≼ (Dog → Dog)</code> 成立（即能被视作此函数的子类型，）。这里的参数类型与返回值类型实际上可以各自独立出来看：</p><p>考虑 <code>Corgi ≼ Dog</code>，假设我们对其进行返回值类型的函数签名类型包装，则有 <code>(T → Corgi) ≼ (T → Dog)</code>，也即是说，在我需要狗狗的地方，柯基都是可用的。即不考虑参数类型的情况，在包装为函数签名的返回值类型后，其子类型层级关系保持一致。</p><p>考虑 <code>Dog ≼ Animal</code>，如果换成参数类型的函数签名类型包装，则有 <code>(Animal -&gt; T) ≼ (Dog -&gt; T)</code>，也即是说，在我需要条件满足是动物时，狗狗都是可用的。即不考虑返回值类型的情况，在包装为函数签名的参数类型后，其子类型层级关系发生了逆转。</p><p>实际上，这就是 TypeScript 中的<strong>协变（</strong> <strong><em>covariance</em></strong> <strong>）</strong> 与<strong>逆变（</strong> <strong><em>contravariance</em></strong> <strong>）</strong> 在函数签名类型中的表现形式。这两个单词最初来自于几何学领域中：<strong>随着某一个量的变化，随之变化一致的即称为协变，而变化相反的即称为逆变。</strong></p><p>用 TypeScript 的思路进行转换，即如果有 <code>A ≼ B</code> ，协变意味着 <code>Wrapper&lt;A&gt; ≼ Wrapper&lt;B&gt;</code>，而逆变意味着 <code>Wrapper&lt;B&gt; ≼ Wrapper&lt;A&gt;</code>。</p><p>而在这里的示例中，<strong>变化（Wrapper）即指从单个类型到函数类型的包装过程</strong>，我们可以使用工具类型来实现独立的包装类型（独立指对参数类型与返回值类型）：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">AsFuncArgType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token keyword">type</span> <span class="token class-name">AsFuncReturnType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">T</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再使用这两个包装类型演示我们上面的例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 1 成立：(T -> Corgi) ≼ (T -> Dog)</span><span class="token keyword">type</span> <span class="token class-name">CheckReturnType</span> <span class="token operator">=</span> AsFuncReturnType<span class="token operator">&lt;</span>Corgi<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AsFuncReturnType<span class="token operator">&lt;</span>Dog<span class="token operator">></span></span>  <span class="token operator">?</span> <span class="token number">1</span>  <span class="token operator">:</span> <span class="token number">2</span><span class="token comment">// 2 不成立：(Dog -> T) ≼ (Animal -> T)</span><span class="token keyword">type</span> <span class="token class-name">CheckArgType</span> <span class="token operator">=</span> AsFuncArgType<span class="token operator">&lt;</span>Dog<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AsFuncArgType<span class="token operator">&lt;</span>Animal<span class="token operator">></span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进行一个总结：<strong>函数类型的参数类型使用子类型逆变的方式确定是否成立，而返回值类型使用子类型协变的方式确定</strong>。</p><p>学习了函数类型的比较以及协变逆变的知识以后，你已经了解了如何通过“公式”来确定函数类型之间的兼容性关系，但实际上，基于协变逆变地检查并不是始终启用的（毕竟 TypeScript 在严格检查全关与全开的情况下，简直像是两门语言），我们需要通过配置来开启。</p><h2 id="TSConfig-中的-StrictFunctionTypes"><a href="#TSConfig-中的-StrictFunctionTypes" class="headerlink" title="TSConfig 中的 StrictFunctionTypes"></a>TSConfig 中的 StrictFunctionTypes</h2><p>如果你曾经翻过 tsconfig 配置，你可能会注意到 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.typescriptlang.org%2Ftsconfig%23strictFunctionTypes">strictFunctionTypes</a> 这一项配置，但它在文档中的描述其实相对简略了些：<strong>在比较两个函数类型是否兼容时，将对函数参数进行更严格的检查</strong>（<em>When enabled, this flag causes functions parameters to be checked more correctly</em>），而实际上，这里的更严格指的即是 <strong>对函数参数类型启用逆变检查</strong>，很自然的我们会产生一些疑惑：</p><ul><li>如果启用了这个配置才是逆变检查，那么原来是什么样的？</li><li>在实际场景中的逆变检查又是什么样的？</li></ul><p>还是以我们的三个类为例，首先是一个函数以及两个函数类型签名：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>dog<span class="token operator">:</span> Dog<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  dog<span class="token punctuation">.</span><span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">CorgiFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> Corgi<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token keyword">type</span> <span class="token class-name">AnimalFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> Animal<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们通过赋值的方式来实现对函数类型的比较：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> func1<span class="token operator">:</span> CorgiFunc <span class="token operator">=</span> fn<span class="token keyword">const</span> func2<span class="token operator">:</span> AnimalFunc <span class="token operator">=</span> fn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>还记得吗？如果赋值成立，说明 fn 的类型是 <code>CorgiFunc</code> / <code>AnimalFunc</code> 的子类型</p></blockquote><p>这两个赋值实际上等价于：</p><ul><li><code>(Dog -&gt; T) ≼ (Corgi -&gt; T)</code></li><li><code>(Dog -&gt; T) ≼ (Animal -&gt; T)</code></li></ul><p>结合上面所学，我们很明显能够发现第二种应当是不成立的。但在禁用了 <code>strictFunctionTypes</code> 的情况下，TypeScript 并不会抛出错误。这是因为，在默认情况下，对函数参数的检查采用 <strong>双变（</strong> <strong><em>bivariant</em></strong> <strong>）</strong> ，<strong>即逆变与协变都被认为是可接受的</strong>。</p><p>在 TypeScript ESLint 中，有这么一条规则：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftypescript-eslint%2Ftypescript-eslint%2Fblob%2Fmain%2Fpackages%2Feslint-plugin%2Fdocs%2Frules%2Fmethod-signature-style.md">method-signature-style</a>，它的意图是约束在接口中声明方法时，需要使用 <strong>property</strong> 而非 <strong>method</strong> 形式：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// method 声明</span><span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token punctuation">&#123;</span>  <span class="token function">func</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token comment">// property 声明</span><span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">func</span><span class="token operator">:</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进行如此约束的原因即，对于 property 声明，才能在开启严格函数类型检查的情况下享受到<strong>基于逆变的参数类型检查</strong>。</p><p>对于 method 声明（以及构造函数声明），其无法享受到这一更严格的检查的原因则是对于如 Array 这样的内置定义，我们希望它的函数方法就是以协变的方式进行检查，举个栗子，<code>Dog[] ≼ Animal[]</code> 是否成立？</p><ul><li>我们并不能简单的比较 Dog 与 Animal，而是要将它们视为两个完整的类型比较，即 <code>Dog[]</code> 的每一个成员（属性、方法）是否都能对应的赋值给 <code>Animal[]</code> ？</li><li><code>Dog[].push ≼ Animal[].push</code> 是否成立？</li><li>由 push 方法的类型签名进一步推导，<code>Dog -&gt; void ≼ Animal -&gt; void</code> 是否成立？</li><li><code>Dog -&gt; void ≼ Animal -&gt; void</code>在逆变的情况下意味着 <code>Animal ≼ Dog</code>，而这很明显是不对的！</li><li>简单来说， <code>Dog -&gt; void ≼ Animal -&gt; void</code> 是否成立本身就为 <code>Dog[] ≼ Animal[]</code> 提供了一个前提答案。</li></ul><p>因此，如果 TypeScript 在此时仍然强制使用参数逆变的规则进行检查，那么 <code>Dog[] ≼ Animal[]</code> 就无法成立，也就意味着无法将 Dog 赋值给 Animal，这不就前后矛盾了吗？所以在大部分情况下，我们确实希望方法参数类型的检查可以是<strong>双变</strong>的，这也是为什么它们的声明中类型结构使用 method 方式来声明：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name"><span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span>  <span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>items<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节，我们学习了 TypeScript 函数类型的兼容性比较，这应该带给了你一些新的启发：原来不只是原始类型、联合类型、对象类型等可以比较，函数类型之间同样是能够比较的。而对我们开头提出的，<strong>如何对两个函数类型进行兼容性比较</strong>这一问题，我想你也有了答案：比较它们的参数类型是否是反向的父子类型关系，返回值是否是正向的父子类型关系。</p><p>如果用本章学到的新知识来说，其实就是判断<strong>参数类型是否遵循类型逆变，返回值类型是否遵循类型协变</strong>。我们可以通过 TypeScript ESLint 的规则以及 <code>strictFunctionTypes</code> 配置，来为 interface 内的函数声明启用严格的检查模式。如果你的项目内已经配置了 TypeScript ESLint，不妨添加上 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftypescript-eslint%2Ftypescript-eslint%2Fblob%2Fmain%2Fpackages%2Feslint-plugin%2Fdocs%2Frules%2Fmethod-signature-style.md">method-signature-style</a> 这条规则来让你的代码质量更上一层楼。</p><p>除了对自定义函数类型地比较，我们也了解了对于部分 TypeScript 内置的方法，会通过显式的 method 声明方式来确保在调用时，对参数类型检查采用<strong>双变</strong>而非<strong>逆变。</strong></p><p>到这里，你已经了解了 TypeScript 类型系统中绝大部分的知识，我想在未来你再遇到奇怪的类型报错时，应该再也不会憋着气打开 StackOverflow 搜索，而是微微一笑胸有成竹地轻松解决，所凭借的自然就是我们对类型系统的深刻掌握。</p><p>类型工具、类型系统、类型编程这三辆马车我们已经解决了俩，在下一节，我们就将开始进入类型编程的世界里，此前我们所学的所有类型工具与类型系统知识将轮番上阵接受考验，而你也将从看见复杂工具类型就头疼，变成看见类型就两眼放光的 TypeScript 高高手。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="联合类型与兄弟类型下的比较"><a href="#联合类型与兄弟类型下的比较" class="headerlink" title="联合类型与兄弟类型下的比较"></a>联合类型与兄弟类型下的比较</h3><p>在上面我们只关注了显式的父子类型关系，实际上在类型层级中还有隐式的父子类型关系（联合类型）以及兄弟类型（同一基类的两个派生类）。对于隐式的父子类型其可以仍然沿用显式的父子类型协变与逆变判断，但对于兄弟类型，比如 Dog 与 Cat，需要注意的是它们根本就<strong>不满足逆变与协变的发生条件（父子类型）</strong>，因此 <code>(Cat -&gt; void) ≼ (Dog -&gt; void)</code> （或者反过来）无论在严格检查与默认情况下均不成立。</p><h3 id="非函数签名包装类型的变换"><a href="#非函数签名包装类型的变换" class="headerlink" title="非函数签名包装类型的变换"></a>非函数签名包装类型的变换</h3><p>我们在最开始一直以函数体作为包装类型来作为协变与逆变的转变前提，后面虽然提到了使用数组的作为包装类型（<code>Dog[]</code>）的，但只是一笔带过，重点还是在函数体方面。现在，如果我们就是就是要考虑类似数组这种包装类型呢？比如直接一个简单的笼子 Cage ？</p><p>先不考虑 Cage 内部的实现，只知道它同时只能放一个物种的动物，<code>Cage&lt;Dog&gt;</code> 能被作为 <code>Cage&lt;Animal&gt;</code> 的子类型吗？对于这一类型的比较，我们可以直接用实际场景来代入：</p><ul><li>假设我需要一笼动物，但并不会对它们进行除了读以外的操作，那么你给我一笼狗我也是没问题的，但你不能给我一笼植物。也就意味着，此时 List 是 readonly 的，而 <code>Cage&lt;Dog&gt; ≼ Cage&lt;Animal&gt;</code> 成立。<strong>即在不可变的 Wrapper 中，我们允许其遵循协变。</strong></li><li>假设我需要一笼动物，并且会在其中新增其他物种，比如兔子啊王八，这个时候你给我一笼兔子就不行了，因为这个笼子只能放狗，放兔子进行可能会变异（？）。也就意味着，此时 List 是 writable 的，而 <code>Cage&lt;Dog&gt;</code> <code>Cage&lt;Rabit&gt;</code> <code>Cage&lt;Turtle&gt;</code> 彼此之间是互斥的，我们称为 <strong>不变（*invariant*）</strong>，用来放狗的笼子绝不能用来放兔子，即无法进行分配。</li><li>如果我们再修改下规则，现在一个笼子可以放任意物种的动物，狗和兔子可以放一个笼子里，这个时候任意的笼子都可以放任意的物种，放狗的可以放兔子，放兔子的也可以放狗，即可以互相分配，我们称之为<strong>双变（*Bivariant*）</strong>。</li></ul><p>也就是说，包装类型的表现与我们实际需要的效果是紧密关联的。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>18.基础类型新成员：模板字符串类型入门</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/18.%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E6%96%B0%E6%88%90%E5%91%98%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%85%A5%E9%97%A8/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/18.%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E6%96%B0%E6%88%90%E5%91%98%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>上一节，我们对内置工具类型的进阶方向进行了实现，它们中的部分工具类型确实相对烧脑和难以理解。这一节，我们稍作驻足，放慢节奏，来学习 TypeScript 的一个特殊存在：<strong>模板字符串类型</strong>。</p><p>此前我们已经学习了泛型相关的概念，知道它的表现就像 JavaScript 中的函数参数一样，接受一组参数，处理，然后返回一个新的值。而模板字符串类型，其实也完全可以映射到 JavaScript 中的概念——模板字符串。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F15-template-string-type">Template String Types</a></p></blockquote><h2 id="模板字符串类型的基础使用"><a href="#模板字符串类型的基础使用" class="headerlink" title="模板字符串类型的基础使用"></a>模板字符串类型的基础使用</h2><p>我们来看一个最简单的使用例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">World</span> <span class="token operator">=</span> <span class="token string">'World'</span><span class="token comment">// "Hello World"</span><span class="token keyword">type</span> <span class="token class-name">Greeting</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>World<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 Greeting 就是一个模板字符串类型，它内部通过与 JavaScript 中模板字符串相同的语法（<code>$&#123;&#125;</code>），使用了另一个类型别名 World，其最终的类型就是<strong>将两个字符串类型值组装在一起返回</strong>。</p><p>除了使用确定的类型别名以外，模板字符串类型当然也支持通过泛型参数传入。需要注意的是，并不是所有值都能被作为模板插槽：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Greet<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token operator">|</span> bigint<span class="token operator">></span></span> <span class="token operator">=</span>  <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token constant">T</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token keyword">type</span> <span class="token class-name">Greet1</span> <span class="token operator">=</span> Greet<span class="token operator">&lt;</span><span class="token string">'linbudu'</span><span class="token operator">></span> <span class="token comment">// "Hello linbudu"</span><span class="token keyword">type</span> <span class="token class-name">Greet2</span> <span class="token operator">=</span> Greet<span class="token operator">&lt;</span><span class="token number">599</span><span class="token operator">></span> <span class="token comment">// "Hello 599"</span><span class="token keyword">type</span> <span class="token class-name">Greet3</span> <span class="token operator">=</span> Greet<span class="token operator">&lt;</span><span class="token boolean">true</span><span class="token operator">></span> <span class="token comment">// "Hello true"</span><span class="token keyword">type</span> <span class="token class-name">Greet4</span> <span class="token operator">=</span> Greet<span class="token operator">&lt;</span><span class="token keyword">null</span><span class="token operator">></span> <span class="token comment">// "Hello null"</span><span class="token keyword">type</span> <span class="token class-name">Greet5</span> <span class="token operator">=</span> Greet<span class="token operator">&lt;</span><span class="token keyword">undefined</span><span class="token operator">></span> <span class="token comment">// "Hello undefined"</span><span class="token keyword">type</span> <span class="token class-name">Greet6</span> <span class="token operator">=</span> Greet<span class="token operator">&lt;</span><span class="token number">0x1fffffffffffff</span><span class="token operator">></span> <span class="token comment">// "Hello 9007199254740991"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目前有效的类型只有 <code>string | number | boolean | null | undefined | bigint</code> 这几个。正如上面的例子所示，这些类型在最终的字符串结果中都会被转换为字符串字面量类型，即使是 null 与 undefined。</p><p>当然，你也可以直接为插槽传入一个类型而非类型别名：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Greeting</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token builtin">string</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这种情况下，Greeting 类型并不会变成 <code>Hello string</code>，而是保持原样。这也意味着它并没有实际意义，此时就是一个无法改变的模板字符串类型，但所有 <code>Hello</code>开头的字面量类型都会被视为 <code>Hello $&#123;string&#125;</code> 的子类型，如 <code>Hello Linbudu</code>、<code>Hello TypeScript</code> 。</p><p>很明显，模板字符串类型的主要目的即是增强字符串字面量类型的灵活性，进一步增强类型和逻辑代码的关联。通过模板字符串类型你可以这样声明你的版本号：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Version</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">.</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">.</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token keyword">const</span> v1<span class="token operator">:</span> Version <span class="token operator">=</span> <span class="token string">'1.1.0'</span><span class="token comment">// X 类型 "1.0" 不能赋值给类型 `$&#123;number&#125;.$&#123;number&#125;.$&#123;number&#125;`</span><span class="token keyword">const</span> v2<span class="token operator">:</span> Version <span class="token operator">=</span> <span class="token string">'1.0'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而在需要声明大量存在关联的字符串字面量类型时，模板字符串类型也能在减少代码的同时获得更好的类型保障。举例来说，当我们需要声明以下字符串类型时：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">SKU</span></span> <span class="token operator">=</span>  <span class="token operator">|</span> <span class="token string">'iphone-16G-official'</span>  <span class="token operator">|</span> <span class="token string">'xiaomi-16G-official'</span>  <span class="token operator">|</span> <span class="token string">'honor-16G-official'</span>  <span class="token operator">|</span> <span class="token string">'iphone-16G-second-hand'</span>  <span class="token operator">|</span> <span class="token string">'xiaomi-16G-second-hand'</span>  <span class="token operator">|</span> <span class="token string">'honor-16G-second-hand'</span>  <span class="token operator">|</span> <span class="token string">'iphone-64G-official'</span>  <span class="token operator">|</span> <span class="token string">'xiaomi-64G-official'</span>  <span class="token operator">|</span> <span class="token string">'honor-64G-official'</span>  <span class="token operator">|</span> <span class="token string">'iphone-64G-second-hand'</span>  <span class="token operator">|</span> <span class="token string">'xiaomi-64G-second-hand'</span>  <span class="token operator">|</span> <span class="token string">'honor-64G-second-hand'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>随着商品、内存数、货品类型的增加，我们可能需要成几何倍地新增。但如果使用模板字符串类型，我们可以利用其<strong>自动分发的特性</strong>来实现简便而又严谨的声明：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Brand</span> <span class="token operator">=</span> <span class="token string">'iphone'</span> <span class="token operator">|</span> <span class="token string">'xiaomi'</span> <span class="token operator">|</span> <span class="token string">'honor'</span><span class="token keyword">type</span> <span class="token class-name">Memory</span> <span class="token operator">=</span> <span class="token string">'16G'</span> <span class="token operator">|</span> <span class="token string">'64G'</span><span class="token keyword">type</span> <span class="token class-name">ItemType</span> <span class="token operator">=</span> <span class="token string">'official'</span> <span class="token operator">|</span> <span class="token string">'second-hand'</span><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">SKU</span></span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Brand<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Memory<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>ItemType<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在插槽中传入联合类型，然后你就会发现，所有的联合类型排列组合都已经自动组合完毕了：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edbbe4aa3e4d475582c0cd15d68ce8f9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><blockquote><p>你可能会想，如果某一种组合并不存在，就像 <code>iphone-32G</code> 系列？我们在内置工具类型环节中提到了作为类型编程范式之一的集合工具类型，使用差集就可以解决这里的问题，比如我们可以只是<strong>剔除数个确定商品集合</strong>，也可以<strong>再利用模板字符串类型的排列组合能力生成要剔除的集合</strong>。</p></blockquote><p>通过这种方式，我们不仅不需要再手动声明一大堆工具类型，同时也获得了逻辑层面的保障：它会忠实地将<strong>所有插槽中的联合类型与剩余的字符串部分进行依次的排列组合</strong>。</p><p>除了直接在插槽中传递联合类型，通过泛型传入联合类型时同样会有分发过程：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">SizeRecord<span class="token operator">&lt;</span>Size <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Size<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">-Record</span><span class="token template-punctuation string">`</span></span><span class="token keyword">type</span> <span class="token class-name">Size</span> <span class="token operator">=</span> <span class="token string">'Small'</span> <span class="token operator">|</span> <span class="token string">'Middle'</span> <span class="token operator">|</span> <span class="token string">'Large'</span><span class="token comment">// "Small-Record" | "Middle-Record" | "Huge-Record"</span><span class="token keyword">type</span> <span class="token class-name">UnionSizeRecord</span> <span class="token operator">=</span> SizeRecord<span class="token operator">&lt;</span>Size<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模板字符串类型和字符串字面量类型实在太过相似，我们很容易想到它和字符串类型之间的类型兼容性是怎样的。</p><h3 id="模板字符串类型的类型表现"><a href="#模板字符串类型的类型表现" class="headerlink" title="模板字符串类型的类型表现"></a>模板字符串类型的类型表现</h3><p>实际上，由于模板字符串类型最终的产物还是字符串字面量类型，因此只要插槽位置的类型匹配，字符串字面量类型就可以被认为是模板字符串类型的子类型，比如我们上面的版本号：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">let</span> v1<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">.</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">.</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token keyword">declare</span> <span class="token keyword">let</span> v2<span class="token operator">:</span> <span class="token string">'1.2.4'</span>v1 <span class="token operator">=</span> v2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果反过来，<code>v2 = v1</code> 很显然是不成立的，因为 v1 还包含了 <code>100.0.0</code> 等等情况。同样的，模板字符串类型和模板字符串也拥有着紧密的关联：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> greet <span class="token operator">=</span> <span class="token punctuation">(</span>to<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token builtin">string</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>to<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个例子进一步体现了类型与值的紧密关联，通过模板字符串类型，现在我们能够进行更精确地类型描述了。而作为基础类型能力，模板字符串类型和其他类型工具也有着奇妙的组合作用，比如索引类型和映射类型。</p><h2 id="结合索引类型与映射类型"><a href="#结合索引类型与映射类型" class="headerlink" title="结合索引类型与映射类型"></a>结合索引类型与映射类型</h2><p>说到模板字符串插槽中传入联合类型的自动分发特性时，你可能会想到我们此前接触的一个能够生成联合类型的工具：索引类型查询操作符 keyof。基于 <strong>keyof + 模板字符串类型</strong>，我们可以基于已有的对象类型来实现精确到字面量的类型推导：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  age<span class="token operator">:</span> <span class="token builtin">number</span>  job<span class="token operator">:</span> Job<span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">ChangeListener</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  on<span class="token operator">:</span> <span class="token punctuation">(</span>change<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">keyof</span> Foo<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">Changed</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">&#125;</span><span class="token keyword">declare</span> <span class="token keyword">let</span> listener<span class="token operator">:</span> ChangeListener<span class="token comment">// 提示并约束为 "nameChanged" | "ageChanged" | "jobChanged"</span>listener<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在需要基于已有的对象类型进行字面量层面的变更时，我们现在能够放心地将这部分类型约束也交给模板字符串类型了。而除了索引类型，模板字符串类型也和映射类型有着奇妙的化学反应。</p><p>为了与映射类型实现更好的协作，TS 在引入模板字符串类型时支持了一个叫做 <strong>重映射（*Remapping*）</strong> 的新语法，基于模板字符串类型与重映射，我们可以实现一个此前无法想象的新功能：<strong>在映射键名时基于原键名做修改</strong>。</p><p>我们可以使用映射类型很容易复制一个接口：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Copy<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然而，如果我们想要在复制时小小的修改下键名要怎么做？比如从 <code>name</code> 到 <code>modified_name</code> ？修改键值类型我们都很熟练了，但要修改键名，我们就需要本节的新朋友搭把手才可以。</p><p>我们直接看如何基于重映射来修改键名：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">CopyWithRename<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token keyword">as</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">modified_</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token builtin">string</span> <span class="token operator">&amp;</span> <span class="token constant">K</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token comment">// &#123;</span><span class="token comment">//   modified_name: string;</span><span class="token comment">//   modified_age: number;</span><span class="token comment">// &#125;</span><span class="token keyword">type</span> <span class="token class-name">CopiedFoo</span> <span class="token operator">=</span> CopyWithRename<span class="token operator">&lt;</span>Foo<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们其实就是通过 <code>as</code> 语法，将映射的键名作为变量，映射到一个新的字符串类型。需要注意的是，由于对象的合法键名类型包括了 symbol，而模板字符串类型插槽中并不支持 symbol 类型。因此我们使用 <code>string &amp; K</code> 来确保了最终交由模板插槽的值，一定会是合法的 string 类型。</p><p>我们也可以通过伪代码来帮助理解：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> Copied <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token constant">K</span> <span class="token keyword">in</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> Key <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">modified_</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token constant">K</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  Copied<span class="token punctuation">[</span>Key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而重映射并不是模板字符串类型的唯一伴生伙伴，为了迎接这位新成员，TS 还隆重地为它准备了一些特殊的工具类型，以此让它能够快速和各位前辈大哥平起平坐。</p><h2 id="专用工具类型"><a href="#专用工具类型" class="headerlink" title="专用工具类型"></a>专用工具类型</h2><p>这些工具类型专用于字符串字面量类型，包括 <strong>Uppercase</strong>、<strong>Lowercase</strong>、<strong>Capitalize</strong> 与 <strong>Uncapitalize</strong>，看名字就能知道它们的作用：字符串大写、字符串小写、首字母大写与首字母小写：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Heavy<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Uppercase<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token keyword">type</span> <span class="token class-name">Respect<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Capitalize<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token keyword">type</span> <span class="token class-name">HeavyName</span> <span class="token operator">=</span> Heavy<span class="token operator">&lt;</span><span class="token string">'linbudu'</span><span class="token operator">></span> <span class="token comment">// "LINBUDU"</span><span class="token keyword">type</span> <span class="token class-name">RespectName</span> <span class="token operator">=</span> Respect<span class="token operator">&lt;</span><span class="token string">'linbudu'</span><span class="token operator">></span> <span class="token comment">// "Linbudu"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的重映射部分，我们成功将键名从 <code>name</code> 修改成了 <code>modified_name</code> 的形式，如果要修改成我们更习惯的小驼峰形式呢？此时我们就可以使用上 Capitalize 工具类型了：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">CopyWithRename<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token keyword">as</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">modified</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Capitalize<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">&amp;</span> <span class="token constant">K</span><span class="token operator">></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token comment">// &#123;</span><span class="token comment">//   modifiedName: string;</span><span class="token comment">//   modifiedAge: number;</span><span class="token comment">// &#125;</span><span class="token keyword">type</span> <span class="token class-name">CopiedFoo</span> <span class="token operator">=</span> CopyWithRename<span class="token operator">&lt;</span>Foo<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，这是 TypeScript 中首次引入了<strong>能直接改变类型本身含义</strong>的工具类型。你肯定对它们的内部实现非常有兴趣，然而当你跳转到源码定义时却会发现它们的定义是这样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Uppercase<span class="token operator">&lt;</span><span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> intrinsic<span class="token keyword">type</span> <span class="token class-name">Lowercase<span class="token operator">&lt;</span><span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> intrinsic<span class="token keyword">type</span> <span class="token class-name">Capitalize<span class="token operator">&lt;</span><span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> intrinsic<span class="token keyword">type</span> <span class="token class-name">Uncapitalize<span class="token operator">&lt;</span><span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> intrinsic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>intrinsic 代表了这一工具类型由 TypeScript 内部进行实现，如果我们去看内部的源码，会发现更神奇的部分：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">applyStringMapping</span><span class="token punctuation">(</span><span class="token builtin">symbol</span><span class="token operator">:</span> Symbol<span class="token punctuation">,</span> str<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>intrinsicTypeKinds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token builtin">symbol</span><span class="token punctuation">.</span>escapedName <span class="token keyword">as</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> IntrinsicTypeKind<span class="token punctuation">.</span>Uppercase<span class="token operator">:</span>      <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">case</span> IntrinsicTypeKind<span class="token punctuation">.</span>Lowercase<span class="token operator">:</span>      <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">case</span> IntrinsicTypeKind<span class="token punctuation">.</span>Capitalize<span class="token operator">:</span>      <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">case</span> IntrinsicTypeKind<span class="token punctuation">.</span>Uncapitalize<span class="token operator">:</span>      <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> str<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你会发现，在这里字符串字面量类型被作为一个字符串值一样进行处理，这些工具类型通过调用了字符串的 toUpperCase 等原生方法实现。而按照这个趋势来看，在未来我们很有可能实现对字面量类型的更多操作，甚至以后我们能直接调用 Lodash 来处理字符串类型也说不定。</p><p>也正是由于目前这些实现需要在 TypeScript 内部实现，而无法通过类型编程达到，在类型编程范式归类中我们并没有包括这一部分。但模板字符串类型却可以和部分范式产生奇妙的化学反应，比如模式匹配工具类型。</p><h2 id="模板字符串类型与模式匹配"><a href="#模板字符串类型与模式匹配" class="headerlink" title="模板字符串类型与模式匹配"></a>模板字符串类型与模式匹配</h2><p>模式匹配工具类型的核心理念就是对符合约束的某个类型结构，提取其某一个位置的类型，比如函数结构中的参数与返回值类型。而如果我们将一个字符串类型视为一个结构，就能够在其中也应用模式匹配相关的能力，而我们此前所缺少的就是模板字符串类型的能力。</p><p>模板插槽不仅可以声明一个占位的坑，也可以声明一个要提取的部分，我们来看一个例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ReverseName<span class="token operator">&lt;</span>Str <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span>  Str <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> First<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Last<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>    <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Capitalize<span class="token operator">&lt;</span>Last<span class="token operator">></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>First<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>    <span class="token operator">:</span> Str<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们一共在两处使用了模板字符串类型。首先是在约束部分，我们希望传入的字符串字面量类型是 <code>&quot;Tom Hardy&quot;</code> <code>&quot;Lin Budu&quot;</code> 这样的形式。注意，这里的空格也需要严格遵循，因为<strong>它也是一个字面量类型的一部分</strong>。对于符合这样约束的类型，我们使用<strong>模板插槽 + infer 关键字</strong>提取了其空格旁的两个部分（即名与姓）。然后在条件类型中，我们将 infer 提取出来的值，再次使用模板插槽注入到了新的字符串类型中。</p><p>来实际使用一下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ReversedTomHardy</span> <span class="token operator">=</span> ReverseName<span class="token operator">&lt;</span><span class="token string">'Tom hardy'</span><span class="token operator">></span> <span class="token comment">// "Hardy Tom"</span><span class="token keyword">type</span> <span class="token class-name">ReversedLinbudu</span> <span class="token operator">=</span> ReverseName<span class="token operator">&lt;</span><span class="token string">'Budu Lin'</span><span class="token operator">></span> <span class="token comment">// "Lin Budu"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>你可能会想到，如果传入的字符串字面量类型中有多个空格呢？这种情况下，模式匹配将只会匹配首个空格，即 <code>&quot;A B C&quot;</code> 会被匹配为 <code>&quot;A&quot;</code> 与 <code>&quot;B C&quot;</code> 这样的两个结构：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ReversedRes1</span> <span class="token operator">=</span> ReverseName<span class="token operator">&lt;</span><span class="token string">'Budu Lin 599'</span><span class="token operator">></span> <span class="token comment">// "Lin 599 Budu"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>除了显式使用 infer 进行模式匹配操作以外，由于模板字符串的灵活性，我们甚至可以直接声明一个泛型来进行模式匹配操作：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">handler</span><span class="token generic class-name"><span class="token operator">&lt;</span>Str <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Guess who is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Str<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token operator">:</span> Str<span class="token function">handler</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Guess who is Linbudu</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span> <span class="token comment">// "Linbudu"</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Guess who is </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span> <span class="token comment">// ""</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Guess who is  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span> <span class="token comment">// " "</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Guess who was</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span> <span class="token comment">// Error</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span> <span class="token comment">// Error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节，我们学习了一个新的内置类型能力：模板字符串类型。它既是内置类型，也是内置类型工具，还包括了专用的工具类型等。在实际应用中，由于其灵活性与自动分发联合能力等能力，我们可以用它来进行大量字面量类型的定义与约束。另外，模板字符串类型本身也和此前已存在类型工具（如映射类型与索引类型）有着奇妙的组合效果。</p><p>而基于模板字符串类型与模式匹配，我们还可以进行非常多有趣的操作，在下一节我们就会来介绍一些基于模板字符串的工具类型，包括类型层面的 Split（从 <code>1.2.4</code> 到 <code>[1, 2, 4]</code>），Join（从 <code>[1, 2, 4]</code> 到 <code>1.2.4</code>），Trim（还有 TrimLeft、TrimRight），甚至还有 Case 转换，如驼峰 CamelCase 类型的一步步实现等。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="基于重映射的-PickByValueType"><a href="#基于重映射的-PickByValueType" class="headerlink" title="基于重映射的 PickByValueType"></a>基于重映射的 PickByValueType</h3><p>我们在这一节了解了重映射这一能力，它使得我们可以在映射类型中去修改映射后的键名，而如果映射后的键名变成了 never ，那么这个属性将不会出现在最终的接口结构中。也就是说，我们也可以基于重映射来实现<strong>结构处理</strong>工具类型，比如说 PickByValueType ：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">PickByValueType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span> Type<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token keyword">as</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">Type</span> <span class="token operator">?</span> <span class="token constant">K</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们在重映射中再次进行了条件类型判断，并在其成立时才重映射到原键名，否则只返回一个 never。类似的，我们也可以实现 OmitByType 等等。</p><p>这也是 TypeScript 的更新中经常会出现的一个有趣现象，新版本的能力有时可以让我们大大简化类型编程中的操作，除了上面基于重映射实现的结构处理，我们此前也了解了基于 infer extends 来简化模式匹配类型中的结果过滤。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>19.类型编程新范式：模板字符串工具类型进阶</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/19.%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E6%96%B0%E8%8C%83%E5%BC%8F%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E8%BF%9B%E9%98%B6/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/19.%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E6%96%B0%E8%8C%83%E5%BC%8F%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>上一节，我们了解了模板字符串类型的基础内容，它与数个类型工具的协作，以及将作为本节核心内容的，<strong>模板字符串类型与模式匹配产生的化学反应</strong>。</p><p>我们还是照例先复习一下，如何在模板插槽中使用 infer 关键字：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ReverseName<span class="token operator">&lt;</span>Str <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span>  Str <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> First<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Last<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>    <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Capitalize<span class="token operator">&lt;</span>Last<span class="token operator">></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>First<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>    <span class="token operator">:</span> Str<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们在上一节说到，对模板字符串类型中使用模式匹配时，本质上就是在一个字符串字面量类型结构做处理。因此我们可以复刻一个字符串类型的值拥有的大部分方法，从 trim 到 split，从 startsWith 到 endsWith 等等。这些方法就是我们本节要学习的内容，从简单的 trim 、includes，到需要稍微绕一绕的 split、join ，再到较为复杂的 case 转换，我们都将一一实现。</p><p>万事开头难并不是绝对的，也可能是你的开头不一定对。模板字符串相关的工具类型既有非常简单的，也有极度复杂烧脑的。为了秉持本小册一路循序渐进的优良作风，我们当然还是从最简单的部分开始。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F16-advanced-template-string-type">Advanced Template String Types</a></p></blockquote><h2 id="从最简单的模式匹配说起：Trim、Includes-等"><a href="#从最简单的模式匹配说起：Trim、Includes-等" class="headerlink" title="从最简单的模式匹配说起：Trim、Includes 等"></a>从最简单的模式匹配说起：Trim、Includes 等</h2><p>最简单的模式匹配只有一层条件类型语句，也就意味着我们不需要对模式匹配的结果做结构转换等操作。对比到字符串类型变量的方法，也就是 trim（trimLeft、trimRight）、includes、startsWith 与 endsWith。</p><p>我们从比较有代表性的 includes 看起，对应实现一个类型层面的版本：<strong>判断传入的字符串字面量类型中是否含有某个字符串</strong>：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Include<span class="token operator">&lt;</span>  Str <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span>  Search <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> Str <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> _R1<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Search<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> _R2<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 Include 类型中，我们在 Search 前后声明了两个 infer 插槽，但实际上并不消费 R1 与 R2，而只是判断字符串是否可以被划分为<strong>要搜索的部分 + 其他部分</strong>。来验证一下实际效果：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">IncludeRes1</span> <span class="token operator">=</span> Include<span class="token operator">&lt;</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token string">'lin'</span><span class="token operator">></span> <span class="token comment">// true</span><span class="token keyword">type</span> <span class="token class-name">IncludeRes2</span> <span class="token operator">=</span> Include<span class="token operator">&lt;</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token string">'_lin'</span><span class="token operator">></span> <span class="token comment">// false</span><span class="token keyword">type</span> <span class="token class-name">IncludeRes3</span> <span class="token operator">=</span> Include<span class="token operator">&lt;</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token operator">></span> <span class="token comment">// true</span><span class="token keyword">type</span> <span class="token class-name">IncludeRes4</span> <span class="token operator">=</span> Include<span class="token operator">&lt;</span><span class="token string">' '</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token operator">></span> <span class="token comment">// true</span><span class="token keyword">type</span> <span class="token class-name">IncludeRes5</span> <span class="token operator">=</span> Include<span class="token operator">&lt;</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token operator">></span> <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 IncludeRes4 中，我们发现对于空字符串 <code>&#39;&#39;</code> 需要进行特殊的处理，<code>&#39;&#39;.includes(&#39;&#39;)</code> 也应当是成立的，就像实际字符串中进行判断一样。我们希望尽可能贴近原本字符串方法的表现，因此我们需要新增额外处理：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">_Include<span class="token operator">&lt;</span>  Str <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span>  Search <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> Str <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> _R1<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Search<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> _R2<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token keyword">type</span> <span class="token class-name">Include<span class="token operator">&lt;</span>Str <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span> Search <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> Str <span class="token keyword">extends</span> <span class="token string">''</span>  <span class="token operator">?</span> Search <span class="token keyword">extends</span> <span class="token string">''</span>    <span class="token operator">?</span> <span class="token boolean">true</span>    <span class="token operator">:</span> <span class="token boolean">false</span>  <span class="token operator">:</span> _Include<span class="token operator">&lt;</span>Str<span class="token punctuation">,</span> Search<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当字符串 Str 为空字符串时，我们判断 Search 是否是空字符串来直接决定返回结果，因为很明显 <code>&#39;&#39;.includes(&#39;linbudu&#39;)</code> 是不成立的。在 Str 不为空字符串时，我们才会真的进行 Include 的判断。</p><p>在 Str 与 Search 均为空字符串的情况下，我们直接返回 true，否则我们才进行模式匹配。</p><p>而提到模板字符串类型中的空字符串，我们会想到 trim 三兄弟：去除起始部分空格的 trimStart，去除结尾部分空格的 trimEnd，以及开头结尾空格一起去的 trim。基于模式匹配的思路我们还是很容易进行对应的类型实现：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// trimStart</span><span class="token keyword">type</span> <span class="token class-name">TrimLeft<span class="token operator">&lt;</span><span class="token constant">V</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">V</span> <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> <span class="token constant">R</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">?</span> <span class="token constant">R</span> <span class="token operator">:</span> <span class="token constant">V</span><span class="token comment">// trimEnd</span><span class="token keyword">type</span> <span class="token class-name">TrimRight<span class="token operator">&lt;</span><span class="token constant">V</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">V</span> <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> <span class="token constant">R</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> </span><span class="token template-punctuation string">`</span></span> <span class="token operator">?</span> <span class="token constant">R</span> <span class="token operator">:</span> <span class="token constant">V</span><span class="token comment">// trim</span><span class="token keyword">type</span> <span class="token class-name">Trim<span class="token operator">&lt;</span><span class="token constant">V</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> TrimLeft<span class="token operator">&lt;</span>TrimRight<span class="token operator">&lt;</span><span class="token constant">V</span><span class="token operator">>></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>聪明的你肯定会想到，我们的字符串边缘可能不止有一个空格！而这里的实现只能去掉一个，操作很简单，我们递归一下就好了：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">TrimLeft<span class="token operator">&lt;</span>Str <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> Str <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> <span class="token constant">R</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">?</span> TrimLeft<span class="token operator">&lt;</span><span class="token constant">R</span><span class="token operator">></span>  <span class="token operator">:</span> Str<span class="token keyword">type</span> <span class="token class-name">TrimRight<span class="token operator">&lt;</span>Str <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> Str <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> <span class="token constant">R</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> </span><span class="token template-punctuation string">`</span></span>  <span class="token operator">?</span> TrimRight<span class="token operator">&lt;</span><span class="token constant">R</span><span class="token operator">></span>  <span class="token operator">:</span> Str<span class="token keyword">type</span> <span class="token class-name">Trim<span class="token operator">&lt;</span>Str <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> TrimLeft<span class="token operator">&lt;</span>TrimRight<span class="token operator">&lt;</span>Str<span class="token operator">>></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，在字符串的两边不包含空格时，递归就会停止，从而返回一致“干净”的字符串。</p><p>而类型版本的 StartsWith 与 EndsWith 两个工具类型，和 Include 的实现非常接近，我们直接看其中 StartsWith 的最终实现与验证：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">_StartsWith<span class="token operator">&lt;</span>  Str <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span>  Search <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> Str <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Search<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> _R<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token keyword">type</span> <span class="token class-name">StartsWith<span class="token operator">&lt;</span>Str <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span> Search <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> Str <span class="token keyword">extends</span> <span class="token string">''</span>  <span class="token operator">?</span> Search <span class="token keyword">extends</span> <span class="token string">''</span>    <span class="token operator">?</span> <span class="token boolean">true</span>    <span class="token operator">:</span> _StartsWith<span class="token operator">&lt;</span>Str<span class="token punctuation">,</span> Search<span class="token operator">></span>  <span class="token operator">:</span> _StartsWith<span class="token operator">&lt;</span>Str<span class="token punctuation">,</span> Search<span class="token operator">></span><span class="token keyword">type</span> <span class="token class-name">StartsWithRes1</span> <span class="token operator">=</span> StartsWith<span class="token operator">&lt;</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token string">'lin'</span><span class="token operator">></span> <span class="token comment">// true</span><span class="token keyword">type</span> <span class="token class-name">StartsWithRes2</span> <span class="token operator">=</span> StartsWith<span class="token operator">&lt;</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token operator">></span> <span class="token comment">// true</span><span class="token keyword">type</span> <span class="token class-name">StartsWithRes3</span> <span class="token operator">=</span> StartsWith<span class="token operator">&lt;</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token operator">></span> <span class="token comment">// false</span><span class="token keyword">type</span> <span class="token class-name">StartsWithRes4</span> <span class="token operator">=</span> StartsWith<span class="token operator">&lt;</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token operator">></span> <span class="token comment">// true</span><span class="token keyword">type</span> <span class="token class-name">StartsWithRes5</span> <span class="token operator">=</span> StartsWith<span class="token operator">&lt;</span><span class="token string">' '</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token operator">></span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和 Include 基本一致，只是我们需要确保 Search 在字符串的开头部分。</p><p>在这一部分，我们了解了字符串类型中 Include、Trim 系列、StartsWith 与 EndsWith 这几个较简单的工具类型实现。现在热身完毕，是时候开始更复杂的部分了，比如 Replace 怎么样？</p><h2 id="结构转换：Replace、Split-与-Join"><a href="#结构转换：Replace、Split-与-Join" class="headerlink" title="结构转换：Replace、Split 与 Join"></a>结构转换：Replace、Split 与 Join</h2><p>看起来 Replace 好像是挺复杂的实现？但仔细想想它和 Include 其实没有啥区别，Include 判断是<strong>否能将字符串字面量划分为目标部分与其他部分</strong>，那 Replace 不是只需要<strong>将目标部分替换为新的部分，按照原本的结构组合好</strong>就行了吗？就像我们在对象层面的集合类型中学习的那样，<strong>一切复杂的工具类型最终都可以转换为数个简单工具类型的组合</strong>。</p><p>在 Include 实现中，我们有两个纯做结构判断的 infer 插槽，现在它们也能真正的派上用场了：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Replace<span class="token operator">&lt;</span>  Str <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span>  Search <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span>  Replacement <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> Str <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Head<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Search<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Tail<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Head<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Replacement<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Tail<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">:</span> Str<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>既然这两个插槽派上了用场，我们就需要给它们正式点的名字。Head 与 Tail 这两个名字我们后面还会常常见到，它们就表示开头与结尾的匹配部分。</p><p>这里我们其实是先判断字符串字面量中是否包含 Search 部分（就像 Include 那样），在包含也就是结构符合时，将匹配得到的 Head 与 Tail 部分夹上 Replacement，我们就实现了一个类型版本的 Replace：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// "林不渡也不是不能渡"</span><span class="token keyword">type</span> <span class="token class-name">ReplaceRes1</span> <span class="token operator">=</span> Replace<span class="token operator">&lt;</span><span class="token string">'林不渡'</span><span class="token punctuation">,</span> <span class="token string">'不'</span><span class="token punctuation">,</span> <span class="token string">'不渡也不是不能'</span><span class="token operator">></span><span class="token comment">// 不发生替换，仍然是"林不渡"</span><span class="token keyword">type</span> <span class="token class-name">ReplaceRes2</span> <span class="token operator">=</span> Replace<span class="token operator">&lt;</span><span class="token string">'林不渡'</span><span class="token punctuation">,</span> <span class="token string">'？'</span><span class="token punctuation">,</span> <span class="token string">'？？'</span><span class="token operator">></span> <span class="token comment">//</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然而，你应该遇到过需要全量替换的场景，也就是 ECMAScript 2021 的 replaceAll 方法。那我们能否在类型层面也实现一个 replaceAll？当然没问题，只需要再请出我们的老朋友——递归：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">ReplaceAll<span class="token operator">&lt;</span>  Str <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span>  Search <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span>  Replacement <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> Str <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Head<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Search<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Tail<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">?</span> ReplaceAll<span class="token operator">&lt;</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Head<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Replacement<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Tail<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> Search<span class="token punctuation">,</span> Replacement<span class="token operator">></span>  <span class="token operator">:</span> Str<span class="token comment">// "mmm.linbudu.top"</span><span class="token keyword">type</span> <span class="token class-name">ReplaceAllRes1</span> <span class="token operator">=</span> ReplaceAll<span class="token operator">&lt;</span><span class="token string">'www.linbudu.top'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token string">'m'</span><span class="token operator">></span><span class="token comment">// "www-linbudu-top"</span><span class="token keyword">type</span> <span class="token class-name">ReplaceAllRes2</span> <span class="token operator">=</span> ReplaceAll<span class="token operator">&lt;</span><span class="token string">'www.linbudu.top'</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你更喜欢将这两个类型合并在一起，再通过选项来控制是否进行全量替换，其实也很简单，在结构工具类型中我们就试过引入类型层面的选项控制，这里也是类似：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Replace<span class="token operator">&lt;</span>  Input <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span>  Search <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span>  Replacement <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span>  ShouldReplaceAll <span class="token keyword">extends</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token operator">></span></span> <span class="token operator">=</span> Input <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Head<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Search<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Tail<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">?</span> ShouldReplaceAll <span class="token keyword">extends</span> <span class="token class-name"><span class="token boolean">true</span></span>    <span class="token operator">?</span> Replace<span class="token operator">&lt;</span>        <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Head<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Replacement<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Tail<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>        Search<span class="token punctuation">,</span>        Replacement<span class="token punctuation">,</span>        ShouldReplaceAll      <span class="token operator">></span>    <span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Head<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Replacement<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Tail<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">:</span> Input<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了 replace 与 replaceAll，在字符串类型值中还有一个常用的方法：split ，它会将字符串按照确定的分隔符拆分成一个数组，比如从 <code>&#39;lin-bu-du&#39;</code> 按照 <code>&#39;-&#39;</code> 拆分为 <code>[&#39;lin&#39;, &#39;bu&#39;, &#39;du&#39;]</code>。在类型层面，我们也可以实现 Split，毕竟“分隔符”这个词就在强烈暗示你，它<strong>一定是符合某种结构的字面量类型</strong>。比如最简单的，假设我们所有的字符串都是 <code>&quot;A-B-C&quot;</code> 这个结构，那就可以这么拆分：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Split<span class="token operator">&lt;</span>Str <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span>  Str <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Head<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Body<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Tail<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>    <span class="token operator">?</span> <span class="token punctuation">[</span>Head<span class="token punctuation">,</span> Body<span class="token punctuation">,</span> Tail<span class="token punctuation">]</span>    <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">type</span> <span class="token class-name">SplitRes1</span> <span class="token operator">=</span> Split<span class="token operator">&lt;</span><span class="token string">'lin-bu-du'</span><span class="token operator">></span> <span class="token comment">// ["lin", "bu", "du"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，真实情况肯定不会这么简单，分隔符与字符串长度都是不确定的。但有着模式匹配与递归，没什么能难得倒我们，管你多长的字符串，我直接一个递归：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Split<span class="token operator">&lt;</span>  Str <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span>  Delimiter <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> Str <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Head<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Delimiter<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Tail<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">?</span> <span class="token punctuation">[</span>Head<span class="token punctuation">,</span> <span class="token operator">...</span>Split<span class="token operator">&lt;</span>Tail<span class="token punctuation">,</span> Delimiter<span class="token operator">></span><span class="token punctuation">]</span>  <span class="token operator">:</span> Str <span class="token keyword">extends</span> <span class="token class-name">Delimiter</span>  <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token operator">:</span> <span class="token punctuation">[</span>Str<span class="token punctuation">]</span><span class="token comment">// ["linbudu", "599", "fe"]</span><span class="token keyword">type</span> <span class="token class-name">SplitRes1</span> <span class="token operator">=</span> Split<span class="token operator">&lt;</span><span class="token string">'linbudu,599,fe'</span><span class="token punctuation">,</span> <span class="token string">','</span><span class="token operator">></span><span class="token comment">// ["linbudu", "599", "fe"]</span><span class="token keyword">type</span> <span class="token class-name">SplitRes2</span> <span class="token operator">=</span> Split<span class="token operator">&lt;</span><span class="token string">'linbudu 599 fe'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token operator">></span><span class="token comment">// ["l", "i", "n", "b", "u", "d", "u"]</span><span class="token keyword">type</span> <span class="token class-name">SplitRes3</span> <span class="token operator">=</span> Split<span class="token operator">&lt;</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有两种情况需要注意。第一种，存在多处分割时，Split 类型进行到最后一次，即无法再分割时，需要直接将最后一部分给返回。第二种，对于空字符串作为分隔符，其表现为将字符串字面量按字母进行拆分（SplitRes3），这同样与 Split 方法的实际表现一致。</p><p>在实际情况中，我们的字符串可能包含了多种可能的分隔符，即这里的 Delimiter 可以是一个联合类型 <code>&quot;_&quot; | &quot;-&quot; | &quot; &quot;</code> 。在这种情况下，模板字符串中的模式匹配也能够生效，它会使用这里的多个分隔符依次进行判断，并在判断到其中一种就立刻成立：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Delimiters</span> <span class="token operator">=</span> <span class="token string">'-'</span> <span class="token operator">|</span> <span class="token string">'_'</span> <span class="token operator">|</span> <span class="token string">' '</span><span class="token comment">// ["lin", "bu", "du"]</span><span class="token keyword">type</span> <span class="token class-name">SplitRes4</span> <span class="token operator">=</span> Split<span class="token operator">&lt;</span><span class="token string">'lin_bu_du'</span><span class="token punctuation">,</span> Delimiters<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但需要注意的是，我们并不能在一个字符串中混用多种分隔符，在这种情况下由于联合类型在插槽中的排列组合特性，我们会得到一个诡异的结果：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// ["lin" | "lin_bu", "du"] | ["lin" | "lin_bu", "bu", "du"]</span><span class="token keyword">type</span> <span class="token class-name">SplitRes5</span> <span class="token operator">=</span> Split<span class="token operator">&lt;</span><span class="token string">'lin_bu-du'</span><span class="token punctuation">,</span> Delimiters<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上，每次只能依据一种分隔符进行拆分才是符合预期的。在正常的变量命名中，通常只会使用一种分隔方式，如 <code>module-my_super_module-beta</code> 这个命名中，实际上只有 <code>-</code> 是分隔符。确实使用了多种具有实际意义的分隔符时，我们应该进行多次拆分，如 CSS 的 BEM 命名方式（<code>Block__Element--Modifier</code>）下，我们经常会这么写类名：<code>footer__button--danger</code>。此时，我们就应当先按照 <code>__</code> 拆出 Block，再按照 <code>--</code> 拆出 Modifier。</p><blockquote><p>另外，基于 Split 类型我们还可以获取字符串长度：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">StrLength<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> Split<span class="token operator">&lt;</span>Trim<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token string">'length'</span><span class="token punctuation">]</span><span class="token keyword">type</span> <span class="token class-name">StrLengthRes1</span> <span class="token operator">=</span> StrLength<span class="token operator">&lt;</span><span class="token string">'linbudu'</span><span class="token operator">></span> <span class="token comment">// 7</span><span class="token keyword">type</span> <span class="token class-name">StrLengthRes2</span> <span class="token operator">=</span> StrLength<span class="token operator">&lt;</span><span class="token string">'lin budu'</span><span class="token operator">></span> <span class="token comment">// 8</span><span class="token keyword">type</span> <span class="token class-name">StrLengthRes3</span> <span class="token operator">=</span> StrLength<span class="token operator">&lt;</span><span class="token string">''</span><span class="token operator">></span> <span class="token comment">// 0</span><span class="token keyword">type</span> <span class="token class-name">StrLengthRes4</span> <span class="token operator">=</span> StrLength<span class="token operator">&lt;</span><span class="token string">' '</span><span class="token operator">></span> <span class="token comment">// 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为即使是在类型层面，元祖类型的长度也会是一个有实际意义的值。</p></blockquote><p>我们上面介绍的许多方法之间其实存在关联，比如 TrimLeft 与 TrimEnd、StartsWith 与 EndsWith 是作用位置相反，Replace 是 Include 的进化版本，而 Split 也有这么一位伙伴：与它作用相反的 Join 。</p><p>Split 方法是<strong>将字符串按分隔符拆分成一个数组</strong>，而 Join 方法则是<strong>将一个数组中的所有字符串按照分隔符组装成一个字符串</strong>。我们只需要通过递归依次取出每一个字符串单元，使用模板插槽组装即可：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Join<span class="token operator">&lt;</span>  List <span class="token keyword">extends</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">,</span>  Delimiter <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> List <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token keyword">infer</span> Rest<span class="token punctuation">]</span>  <span class="token operator">?</span> <span class="token comment">// @ts-expect-error</span>    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>List<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Delimiter<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Join<span class="token operator">&lt;</span>Rest<span class="token punctuation">,</span> Delimiter<span class="token operator">></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">:</span> <span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里的 Rest 类型无法被正确地推导，因此使用了 // @ts-expect-error 来忽略错误。</p></blockquote><p>看起来似乎没啥问题，我们来试一下？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// `lin-bu-du-$&#123;string&#125;`</span><span class="token keyword">type</span> <span class="token class-name">JoinRes1</span> <span class="token operator">=</span> Join<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token string">'lin'</span><span class="token punctuation">,</span> <span class="token string">'bu'</span><span class="token punctuation">,</span> <span class="token string">'du'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>啊哦，很明显不对，我们分析一下原因。在递归进行到最后一次时，我们面对的条件类型大致是这样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">JoinTmp</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token keyword">infer</span> Rest<span class="token punctuation">]</span>  <span class="token operator">?</span> <span class="token comment">// @ts-expect-error</span>    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">lin-bu-du-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Join<span class="token operator">&lt;</span>Rest<span class="token punctuation">,</span> Delimiter<span class="token operator">></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">:</span> <span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个条件很明显不会成立，因此它返回了 string 类型，而这个 string 类型我们的本义是用来兜底：<strong>如果 Join 无法拼接一个列表，那至少要返回一个 string 类型</strong>。</p><p>要解决这种情况，我们只需要额外处理一下空数组的情况：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Join<span class="token operator">&lt;</span>  List <span class="token keyword">extends</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">,</span>  Delimiter <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> List <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token operator">?</span> <span class="token string">''</span>  <span class="token operator">:</span> List <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token keyword">infer</span> Rest<span class="token punctuation">]</span>  <span class="token operator">?</span> <span class="token comment">// @ts-expect-error</span>    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>List<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Delimiter<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Join<span class="token operator">&lt;</span>Rest<span class="token punctuation">,</span> Delimiter<span class="token operator">></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">:</span> <span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但最终结果还是不太对：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// `lin-bu-du-`</span><span class="token keyword">type</span> <span class="token class-name">JoinRes2</span> <span class="token operator">=</span> Join<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token string">'lin'</span><span class="token punctuation">,</span> <span class="token string">'bu'</span><span class="token punctuation">,</span> <span class="token string">'du'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上，在进行到最后一项数组成员时（即 <code>[&#39;du&#39;]</code>），我们的递归过程就应当被提前阻止。这里产生一个多余的 <code>&#39;-&#39;</code> 的原因，其实就是让这仅有一项的数组还进行了一次分隔符拼接。</p><p>因此我们也需要处理只剩下最后一项的情况：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Join<span class="token operator">&lt;</span>  List <span class="token keyword">extends</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">,</span>  Delimiter <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> List <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token operator">?</span> <span class="token string">''</span>  <span class="token operator">:</span> List <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">]</span>  <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>List<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">:</span> List <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token keyword">infer</span> Rest<span class="token punctuation">]</span>  <span class="token operator">?</span> <span class="token comment">// @ts-expect-error</span>    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>List<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Delimiter<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Join<span class="token operator">&lt;</span>Rest<span class="token punctuation">,</span> Delimiter<span class="token operator">></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">:</span> <span class="token builtin">string</span><span class="token comment">// "lin-bu-du"</span><span class="token keyword">type</span> <span class="token class-name">JoinRes3</span> <span class="token operator">=</span> Join<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token string">'lin'</span><span class="token punctuation">,</span> <span class="token string">'bu'</span><span class="token punctuation">,</span> <span class="token string">'du'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看起来简单的 Join 类型，我们却连续实现了三次才完成。Split 类型其实也是，如果不提前考虑到各种情况，很难注意到在最后一次递归需要的特殊处理。这也是类型编程中常见的一个情景，<strong>一个工具类型有时需要多次改进、多种边界情况处理，才能称为“可用”，尤其是在递归的情况下</strong>。</p><p>在模板字符串进阶类型的最后一部分，我们要来实现字符串的 Case 处理。这也是模板字符串类型中相对最为复杂的一部分，我们基本上是在对上面的模式匹配、递归、结构转换等概念做一次全面的结合应用。</p><h2 id="最后一步：Case-转换"><a href="#最后一步：Case-转换" class="headerlink" title="最后一步：Case 转换"></a>最后一步：Case 转换</h2><p>在上一节，我们已经了解了 TypeScript 内置的 Lowercase、Capitalize 等工具类型，知道它们是在内部实现的层面支持了字符串值的变换。其实基于这些工具类型，我们完全可以实现几乎所有常见的 Case，如 Camel Case（<code>&#39;linBuDu&#39;</code>）、Snake Case（<code>&#39;lin_bu_du&#39;</code>）、Delimiter Case（按照指定分隔符划分，如 <code>&#39;lin~bu~du&#39;</code> <code>&#39;lin&gt;bu&gt;du&#39;</code> 等，也包括 Snake Case）。</p><p>首先需要明确的一点是，对于字符串，无论是值还是字面量类型，我们并没有办法去智能拆分，比如 mynameislinbudu，在不注入判断逻辑的情况下，计算机并不知道如何进行分词。如果是已经具有了一种 case 的字符串，比如 my_name_is_linbudu，此时我们要拆分就容易多了。拆分其实就是 Case 转换的基础，我们本节介绍的 Case 转换一定是建立在 <strong>传入字符串已经拥有了一种 case</strong> 的情况。</p><p>我们先以 CamelCase 为最终产物，了解如何从 SnakeCase 转换到 CamelCase，也就是下划线转小驼峰。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 如何实现？</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>SnakeCase2CamelCase<span class="token operator">&lt;</span><span class="token string">'foo_bar_baz'</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token string">'fooBarBaz'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>看这清晰明确的结构，不用模式匹配简直暴殄天物，我们需要做的就是按照 <code>_</code> 进行结构匹配，然后将除了首个字符串单元（在这里即是 <code>foo</code> ）以外的后续部分都转为首字母大写。至于怎么转，当然是贴心内置的 Capitalize 了。</p><p>我们直接来看实现，由于这部分会有大量的结果验证，我们再次请出 expectType：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">SnakeCase2CamelCase<span class="token operator">&lt;</span><span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span>  <span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Head<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token string">'_'</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Rest<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>    <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Head<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>SnakeCase2CamelCase<span class="token operator">&lt;</span>Capitalize<span class="token operator">&lt;</span>Rest<span class="token operator">>></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>    <span class="token operator">:</span> <span class="token constant">S</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>SnakeCase2CamelCase<span class="token operator">&lt;</span><span class="token string">'foo_bar_baz'</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token string">'fooBarBaz'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决了 SnakeCase ，稍微举一反三，你会发现 KebabCase（中划线，如 <code>&quot;lin-bu-du&quot;</code>）其实也解决了，不就是换个分隔符的事？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">KebabCase2CamelCase<span class="token operator">&lt;</span><span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span>  <span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Head<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token string">'-'</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Rest<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>    <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Head<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>KebabCase2CamelCase<span class="token operator">&lt;</span>Capitalize<span class="token operator">&lt;</span>Rest<span class="token operator">>></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>    <span class="token operator">:</span> <span class="token constant">S</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>KebabCase2CamelCase<span class="token operator">&lt;</span><span class="token string">'foo-bar-baz'</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token string">'fooBarBaz'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SnakeCase 和 KebabCase 的唯一区别就是模式匹配的分隔符，身为封装工程师，我们肯定要把分隔符的能力进行抽象，支持任意的分隔符：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">DelimiterCase2CamelCase<span class="token operator">&lt;</span>  <span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span>  Delimiter <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Head<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Delimiter<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Rest<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Head<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>DelimiterCase2CamelCase<span class="token operator">&lt;</span>Capitalize<span class="token operator">&lt;</span>Rest<span class="token operator">></span><span class="token punctuation">,</span> Delimiter<span class="token operator">></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">:</span> <span class="token constant">S</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>来验证一下效果：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>DelimiterCase2CamelCase<span class="token operator">&lt;</span><span class="token string">'foo-bar-baz'</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token string">'fooBarBaz'</span><span class="token punctuation">)</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>DelimiterCase2CamelCase<span class="token operator">&lt;</span><span class="token string">'foo~bar~baz'</span><span class="token punctuation">,</span> <span class="token string">'~'</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token string">'fooBarBaz'</span><span class="token punctuation">)</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>DelimiterCase2CamelCase<span class="token operator">&lt;</span><span class="token string">'foo bar baz'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token string">'fooBarBaz'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>到这里，我们支持了一个能够通过传入分隔符解决任意 Delimiter Case 转 Camel Case，看起来可以功成身退了。但这里还存在非常大的优化空间，比如我们还能让它自动处理分隔符。通常的变量命名只会使用 <code>_</code> 和 <code>-</code> 作为分隔符，加上字面量中可能存在的空格，也就是我们希望自动处理 <code>&quot;_&quot; | &quot;-&quot; | &quot; &quot;</code> 这三个分隔符。</p><p>你可能会想当然地写出这样的代码：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">WordDelimiter</span> <span class="token operator">=</span> <span class="token string">'-'</span> <span class="token operator">|</span> <span class="token string">'_'</span> <span class="token operator">|</span> <span class="token string">' '</span><span class="token keyword">type</span> <span class="token class-name">DelimiterCase2CamelCaseAuto<span class="token operator">&lt;</span><span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span>  <span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Head<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Delimiter<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Rest<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>    <span class="token operator">?</span> Delimiter <span class="token keyword">extends</span> <span class="token class-name">WordDelimiter</span>      <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Head<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>DelimiterCase2CamelCaseAuto<span class="token operator">&lt;</span>Capitalize<span class="token operator">&lt;</span>Rest<span class="token operator">>></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>      <span class="token operator">:</span> <span class="token constant">S</span>    <span class="token operator">:</span> <span class="token constant">S</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你真觉得这能够工作，我的建议是再回到上一部分重新来过。对于这种连续的 infer 插槽，其匹配策略是尽可能为前面的每个插槽匹配一个字符，然后将所有剩下的部分都交给最后一个插槽。如 <code>&quot;lin-bu-du&quot;</code> 在上面会匹配为 <code>l</code> <code>i</code> <code>n-budu</code>。</p><p>因此要实现一个自动分割的版本，我们还需要一些额外的工作，但思路仍然是一致的：<strong>按照分隔符拆分</strong>，对除首个字符串以外的字符单元进行首字母大写处理以及组装。在 Delimiter Case 中，我们通过可确定的分隔符直接使用递归模式匹配拆分，如果分隔符并不确定的情况下我们应该怎么做？</p><p>我们在上面讲到的 Split 类型，其实就能很好地满足我们的需要：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Delimiters</span> <span class="token operator">=</span> <span class="token string">'-'</span> <span class="token operator">|</span> <span class="token string">'_'</span> <span class="token operator">|</span> <span class="token string">' '</span><span class="token comment">// ["lin", "bu", "du"]</span><span class="token keyword">type</span> <span class="token class-name">SplitRes4</span> <span class="token operator">=</span> Split<span class="token operator">&lt;</span><span class="token string">'lin_bu_du'</span><span class="token punctuation">,</span> Delimiters<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，我们可以使用 Split 将字符串拆分成数组，然后在数组中去处理第一项以外的其他成员：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">CamelCase<span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> CamelCaseStringArray<span class="token operator">&lt;</span>  Split<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span> Delimiters<span class="token operator">></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>而 CamelCaseStringArray 这个类型，我们希望它能够将 <code>[&#39;lin&#39;, &#39;bu&#39;, &#39;du&#39;]</code> 转化为 <code>[&#39;lin&#39;, &#39;Bu&#39;, &#39;Du&#39;]</code>。也就是说这个数组可以分为两个部分，无需处理的第一项和全部首字母大写的其余项：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">CamelCaseStringArray<span class="token operator">&lt;</span>Words <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span> <span class="token operator">=</span> Words <span class="token keyword">extends</span> <span class="token punctuation">[</span>  <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> First<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>  <span class="token operator">...</span><span class="token keyword">infer</span> Rest<span class="token punctuation">]</span>  <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>First<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>CapitalizeStringArray<span class="token operator">&lt;</span>Rest<span class="token operator">></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">:</span> <span class="token builtin">never</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在数组中进行模式匹配时，我们为何也使用了看似多余的 infer 插槽？这是因为我们的 First 会直接传入给插槽，通过 infer 插槽匹配，能够确保最终 infer First 得到的 infer 值一定会是字符串类型。</p><p>由于这里的 First 和 Rest 被视为两种不同的结构，因此我们需要再声明一个 CapitalizeStringArray 类型，它的作用就是将<strong>递归地将数组中所有的字符串单元转化为首字母大写形式</strong>：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">CapitalizeStringArray<span class="token operator">&lt;</span>Words <span class="token keyword">extends</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span> <span class="token operator">=</span> Words <span class="token keyword">extends</span> <span class="token punctuation">[</span>  <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> First<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>  <span class="token operator">...</span><span class="token keyword">infer</span> Rest<span class="token punctuation">]</span>  <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Capitalize<span class="token operator">&lt;</span>First<span class="token operator">></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>CapitalizeStringArray<span class="token operator">&lt;</span>Rest<span class="token operator">></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">:</span> <span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样我们就得到了一个初具雏形的 Camel Case 智能版：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Delimiters</span> <span class="token operator">=</span> <span class="token string">'-'</span> <span class="token operator">|</span> <span class="token string">'_'</span> <span class="token operator">|</span> <span class="token string">' '</span><span class="token keyword">type</span> <span class="token class-name">CapitalizeStringArray<span class="token operator">&lt;</span>Words <span class="token keyword">extends</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span> <span class="token operator">=</span> Words <span class="token keyword">extends</span> <span class="token punctuation">[</span>  <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> First<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>  <span class="token operator">...</span><span class="token keyword">infer</span> Rest<span class="token punctuation">]</span>  <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Capitalize<span class="token operator">&lt;</span>First<span class="token operator">></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>CapitalizeStringArray<span class="token operator">&lt;</span>Rest<span class="token operator">></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">:</span> <span class="token string">''</span><span class="token keyword">type</span> <span class="token class-name">CamelCaseStringArray<span class="token operator">&lt;</span>Words <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span> <span class="token operator">=</span> Words <span class="token keyword">extends</span> <span class="token punctuation">[</span>  <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> First<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>  <span class="token operator">...</span><span class="token keyword">infer</span> Rest<span class="token punctuation">]</span>  <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>First<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>CapitalizeStringArray<span class="token operator">&lt;</span>Rest<span class="token operator">></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Split<span class="token operator">&lt;</span>  <span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span>  Delimiter <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Head<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Delimiter<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Tail<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">?</span> <span class="token punctuation">[</span>Head<span class="token punctuation">,</span> <span class="token operator">...</span>Split<span class="token operator">&lt;</span>Tail<span class="token punctuation">,</span> Delimiter<span class="token operator">></span><span class="token punctuation">]</span>  <span class="token operator">:</span> <span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token class-name">Delimiter</span>  <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">]</span><span class="token keyword">type</span> <span class="token class-name">CamelCase<span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> CamelCaseStringArray<span class="token operator">&lt;</span>Split<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span> Delimiters<span class="token operator">>></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>来验证一下效果：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>CamelCase<span class="token operator">&lt;</span><span class="token string">'foo-bar-baz'</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token string">'fooBarBaz'</span><span class="token punctuation">)</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>CamelCase<span class="token operator">&lt;</span><span class="token string">'foo bar baz'</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token string">'fooBarBaz'</span><span class="token punctuation">)</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>CamelCase<span class="token operator">&lt;</span><span class="token string">'foo_bar_baz'</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token string">'fooBarBaz'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>CamelCase 这个类型确实有一定复杂度，但它本质上仍然是数个基础工具类型与概念的组合，包括模板字符串类型、infer 插槽与模式匹配结合、Rest infer 等等。同时，我们并没有想一口气把它实现出来，而是先整理了思路（拆分、转换、重组），确定了能够依赖的基础工具类型（Split），才一步步实现了它。</p><p>这里的 Camel Case 其实还有一些需要改进的地方，比如首字母大写的 <code>Foo-bar-baz</code> 和全大写的 <code>&#39;FOO-BAR-BAZ&#39;</code> ，也需要转化为小驼峰形式的 <code>fooBarBaz</code> 。</p><p>这里我放上 Type Fest 中 Camel Case 的最终实现，基本上处理了绝大部分的边界情况：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">PlainObjectType</span> <span class="token operator">=</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">></span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">WordSeparators</span> <span class="token operator">=</span> <span class="token string">'-'</span> <span class="token operator">|</span> <span class="token string">'_'</span> <span class="token operator">|</span> <span class="token string">' '</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Split<span class="token operator">&lt;</span>  <span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span>  Delimiter <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Head<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Delimiter<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> Tail<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">?</span> <span class="token punctuation">[</span>Head<span class="token punctuation">,</span> <span class="token operator">...</span>Split<span class="token operator">&lt;</span>Tail<span class="token punctuation">,</span> Delimiter<span class="token operator">></span><span class="token punctuation">]</span>  <span class="token operator">:</span> <span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token class-name">Delimiter</span>  <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">]</span><span class="token keyword">type</span> <span class="token class-name">CapitalizeStringArray<span class="token operator">&lt;</span>Words <span class="token keyword">extends</span> <span class="token keyword">readonly</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Prev<span class="token operator">></span></span> <span class="token operator">=</span> Words <span class="token keyword">extends</span> <span class="token punctuation">[</span>  <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> First<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>  <span class="token operator">...</span><span class="token keyword">infer</span> Rest<span class="token punctuation">]</span>  <span class="token operator">?</span> First <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">undefined</span></span>    <span class="token operator">?</span> <span class="token string">''</span>    <span class="token operator">:</span> First <span class="token keyword">extends</span> <span class="token string">''</span>    <span class="token operator">?</span> CapitalizeStringArray<span class="token operator">&lt;</span>Rest<span class="token punctuation">,</span> Prev<span class="token operator">></span>    <span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Prev <span class="token keyword">extends</span> <span class="token string">''</span> <span class="token operator">?</span> First <span class="token operator">:</span> Capitalize<span class="token operator">&lt;</span>First<span class="token operator">></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>CapitalizeStringArray<span class="token operator">&lt;</span>        Rest<span class="token punctuation">,</span>        First      <span class="token operator">></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token operator">:</span> <span class="token string">''</span><span class="token keyword">type</span> <span class="token class-name">CamelCaseStringArray<span class="token operator">&lt;</span>Words <span class="token keyword">extends</span> <span class="token keyword">readonly</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span> <span class="token operator">=</span> Words <span class="token keyword">extends</span> <span class="token punctuation">[</span>  <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">infer</span> First<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>  <span class="token operator">...</span><span class="token keyword">infer</span> Rest<span class="token punctuation">]</span>  <span class="token operator">?</span> Uncapitalize<span class="token operator">&lt;</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>First<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>CapitalizeStringArray<span class="token operator">&lt;</span>Rest<span class="token punctuation">,</span> First<span class="token operator">></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token operator">></span>  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">CamelCase<span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token operator">=</span> CamelCaseStringArray<span class="token operator">&lt;</span>  Split<span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token class-name">Uppercase<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token operator">></span></span> <span class="token operator">?</span> Lowercase<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token operator">></span> <span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">,</span> WordSeparators<span class="token operator">></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，虽然 Camel Case 只是对一维字符串字面量进行的转换，但由于我们上一节讲到的重映射能力，它也可以被应用到对象类型层面：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">CamelCasedProperties<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> PlainObjectType<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token keyword">as</span> CamelCase<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">&amp;</span> <span class="token constant">K</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">object</span>    <span class="token operator">?</span> CamelCasedProperties<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">></span>    <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span>  CamelCasedProperties<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span> foo_bar<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> foo_baz<span class="token operator">:</span> <span class="token punctuation">&#123;</span> nested_foo<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token operator">></span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  fooBar<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>  fooBaz<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    nestedFoo<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基于此，我们就完成了模板字符串工具类型的最后一步，也是其集大成者 Case 转换。除了 Camel Case 以外，其实你也可以很容易对应着实现智能版的 Delimiter Case、Snake Case 等等，只要按着思路划分、基础工具类型确定、边界情况补全这一系列路径走下来，看似繁琐的模板字符串工具类型也并不可怕。</p><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>这一节，我们完成了模板字符串类型的进阶学习，仿照着 JavaScript 中字符串变量的方法实现了 Trim、Include、Replace、Split 以及 Case 转换等工具类型。这些类型虽然在实际项目开发中使用场景有限，但却带来了访问性修饰与结构处理等类型编程范式以外的新类型编程体系。同时，我们借着模板字符串类型的灵活性，再次复习了模式匹配的应用场景，让你对它的应用有了更深刻的了解。</p><p>到这里，我们的类型能力核心篇章就告一段落了。在这数十节的内容里，我们从内置类型基础开始，一步步跨过了内置类型工具、类型系统、类型编程与模板字符串类型四座大山，现在你可以自信地说自己已经把 TypeScript 的类型能力掌握个八九不离十了。</p><p>接下来，我们就要迈入到实战环节了，包括类型声明、React 与 ESLint 中的工程实践、装饰器、TSConfig 配置、Node API 开发等等，都是我们将攻克的对象。但是，类型能力和工程实战毕竟是两个基本独立的部分，因此我更建议你在此稍微驻足，做一个阶段性总结，看看是否已经把类型能力概念都掌握了？</p><p>相比之下，实战环节的难度其实要更低，我们更多是在介绍语法、配置项、实际使用，所以你完全可以好好缓解一下被类型折磨的大脑。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>20.工程层面的类型能力：类型声明、类型指令与命名空间</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/20.%E5%B7%A5%E7%A8%8B%E5%B1%82%E9%9D%A2%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%83%BD%E5%8A%9B%EF%BC%9A%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/20.%E5%B7%A5%E7%A8%8B%E5%B1%82%E9%9D%A2%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%83%BD%E5%8A%9B%EF%BC%9A%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>我们已经结束了 TypeScript 类型能力的学习，这一节将进入 TypeScript 的实战应用篇。实战篇主要包括了工程能力、框架集成、ECMAScript 语法、TSConfig 解析以及 Node API 开发这五个部分。</p><p>在这一节，我们主要介绍 TypeScript 的工程能力基础，包括类型指令、类型声明、命名空间这么几个部分。这些概念不仅可以帮助你了解到 TypeScript 工程能力的核心理念，也是接下来实战篇内容的前置基础。</p><p>要开始学习工程能力，其实我们可以从一个很简单的场景开始。如果你已经有一定 TypeScript 的使用经验，那你很有可能遇到过这么一个场景：出现了莫名其妙的类型报错，但你又不知道从何入手解决，想让 TypeScript 直接忽略掉这一行出错的代码？此时，类型指令就是你最需要的工具。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F17-declaration">Declaration</a></p></blockquote><h2 id="类型检查指令"><a href="#类型检查指令" class="headerlink" title="类型检查指令"></a>类型检查指令</h2><p>在前端世界的许多工具中，其实都提供了 <strong>行内注释（Inline Comments）</strong> 的能力，用于支持在某一处特定代码<strong>使用特殊的配置来覆盖掉全局配置</strong>。最常见的即是 ESLint 与 Prettier 提供的禁用检查能力，如 <code>/* eslint-disable-next-lint */</code>、<code>&lt;!-- prettier-ignore --&gt;</code> 等。TypeScript 中同样提供了数个行内注释（这里我们称为类型指令），来进行单行代码或单文件级别的配置能力。这些指令均以 <code>// @ts-</code> 开头 ，我们依次来介绍。</p><h3 id="ts-ignore-与-ts-expect-error"><a href="#ts-ignore-与-ts-expect-error" class="headerlink" title="ts-ignore 与 ts-expect-error"></a>ts-ignore 与 ts-expect-error</h3><p><code>ts-ignore</code> 应该是使用最为广泛的一个类型指令了，它的作用就是直接禁用掉对下一行代码的类型检查：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// @ts-ignore</span><span class="token keyword">const</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token number">599</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>基本上所有的类型报错都可以通过这个指令来解决，但由于它本质是上 ignore 而不是 disable，也就意味着如果下一行代码并没有问题，那使用 ignore 反而就是一个错误了。因此 TypeScript 随后又引入了一个更严格版本的 ignore，即 <code>ts-expect-error</code>，它只有在<strong>下一行代码真的存在错误时</strong>才能被使用，否则它会给出一个错误：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// @ts-expect-error</span><span class="token keyword">const</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token number">599</span><span class="token comment">// @ts-expect-error 错误使用此指令，报错</span><span class="token keyword">const</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">599</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里第二个 expect-error 指令会给出一个报错：<strong>无意义的 expect-error 指令</strong>。</p><p>那这两个功能相同的指令应该如何取舍？我的建议是<strong>在所有地方都不要使用 ts-ignore</strong>，直接把这个指令打入冷宫封存起来。原因在上面我们也说了，对于这类 ignore 指令，本来就应当确保<strong>下一行真的存在错误时</strong>才去使用。</p><p>这两个指令只能对单行代码生效，但如果我们有非常多的类型报错要处理（比如正在将一个 JavaScript 文件迁移到 TypeScript），难道要一个个为所有报错的地方都添加上禁用检查指令？当然不，正如 ESLint 中可以使用 <code>/* eslint-disable-next-line */</code> 禁用下一行代码检查，也可以使用 <code>/* eslint-disable */</code> 禁用整个文件检查一样， TypeScript 中也提供了对整个文件生效的类型指令：<code>ts-check</code> 与 <code>ts-nocheck</code>。</p><h3 id="ts-check-与-ts-nocheck"><a href="#ts-check-与-ts-nocheck" class="headerlink" title="ts-check 与 ts-nocheck"></a>ts-check 与 ts-nocheck</h3><p>我们首先来看 ts-nocheck ，你可以把它理解为一个作用于整个文件的 ignore 指令，使用了 ts-nocheck 指令的 TS 文件将不再接受类型检查：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// @ts-nocheck 以下代码均不会抛出错误</span><span class="token keyword">const</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token number">599</span><span class="token keyword">const</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那么 <code>ts-check</code> 呢？这看起来是一个多余的指令，因为默认情况下 TS 文件不是就会被检查吗？实际上，这两个指令还可以用在 JS 文件中。要明白这一点，首先我们要知道，TypeScript 并不是只能检查 TS 文件，对于 JS 文件它也可以通过类型推导与 JSDoc 的方式进行不完全的类型检查。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// JavaScript 文件</span><span class="token keyword">let</span> myAge <span class="token operator">=</span> <span class="token number">18</span><span class="token comment">// 使用 JSDoc 标注变量类型</span><span class="token comment">/** @type &#123;string&#125; */</span><span class="token keyword">let</span> myName<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  prop <span class="token operator">=</span> <span class="token number">599</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的代码中，声明了初始值的 myAge 与 <code>Foo.prop</code> 都能被推导出其类型，而无初始值的 myName 也可以通过 JSDoc 标注的方式来显式地标注类型。</p><p>但我们知道 JavaScript 是弱类型语言，表现之一即是变量可以<strong>被赋值为与初始值类型不一致的值</strong>，比如上面的例子进一步改写：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> myAge <span class="token operator">=</span> <span class="token number">18</span>myAge <span class="token operator">=</span> <span class="token string">'90'</span> <span class="token comment">// 与初始值类型不同</span><span class="token comment">/** @type &#123;string&#125; */</span><span class="token keyword">let</span> myNamemyName <span class="token operator">=</span> <span class="token number">599</span> <span class="token comment">// 与 JSDoc 标注类型不同</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们的赋值操作在类型层面显然是不成立的，但我们是在 JavaScript 文件中，因此这里并不会有类型报错。如果希望在 JS 文件中也能享受到类型检查，此时 <code>ts-check</code> 指令就可以登场了：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// @ts-check</span><span class="token comment">/** @type &#123;string&#125; */</span><span class="token keyword">const</span> myName <span class="token operator">=</span> <span class="token number">599</span> <span class="token comment">// 报错！</span><span class="token keyword">let</span> myAge <span class="token operator">=</span> <span class="token number">18</span>myAge <span class="token operator">=</span> <span class="token string">'200'</span> <span class="token comment">// 报错！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们的 <code>ts-check</code> 指令为 JavaScript 文件也带来了类型检查，而我们同时还可以使用 <code>ts-expect-error</code> 指令来忽略掉单行的代码检查：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// @ts-check</span><span class="token comment">/** @type &#123;string&#125; */</span><span class="token comment">// @ts-expect-error</span><span class="token keyword">const</span> myName <span class="token operator">=</span> <span class="token number">599</span> <span class="token comment">// OK</span><span class="token keyword">let</span> myAge <span class="token operator">=</span> <span class="token number">18</span><span class="token comment">// @ts-expect-error</span>myAge <span class="token operator">=</span> <span class="token string">'200'</span> <span class="token comment">// OK</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而 <code>ts-nocheck</code> 在 JS 文件中的作用和 TS 文件其实也一致，即禁用掉对当前文件的检查。如果我们希望开启对所有 JavaScript 文件的检查，只是忽略掉其中少数呢？此时我们在 TSConfig 中启用 <code>checkJs</code> 配置，来开启<strong>对所有包含的 JS 文件的类型检查</strong>，然后使用 <code>ts-nocheck</code> 来忽略掉其中少数的 JS 文件。</p><p>除了类型指令以外，在实际项目开发中还有一个你会经常打交道的概念：类型声明。</p><h2 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h2><p>在此前我们其实就已经接触到了类型声明，它实际上就是 <code>declare</code> 语法：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">var</span> <span class="token function-variable function">f1</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token keyword">declare</span> <span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  prop<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>input<span class="token operator">:</span> Foo<span class="token punctuation">)</span><span class="token operator">:</span> Foo<span class="token keyword">declare</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以直接访问这些声明：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">let</span> otherProp<span class="token operator">:</span> Foo<span class="token punctuation">[</span><span class="token string">'prop'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但不能为这些声明变量赋值：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// × 不允许在环境上下文中使用初始值</span><span class="token keyword">declare</span> <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// √ Foo</span><span class="token keyword">declare</span> <span class="token keyword">let</span> result<span class="token operator">:</span> ReturnType<span class="token operator">&lt;</span><span class="token keyword">typeof</span> foo<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些类型声明就像我们在 TypeScript 中的类型标注一样，会存放着特定的类型信息，同时由于它们并不具有实际逻辑，我们可以很方便地使用类型声明来进行类型兼容性的比较、工具类型的声明与测试等等。</p><p>除了手动书写这些声明文件，更常见的情况是你的 TypeScript 代码在编译后生成声明文件：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 源代码</span><span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> input<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> foo<span class="token operator">:</span> Foo <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token string">'林不渡'</span><span class="token punctuation">,</span>  age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">FooCls</span> <span class="token punctuation">&#123;</span>  prop<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码在编译后会生成一个 <code>.js</code> 文件和一个 <code>.d.ts</code> 文件，而后者即是类型声明文件：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 生成的类型定义</span><span class="token keyword">declare</span> <span class="token keyword">const</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">boolean</span><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token keyword">declare</span> <span class="token keyword">const</span> foo<span class="token operator">:</span> Foo<span class="token keyword">declare</span> <span class="token keyword">class</span> <span class="token class-name">FooCls</span> <span class="token punctuation">&#123;</span>  prop<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样一来，如果别的文件或是别的项目导入了这段代码，它们就能够从这些类型声明获得对应部分的类型，这也是类型声明的核心作用：<strong>将类型独立于 <code>.js</code> 文件进行存储</strong>。别人在使用你的代码时，就能够获得这些额外的类型信息。同时，如果你在使用别人没有携带类型声明的 <code>.js</code> 文件，也可以通过类型声明进行类型补全，我们在后面还会了解更多。</p><p>接下来，我们要学习如何通过 TypeScript 类型声明的能力，让项目中的类型覆盖更加完整。</p><h2 id="让类型定义全面覆盖你的项目"><a href="#让类型定义全面覆盖你的项目" class="headerlink" title="让类型定义全面覆盖你的项目"></a>让类型定义全面覆盖你的项目</h2><p>在开始学习下面的内容前，不妨先想想你是否遇到过这么几个场景？</p><ul><li>想要使用一个 npm 包，但它发布的时间太早，根本没有携带类型定义，于是你的项目里就出现了这么一处没有被类型覆盖的地方。</li><li>你想要在代码里导入一些非代码文件，反正 Webpack 会帮你处理，但是可恶的 TS 又报错了？</li><li>这个项目在运行时动态注入了一些全局变量（如 <code>window.errorReporter</code>），你想要在代码里直接这样访问，却发现类型又报错了…</li></ul><p>这些问题都可以通过类型声明来解决，这也是它的核心能力：<strong>通过额外的类型声明文件，在核心代码文件以外去提供对类型的进一步补全</strong>。类型声明文件，即 <code>.d.ts</code> 结尾的文件，它会自动地被 TS 加载到环境中，实现对应部分代码的类型补全。</p><p>声明文件中并不包含实际的代码逻辑，它做的事只有一件：<strong>为 TypeScript 类型检查与推导提供额外的类型信息</strong>，而使用的语法仍然是 TypeScript 的 declare 关键字，只不过现在我们要进一步学习其它打开方式了。</p><p>要详细学习声明文件与 declare 关键字，我们不妨先来看看如何解决上面的问题。首先是无类型定义的 npm 包，我们可以通过 declare module 的方式来提供其类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> foo <span class="token keyword">from</span> <span class="token string">'pkg'</span><span class="token keyword">const</span> res <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的 pkg 是一个没有类型定义的 npm 包（实际并不存在），我们来看如何为它添加类型提示。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'pkg'</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">boolean</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在我们的 res 就具有了 boolean 类型！<code>declare module &#39;pkg&#39;</code> 会为默认导入 <code>foo</code> 添加一个具有 handler 的类型，虽然这里的 <code>pkg</code> 根本不存在。我们也可以在 <code>declare module</code> 中使用默认导出：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'pkg2'</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">boolean</span>  <span class="token keyword">export</span> <span class="token keyword">default</span> handler<span class="token punctuation">&#125;</span><span class="token keyword">import</span> bar <span class="token keyword">from</span> <span class="token string">'pkg2'</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在 <code>&#39;pkg&#39;</code> 的类型声明中，你也可以使用 <code>export const</code> ，效果是一致的，但由于对 <code>&#39;pkg2&#39;</code> 我们使用了默认导入，因此必须要有一个 <code>export default</code>。</p></blockquote><p>除了为缺失类型的模块声明类型以外，使用类型声明我们还可以为非代码文件，如图片、CSS 文件等声明类型。</p><p>对于非代码文件，比如说 markdown 文件，假设我们希望导入一个 <code>.md</code> 文件，由于其本质和 npm 包一样是一条导入语句，因此我们可以类似地使用 declare module 语法：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// index.ts</span><span class="token keyword">import</span> raw <span class="token keyword">from</span> <span class="token string">'./note.md'</span><span class="token keyword">const</span> content <span class="token operator">=</span> raw<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'NOTE'</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">NOTE</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token comment">// declare.d.ts</span><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'*.md'</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> raw<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token keyword">export</span> <span class="token keyword">default</span> raw<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于非代码文件的导入，更常见的其实是 <code>.css</code>、<code>.module.css</code>、<code>.png</code> 这一类，但基本语法都相似，我们在后面还会见到更多。</p><p>总结一下，<code>declare module</code> 通常用于为没有提供类型定义的库进行类型的补全，以及为非代码文件提供基本类型定义。但在实际使用中，如果一个库没有内置类型定义，TypeScript 也会提示你，是否要安装 <code>@types/xxx</code> 这样的包。那这个包又是什么？</p><h3 id="DefinitelyTyped"><a href="#DefinitelyTyped" class="headerlink" title="DefinitelyTyped"></a>DefinitelyTyped</h3><p>简单来说，<code>@types/</code> 开头的这一类 npm 包均属于 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FDefinitelyTyped%2FDefinitelyTyped">DefinitelyTyped</a> ，它是 TypeScript 维护的，专用于为社区存在的<strong>无类型定义的 JavaScript 库</strong>添加类型支持，常见的有 <code>@types/react</code> <code>@types/lodash</code> 等等。通过 DefinitelyTyped 来提供类型定义的包常见的有几种情况，如 Lodash 这样的库仍然有大量 JavaScript 项目使用，将类型定义内置在里面不一定是所有人都需要的，反而会影响包的体积。还有像 React 这种不是用纯 JavaScript / TypeScript 书写的库，需要自己来手写类型声明（React 是用 Flow 写的，这是一门同样为 JavaScript 添加类型的语言，或者说语法）。</p><p>举例来说，只要你安装了 <code>@types/react</code>，TypeScript 会自动将其加载到环境中（实际上所有 <code>@types/</code> 下的包都会自动被加载），并作为 react 模块内部 API 的声明。但这些类型定义并不一定都是通过 <code>declare module</code>，我们下面介绍的命名空间 namespace 其实也可以实现一样的能力。</p><p>先来看 <code>@types/node</code> 中与 <code>@types/react</code> 中分别是如何进行类型声明的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// @types/node</span><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'fs'</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token comment">/** 省略 */</span><span class="token punctuation">)</span><span class="token operator">:</span> Buffer<span class="token punctuation">&#125;</span><span class="token comment">// @types/react</span><span class="token keyword">declare</span> <span class="token keyword">namespace</span> React <span class="token punctuation">&#123;</span>  <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">,</span> Dispatch<span class="token operator">&lt;</span>SetStateAction<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">>></span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，<code>@types/node</code> 中仍然使用 <code>declare module</code> 的方式为 <code>fs</code> 这个内置模块声明了类型，而 <code>@types/react</code> 则使用的是我们没见过的 <code>declare namespace</code> 。别担心，我们会在后面详细介绍。</p><p>回到上面的最后一个问题，如果第三方库并不是通过导出来使用，而是直接在全局注入了变量，如 CDN 引入与某些监控埋点 SDK 的引入，我们需要通过 <code>window.xxx</code> 的方式访问，而类型声明很显然并不存在。此时我们仍然可以通过类型声明，但不再是通过 <code>declare module</code> 了。</p><h3 id="扩展已有的类型定义"><a href="#扩展已有的类型定义" class="headerlink" title="扩展已有的类型定义"></a>扩展已有的类型定义</h3><p>对全局变量的声明，还是以 window 为例，实际上我们如果 Ctrl + 点击代码中的 window，会发现它已经有类型声明了：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">var</span> window<span class="token operator">:</span> Window <span class="token operator">&amp;</span> <span class="token keyword">typeof</span> globalThis<span class="token keyword">interface</span> <span class="token class-name">Window</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这行代码来自于 <code>lib.dom.d.ts</code> 文件，它定义了对浏览器文档对象模型的类型声明，这就是 TypeScript 提供的内置类型，也是“出厂自带”的类型检查能力的依据。类似的，还有内置的 <code>lib.es2021.d.ts</code> 这种文件定义了对 ECMAScript 每个版本的类型声明新增或改动等等。</p><p>我们要做的，实际上就是在内置类型声明的基础之上，再新增一部分属性。而别忘了，在 JavaScript 中当你访问全局变量时，是可以直接忽略 <code>window</code> 的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>反过来，在类型声明中，如果我们直接声明一个变量，那就相当于将它声明在了全局空间中：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 类型声明</span><span class="token keyword">declare</span> <span class="token keyword">const</span> <span class="token function-variable function">errorReporter</span><span class="token operator">:</span> <span class="token punctuation">(</span>err<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token comment">// 实际使用</span><span class="token function">errorReporter</span><span class="token punctuation">(</span><span class="token string">'err!'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而如果我们就是想将它显式的添加到已有的 <code>Window</code> 接口中呢？在接口一节中我们其实已经了解到，如果你有多个同名接口，那么<strong>这些接口实际上是会被合并的</strong>，这一特性在类型声明中也是如此。因此，我们再声明一个 Window 接口即可：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Window</span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">userTracker</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">&#125;</span>window<span class="token punctuation">.</span><span class="token function">userTracker</span><span class="token punctuation">(</span><span class="token string">'click!'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似的，我们也可以扩展来自 <code>@types/</code> 包的类型定义：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'fs'</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">bump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">&#125;</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> bump <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'fs'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结一下这两个部分，TypeScript 通过 DefinitelyTyped ，也就是 <code>@types/</code> 系列的 npm 包来为无类型定义的 JavaScript npm 包提供类型支持，这些类型定义 的 npm 包内部其实就是数个 <code>.d.ts</code> 这样的声明文件。</p><p>而这些声明文件主要通过 declare / namespace 的语法进行类型的描述，我们可以通过项目内额外的声明文件，来实现为非代码文件的导入，或者是全局变量添加上类型声明。而对于多个类型声明文件，如果我们想复用某一个已定义的类型呢？此时三斜线指令就该登场了。</p><h2 id="三斜线指令"><a href="#三斜线指令" class="headerlink" title="三斜线指令"></a>三斜线指令</h2><p>三斜线指令就像是声明文件中的导入语句一样，它的作用就是<strong>声明当前的文件依赖的其他类型声明</strong>。而这里的“其他类型声明”包括了 TS 内置类型声明（<code>lib.d.ts</code>）、三方库的类型声明以及你自己提供的类型声明文件等。</p><p>三斜线指令本质上就是一个自闭合的 XML 标签，其语法大致如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">/// &lt;reference path="./other.d.ts" /></span><span class="token comment">/// &lt;reference types="node" /></span><span class="token comment">/// &lt;reference lib="dom" /></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>需要注意的是，三斜线指令必须被放置在文件的顶部才能生效</strong>。</p><p>这里的三条指令作用其实都是声明当前文件依赖的外部类型声明，只不过使用的方式不同：分别使用了 path、types、lib 这三个不同属性，我们来依次解析。</p><p>使用 path 的 reference 指令，其 path 属性的值为一个相对路径，指向你项目内的其他声明文件。而在编译时，TS 会沿着 path 指定的路径不断深入寻找，最深的那个没有其他依赖的声明文件会被最先加载。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// @types/node 中的示例</span><span class="token comment">/// &lt;reference path="fs.d.ts" /></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用 types 的 reference 指令，其 types 的值是一个包名，也就是你想引入的 <code>@types/</code> 声明，如上面的例子中我们实际上是在声明当前文件对 <code>@types/node</code> 的依赖。而如果你的代码文件（<code>.ts</code>）中声明了对某一个包的类型导入，那么在编译产生的声明文件（<code>.d.ts</code>）中会自动包含引用它的指令。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">/// &lt;reference types="node" /></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 lib 的 reference 指令类似于 types，只不过这里 lib 导入的是 TypeScript 内置的类型声明，如下面的例子我们声明了对 <code>lib.dom.d.ts</code> 的依赖：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// vite/client.d.ts</span><span class="token comment">/// &lt;reference lib="dom" /></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而如果我们使用 <code>/// &lt;reference lib=&quot;esnext.promise&quot; /&gt;</code>，那么将依赖的就是 <code>lib.esnext.promise.d.ts</code> 文件。</p><p>这三种指令的目的都是引入当前文件所依赖的其他类型声明，只不过适用场景不同而已。</p><p>如果说三斜线指令的作用就像导入语句一样，那么命名空间（namespace）就像一个模块文件一样，将一组强相关的逻辑收拢到一个命名空间内部。</p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>假设一个场景，我们的项目里需要接入多个平台的支付 SDK，最开始只有微信支付和支付宝：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">WeChatPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">ALiPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后又多了美团支付、虚拟货币支付（比如 Q 币）、信用卡支付等等：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">WeChatPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">ALiPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">MeiTuanPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">CreditCardPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">QQCoinPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>随着业务的不断发展，项目中可能需要引入越来越多的支付 SDK，甚至还有比特币和以太坊，此时将这些所有的支付都放在一个文件内未免过于杂乱了。这些支付方式其实大致可以分成两种：现实货币与虚拟货币。此时我们就可以使用命名空间来区分这两类 SDK：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">namespace</span> RealCurrency <span class="token punctuation">&#123;</span>  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">WeChatPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ALiPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">MeiTuanPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CreditCardPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">namespace</span> VirtualCurrency <span class="token punctuation">&#123;</span>  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">QQCoinPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">BitCoinPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ETHPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，这里的代码是在 <code>.ts</code> 文件中的，此时它是具有实际逻辑意义的，也不能和类型混作一谈。</p></blockquote><p>而命名空间的使用类似于枚举：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> weChatPaySDK <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealCurrency</span><span class="token punctuation">.</span><span class="token function">WeChatPaySDK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>唯一需要注意的是，命名空间内部实际上就像是一个独立的代码文件，因此其中的变量需要导出以后，才能通过 <code>RealCurrency.WeChatPaySDK</code> 这样的形式访问。</p><p>如果你开始学习前端的时间较早，一定会觉得命名空间的编译产物很眼熟——它就像是上古时期里使用的伪模块化方案：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">var</span> RealCurrency<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">RealCurrency</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">class</span> <span class="token class-name">WeChatPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  RealCurrency<span class="token punctuation">.</span>WeChatPaySDK <span class="token operator">=</span> WeChatPaySDK  <span class="token keyword">class</span> <span class="token class-name">ALiPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  RealCurrency<span class="token punctuation">.</span>ALiPaySDK <span class="token operator">=</span> ALiPaySDK  <span class="token keyword">class</span> <span class="token class-name">MeiTuanPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  RealCurrency<span class="token punctuation">.</span>MeiTuanPaySDK <span class="token operator">=</span> MeiTuanPaySDK  <span class="token keyword">class</span> <span class="token class-name">CreditCardPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  RealCurrency<span class="token punctuation">.</span>CreditCardPaySDK <span class="token operator">=</span> CreditCardPaySDK<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span>RealCurrency <span class="token operator">||</span> <span class="token punctuation">(</span>RealCurrency <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，命名空间的作用也正是实现简单的模块化功能，在 TypeScript 中引入它时（<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Frelease-notes%2Ftypescript-1-5.html%23namespace-keyword">1.5 版本</a>），前端的模块化方案还处于混沌时期。</p><p>命名空间的内部还可以再嵌套命名空间，比如在虚拟货币中再新增区块链货币一类，此时嵌套的命名空间也需要被导出：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">namespace</span> VirtualCurrency <span class="token punctuation">&#123;</span>  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">QQCoinPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">export</span> <span class="token keyword">namespace</span> BlockChainCurrency <span class="token punctuation">&#123;</span>    <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">BitCoinPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ETHPaySDK</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> ethPaySDK <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VirtualCurrency</span><span class="token punctuation">.</span>BlockChainCurrency<span class="token punctuation">.</span><span class="token function">ETHPaySDK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似于类型声明中的同名接口合并，命名空间也可以进行合并，但需要通过三斜线指令来声明导入。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// animal.ts</span><span class="token keyword">namespace</span> Animal <span class="token punctuation">&#123;</span>  <span class="token keyword">export</span> <span class="token keyword">namespace</span> ProtectedAnimals <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// dog.ts</span><span class="token comment">/// &lt;reference path="animal.ts" /></span><span class="token keyword">namespace</span> Animal <span class="token punctuation">&#123;</span>  <span class="token keyword">export</span> <span class="token keyword">namespace</span> Dog <span class="token punctuation">&#123;</span>    <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// corgi.ts</span><span class="token comment">/// &lt;reference path="dog.ts" /></span><span class="token keyword">namespace</span> Animal <span class="token punctuation">&#123;</span>  <span class="token keyword">export</span> <span class="token keyword">namespace</span> Dog <span class="token punctuation">&#123;</span>    <span class="token keyword">export</span> <span class="token keyword">namespace</span> Corgi <span class="token punctuation">&#123;</span>      <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">corgiBark</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际使用时需要导入全部的依赖文件：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">/// &lt;reference path="animal.ts" /></span><span class="token comment">/// &lt;reference path="dog.ts" /></span><span class="token comment">/// &lt;reference path="corgi.ts" /></span>Animal<span class="token punctuation">.</span>Dog<span class="token punctuation">.</span>Corgi<span class="token punctuation">.</span><span class="token function">corgiBark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了在 <code>.ts</code> 文件中使用以外，命名空间也可以在声明文件中使用，即 <code>declare namespace</code>：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">namespace</span> Animal <span class="token punctuation">&#123;</span>  <span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">Dog</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">Cat</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">declare</span> <span class="token keyword">let</span> dog<span class="token operator">:</span> Animal<span class="token punctuation">.</span>Dog<span class="token keyword">declare</span> <span class="token keyword">let</span> cat<span class="token operator">:</span> Animal<span class="token punctuation">.</span>Cat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但如果你在 <code>@types/</code> 系列的包下，想要通过 namespace 进行模块的声明，还需要注意将其导出，然后才会加载到对应的模块下。以 <code>@types/react</code> 为例：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token operator">=</span> React<span class="token keyword">export</span> <span class="token keyword">as</span> <span class="token keyword">namespace</span> React<span class="token keyword">declare</span> <span class="token keyword">namespace</span> React <span class="token punctuation">&#123;</span>  <span class="token comment">// 省略了不必要的类型标注</span>  <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>initialState<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先我们声明了一个命名空间 React，然后使用 <code>export = React</code> 将它导出了，这样我们就能够在从 react 中导入方法时，获得命名空间内部的类型声明，如 useState。</p><p>从这一个角度来看，<code>declare namespace</code> 其实就类似于普通的 <code>declare</code> 语法，只是内部的类型我们不再需要使用 <code>declare</code> 关键字（比如我们直接在 namespace 内部 <code>function useState(): []</code> 即可）。</p><p>而还有一行 <code>export as namespace React</code> ，它的作用是在启用了 <code>--allowUmdGlobalAccess</code> 配置的情况下，允许将这个模块作为全局变量使用（也就是不导入直接使用），这一特性同样也适用于通过 CDN 资源导入模块时的变量类型声明。</p><p>除了这两处 namespace 使用，React 中还利用 namespace 合并的特性，在全局的命名空间中注入了一些类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> global <span class="token punctuation">&#123;</span>  <span class="token keyword">namespace</span> <span class="token constant">JSX</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">interface</span> <span class="token class-name">Element</span> <span class="token keyword">extends</span> <span class="token class-name">React</span><span class="token punctuation">.</span>ReactElement<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这也是为什么我们可以在全局使用 <code>JSX.Element</code> 作为类型标注。</p><p>除了类型声明中的导入——三斜线指令，以及类型声明中的模块——命名空间以外，TypeScript 还允许你将这些类型去导入到代码文件中。</p><h2 id="仅类型导入"><a href="#仅类型导入" class="headerlink" title="仅类型导入"></a>仅类型导入</h2><p>在 TypeScript 中，当我们导入一个类型时其实并不需要额外的操作，和导入一个实际值是完全一样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// foo.ts</span><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">Foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">FooType</span> <span class="token operator">=</span> <span class="token builtin">any</span><span class="token comment">// index.ts</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Foo<span class="token punctuation">,</span> FooType <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./foo'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然类型导入和值导入存在于同一条导入语句中，在编译后的 JS 代码里还是只会有值导入存在，同时在编译的过程中，值与类型所在的内存空间也是分开的。</p><p>在这里我们只能通过名称来区分值和类型，但为每一个类型都加一个 Type 后缀也太奇怪了。实际上，我们可以更好地区分值导入和类型导入，只需要通过 <code>import type</code> 语法即可：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Foo <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./foo'</span><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> FooType <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./foo'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样会造成导入语句数量激增，如果你想同时保持较少的导入语句数量又想区分值和类型导入，也可以使用同一导入语句内的方式（需要 4.6 版本以后才支持）：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Foo<span class="token punctuation">,</span> <span class="token keyword">type</span> <span class="token class-name">FooType</span> <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./foo'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这实际上是我个人编码习惯的一部分，即<strong>对导入语句块的规范整理</strong>。在大型项目中一个文件顶部有几十条导入语句是非常常见的，它们可能来自第三方库、UI 库、项目内工具方法、样式文件、类型，项目内工具方法可能又分成 constants、hooks、utils、config 等等。如果将这些所有类型的导入都混乱地堆放在一起，对于后续的维护无疑是灾难。因此，我通常会将这些导入按照实际意义进行组织，顺序大致是这样：</p><ul><li>一般最上面会是 React；</li><li>第三方 UI 组件，然后是项目内封装的其他组件；</li><li>第三方工具库，然后是项目内封装的工具方法，具体 hooks 和 utils 等分类的顺序可以按照自己偏好来；</li><li>类型导入，包括第三方库的类型导入、项目内的类型导入等；</li><li>样式文件，<code>CSS-IN-JS</code> 方案的组件应该被放在第二条中其他组件部分。</li></ul><p>示例如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useEffect <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Button<span class="token punctuation">,</span> Dialog <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'ui'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ChildComp <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./child'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> store <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@/store'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useCookie <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@/hooks/useCookie'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> <span class="token constant">SOME_CONSTANTS</span> <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@/utils/constants'</span><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> <span class="token constant">FC</span> <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> Foo <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@/typings/foo'</span><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> Shared <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@/typings/shared'</span><span class="token keyword">import</span> styles <span class="token keyword">from</span> <span class="token string">'./index.module.scss'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节，我们主要了解了 TypeScript 在工程层面的基础能力，包括<strong>类型指令</strong>、<strong>类型声明</strong>、<strong>命名空间</strong>三个部分。</p><p>类型声明相关的能力几乎是所有规模的工程都会使用到的（你总会遇到没有提供类型定义的库吧），通过大量的额外类型声明我们可以实现更复杂、更准确的类型保护，以及为上古时期的 JavaScript npm 包提供类型定义，即 DefinitelyTyped。但类型指令却相反，它绝对不应该被滥用，无论是相当于后门的 <code>ts-ignore</code> 还是稍显安全的 <code>ts-expect-error</code> 。我们会在后面介绍如何通过 ESLint 规则来进行对应地约束。</p><p>而三斜线指令与命名空间这两个概念，虽然已经不再被大量使用，但了解它们诞生与存在的意义同样对理解整个 TypeScript 工程能力很有帮助。在下一节，我们还会与三斜线指令再次碰面。</p><p>无论你是在将 TypeScript 集成到什么框架或者工具里，其实你在做的只是一件事，那就是<strong>类型，类型，类型！</strong>。包括我们在下一节所要学习的 React 与 TypeScript 结合实战，其实本质上也是在学习如何让你的 React 组件也拥有可靠的类型支持。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="通过-JSDoc-在-JS-文件中获得类型提示"><a href="#通过-JSDoc-在-JS-文件中获得类型提示" class="headerlink" title="通过 JSDoc 在 JS 文件中获得类型提示"></a>通过 JSDoc 在 JS 文件中获得类型提示</h3><p>在上面我们提到了可以在 JS 文件中通过 JSDoc 来标注变量类型，而既然有了类型标注，那么自然也能享受到像 TS 文件中一样的类型提示了。但这里我们需要使用更强大一些的 JSDoc 能力：在 <code>@type &#123;&#125;</code> 中使用导入语句！</p><p>以拥有海量配置项的 Webpack 为例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">/** @type &#123;import("webpack").Configuration&#125; */</span><span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此时你会发现已经拥有了如臂使指的类型提示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3074e724e8ef48f9ba02fae7e2c70b71~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>类似的，也可以直接进行导出：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token comment">/** @type &#123; import('webpack').Configuration &#125; */</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然，Webpack 本身也支持通过 ts 文件进行配置，在使用 TS 进行配置时，一种方式是简单地使用它提供的类型作为一个对象的标注。而目前更常见的一种方式其实是框架内部提供 <code>defineConfig</code> 这样的方法，让你能直接获得类型提示，如 Vite 中的做法：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> defineConfig <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vite'</span><span class="token keyword">import</span> react <span class="token keyword">from</span> <span class="token string">'@vitejs/plugin-react'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">react</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.工欲善其事：打造最舒适的 TypeScript 开发环境</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/2.%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%EF%BC%9A%E6%89%93%E9%80%A0%E6%9C%80%E8%88%92%E9%80%82%E7%9A%84%20TypeScript%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/2.%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%EF%BC%9A%E6%89%93%E9%80%A0%E6%9C%80%E8%88%92%E9%80%82%E7%9A%84%20TypeScript%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>在正式开始小册的学习前，我们还有一件事要做，那就是搭建 TypeScript 的开发环境。一个舒适、便捷且顺手的开发环境，不仅能大大提高学习效率，也会对我们日常的开发工作有很大帮助。</p><p>这一节我们就来介绍 VS Code 下的 TypeScript 环境搭建：插件以及配置项。对于 TS 文件的执行，我们会介绍 ts-node、ts-node-dev 等工具，帮助你快速验证 TS 代码的执行结果。而如果你只想快速开始学习，我们也会介绍 TypeScript 官方提供的 TypeScript Playground，利用它你可以快速开始编写及分享 TS 代码。最后，我们还会介绍如何通过 TS 声明的方式来检查类型兼容性。</p><p>话不多说，我们快点开始吧~</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F00-starter">Starter</a></p></blockquote><h2 id="VS-Code-配置与插件"><a href="#VS-Code-配置与插件" class="headerlink" title="VS Code 配置与插件"></a>VS Code 配置与插件</h2><p>VS Code 本身就是由 TypeScript 编写的，因此它对 TypeScript 有着非常全面的支持，包括类型检查、补全等功能，我们需要的两个 TS 插件都来自于社区，这两个插件分别提供了<strong>类型的自动导入</strong>，和<strong>快速移动 TypeScript 文件</strong>的能力。</p><p>首先是 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3Dpmneo.tsimporter">TypeScript Importer</a> 。这一插件会收集你项目内所有的类型定义，在你敲出<code>:</code>时提供这些类型来进行补全。如果你选择了一个，它还会自动帮你把这个类型导入进来。效果如图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1d8491139134f64a8463cae3efe2e0a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>这一功能在日常开发中真得非常非常好用，尤其是当项目里有数百个声明分散在各个文件中时。</p><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3Dstringham.move-ts">Move TS</a>，这一插件在重构以及像我们这样写 demo 的场景下很有帮助。它可以让你通过编辑文件的路径，直接修改项目的目录结构。比如从<code>home/project/learn-interface.ts</code> 修改成 <code>home/project/interface-notes/interface-extend.ts</code>，这个插件会自动帮你把文件目录更改到对应的样子，并且更新其他文件中对这一文件的导入语句。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/709297374052475aac0899feeb6f3db7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="usage.gif"></p><p>当然，对于 VS Code 内置的 TypeScript 支持，我们也可以通过一些配置项获得更好的开发体验。首先，你需要通过 Ctrl(Command) + Shift + P 打开命令面板，找到「打开工作区设置」这一项。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9f29717e89747858ffd9bdf9a23a6a4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="open setting"></p><p>然后，在打开的设置中输入 typescript，筛选出所有 TypeScript 有关的配置，点击左侧的”TypeScript”，这里才是官方内置的配置。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b52df396bc824134a1baed397c11d328~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>我们需要做的就是开启一些代码提示功能（hints），我们知道 TS 能够在很多地方进行类型地自动推导，但你往往要把鼠标悬浮在代码上才能看到推导得到的类型，其实我们可以通过配置将这些推导类型显示出来：</p><p>在前面配置搜索处，搜索 ‘typescript Inlay Hints’，展示的配置就都是提示相关的了，推荐开启的有这么几个：</p><ul><li>Function Like Return Types，显示推导得到的函数返回值类型；</li><li>Parameter Names，显示函数入参的名称；</li><li>Parameter Types，显示函数入参的类型；</li><li>Variable Types，显示变量的类型。</li></ul><p>以上选项开启后的效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09e04fa5fc3848f091c1f8239e5e8ca7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="eg"></p><p>当然，并不是所有人都习惯这样的显示方式，你可以根据自己的需要进行调整。除了这些提示的配置以外，VS Code 还支持了百余项 TS 配置，你可以看看是否有你需要的配置。</p><h3 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h3><p>除了 TS 强相关的插件与配置，还有一些额外的、能提升你学习效率的插件，你可以依据自己的喜好进行添加，以下的插件列表将会不定期进行更新。</p><ul><li><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DPhilHindle.errorlens">ErrorLens</a>，这一插件能够把你的 VS Code 底部问题栏的错误下直接显示到代码文件中的对应位置，比如这样：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b16f1d32b46c45778beeafc3b8efdefe~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p></li></ul><h2 id="Playground：懒人福音"><a href="#Playground：懒人福音" class="headerlink" title="Playground：懒人福音"></a>Playground：懒人福音</h2><p>如果你只是想拥有一个简单的环境，能写 TypeScript，能检查错误，能快速地调整 tsconfig，那官方提供的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.typescriptlang.org%2Fzh%2Fplay">Playground</a> 一定能满足你的需求。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/639fab7a1fc9437580d541f3d9819160~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>你可以在这里编写 TS 代码，快速查看编译后的 JS 代码与声明文件，还可以通过 Shift + Enter 来执行 TS 文件。可以说，如果不需要 VS Code 更强大的提示能力与一些特殊插件、主题等，Demo 学习使用 Playground 真的够够的了。</p><p>Playground 最强大的能力其实在于，支持非常简单的配置切换，如 TS 版本（左上角 ），以及通过可视化的方式配置 tsconfig （左上角的配置）等，非常适合在这里研究 tsconfig 各项配置的作用。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c402069d1bc541398e4c6d24571d453b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h2 id="TS-文件的快速执行：ts-node-与-ts-node-dev"><a href="#TS-文件的快速执行：ts-node-与-ts-node-dev" class="headerlink" title="TS 文件的快速执行：ts-node 与 ts-node-dev"></a>TS 文件的快速执行：ts-node 与 ts-node-dev</h2><p>当然，如果你主要是想执行 TypeScript 文件，就像 <code>node index.js</code> 这样快速地验证代码逻辑，这个时候你就需要 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FTypeStrong%2Fts-node">ts-node</a> 以及 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwclr%2Fts-node-dev">ts-node-dev</a> 这一类工具了。它们能直接执行 ts 文件，并且支持监听文件重新执行。同时，它们也支持跳过类型检查这一步骤来获得更快的执行体验。</p><p>对于 ts-node，你可以将其安装到项目本地或直接全局安装，我个人更推荐安装到全局然后配置 alias 快速启动，像 <code>tsn index.ts</code> 这样。执行以下命令将 ts-node 与 typescript 安装到全局：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> i ts-node typescript <span class="token parameter variable">-g</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，在项目中执行以下命令创建 TypeScript 的项目配置文件： tsconfig.json。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">npx typescript <span class="token operator">--</span>init<span class="token comment">// 如果全局安装了 TypeScript，可以这么做</span>tsc <span class="token operator">--</span>init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接着，创建一个 TS 文件：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello TypeScript'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再使用 ts-node 执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ts-node index.ts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果一切正常，此时你的终端能够正确地输出字符。ts-node 可以通过两种方式进行配置，在 tsconfig 中新增 <code>&#39;ts-node&#39;</code> 字段，或在执行 ts-node 时作为命令行的参数，这里我们主要介绍通过命令行进行常用配置的方式。</p><ul><li><code>-P,--project</code>：指定你的 tsconfig 文件位置。默认情况下 ts-node 会查找项目下的 tsconfig.json 文件，如果你的配置文件是 <code>tsconfig.script.json</code>、<code>tsconfig.base.json</code> 这种，就需要使用这一参数来进行配置了。</li><li><code>-T, --transpileOnly</code>：禁用掉执行过程中的类型检查过程，这能让你的文件执行速度更快，且不会被类型报错卡住。这一选项的实质是使用了 TypeScript Compiler API 中的 transpileModule 方法，我们会在后面的章节详细讲解。</li><li><code>--swc</code>：在 transpileOnly 的基础上，还会使用 swc 来进行文件的编译，进一步提升执行速度。</li><li><code>--emit</code>：如果你不仅是想要执行，还想顺便查看下产物，可以使用这一选项来把编译产物输出到 <code>.ts-node</code> 文件夹下（需要同时与 <code>--compilerHost</code> 选项一同使用）。</li></ul><p>除了直接使用 ts-node 以外，你也可以通过 node + require hook 的形式来执行 TS 文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">node</span> <span class="token parameter variable">-r</span> ts-node/register index.ts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但此时，如果想要传递参数给 ts-node ，你就需要使用环境变量了，比如要传递之前的 transpileOnly 选项：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">TS_NODE_TRANSPILE_ONLY</span><span class="token operator">=</span>true <span class="token function">node</span> <span class="token parameter variable">-r</span> ts-node/register index.ts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关于选项对应的环境变量，请参考 ts-node 的官方文档了解更多。</p><p>ts-node 本身并不支持自动地监听文件变更然后重新执行，而这一能力又是某些项目场景下的刚需，如 NodeJs API 的开发。因此，我们需要 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwclr%2Fts-node-dev">ts-node-dev</a> 库来实现这一能力。ts-node-dev 基于 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ffgnass%2Fnode-dev">node-dev</a>（你可以理解一个类似 nodemon 的库，提供监听文件重新执行的能力） 与 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FTypeStrong%2Fts-node">ts-node</a> 实现，并在重启文件进程时共享同一个 TS 编译进程，避免了每次重启时需要重新实例化编译进程等操作。</p><p>首先，我们还是在全局安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i ts-node-dev <span class="token parameter variable">-g</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ts-node-dev 在全局提供了 <code>tsnd</code> 这一简写，你可以运行 <code>tsnd</code> 来检查安装情况。最常见的使用命令是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ts-node-dev <span class="token parameter variable">--respawn</span> --transpile-only app.ts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>respawn 选项启用了监听重启的能力，而 transpileOnly 提供了更快的编译速度。你可以查看官方仓库来了解更多选项，但在大部分场景中以上这个命令已经足够了。</p><h2 id="更方便的类型兼容性检查"><a href="#更方便的类型兼容性检查" class="headerlink" title="更方便的类型兼容性检查"></a>更方便的类型兼容性检查</h2><p>某些时候，我们在进行类型比较时，需要使用一个具有具体类型的变量与一个类型进行赋值操作，比如下面这个例子中：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">Bar</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  job<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> foo<span class="token operator">:</span> Foo <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token string">'林不渡'</span><span class="token punctuation">,</span>  age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> bar<span class="token operator">:</span> Bar <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token string">'林不渡'</span><span class="token punctuation">,</span>  job<span class="token operator">:</span> <span class="token string">'fe'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span>foo <span class="token operator">=</span> bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在“只是想要进行类型比较”的前提下，其实并没有必要真的去声明两个变量，即涉及了值空间的操作。我们完全可以只在类型空间中（你可以理解为<strong>用于存放 TypeScript 类型信息的内存空间</strong>）比较这些类型，只需要使用 declare 关键字：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">Bar</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  job<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">declare</span> <span class="token keyword">let</span> foo<span class="token operator">:</span> Foo<span class="token keyword">declare</span> <span class="token keyword">let</span> bar<span class="token operator">:</span> Barfoo <span class="token operator">=</span> bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以理解为在开始时的例子，我们使用一个值空间存放这个变量具体的属性，一个类型空间存放这个变量的类型。而通过 declare 关键字，我们声明了一个仅在类型空间存在的变量，它在运行时完全不存在，这样就避免了略显繁琐的属性声明。</p><p>对于类型兼容的检查，除了两两声明然后进行赋值以外，我们还可以通过工具类型的形式，如 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ftsd">tsd</a> 这个 npm 包提供的一系列工具类型，能帮助你进行声明式的类型检查：：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> expectType <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'tsd'</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">)</span> <span class="token comment">// √</span><span class="token generic-function"><span class="token function">expectType</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">599</span><span class="token punctuation">)</span> <span class="token comment">// ×</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这一部分的内容并不是初学需要掌握的，但你可以选择提前用起来，不必急着去理解具体的实现原理。</p></blockquote><p>它的结构大致是这样：<code>expectType&lt;你预期的类型&gt;(表达式或变量等)</code>，除了 <code>expectType</code>（检查预期类型与表达式或变量的类型是否一致），tsd 还提供了 <code>expectNotType</code>（检查预期类型与表达式或变量的类型是否不同）、<code>expectAssignable</code>（检查表达式或变量的类型是否能赋值给预期类型）等工具类型，其中涉及工具类型与泛型的知识，我们会在后面的课程中一一讲解。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这一节中，我们主要了解了 TypeScript 开发环境的搭建，包括了 VS Code 的配置、插件，使用 Playground 作为一个简易又强大的临时编辑器，以及如何使用 ts-node 与 ts-node-dev 来快速执行你的 ts 文件。在最后，我们稍微提前了一些对后面学习大有裨益的知识，即通过类型声明（declare）与 tsd 来进行更方便的类型兼容性检查。</p><p>这些知识不仅仅只在这本小册的学习过程中起到作用，它们在未来实际项目开发中也是你的得力助手。本着磨刀不误砍柴工的原则，请务必搭建出你最舒适的 TypeScript 开发环境后，再开始这本小册的学习。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="require-extension"><a href="#require-extension" class="headerlink" title="require extension"></a>require extension</h3><p>我们知道，node 中最早使用的是 CommonJs 与 require 来进行模块的导入，除了 <code>.js</code> 文件的导入以外，node 中还支持以扩展的形式来提供自定义扩展名的模块加载机制，这也是 ts-node、<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40adonisjs%2Frequire-ts">require-ts</a> （允许你去 require 一个 TS 文件）这些工具库的工作原理，它们的核心逻辑其实都是通过 <code>require.extension</code>，注册了 <code>.ts</code> 文件的处理逻辑：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">require</span><span class="token punctuation">.</span>extenstions<span class="token punctuation">[</span><span class="token string">'.ts'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>module<span class="token punctuation">,</span> filename<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> content <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span>  module<span class="token punctuation">.</span><span class="token function">_compile</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 require-ts 中，使用了 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fpirates">pirates</a> 这个库来简化注册逻辑：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> compiler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Compiler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">addHook</span><span class="token punctuation">(</span>  <span class="token punctuation">(</span>code<span class="token punctuation">,</span> filename<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> compiler<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> code<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span> exts<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'.ts'</span><span class="token punctuation">,</span> <span class="token string">'.tsx'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function-variable function">matcher</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NodeJs 中的 require 逻辑执行大概是这样的：</p><ul><li>Resolution，基于入参拼接出 require 文件的绝对路径，当路径中不包含后缀名时，会按照 node 的模块解析策略来进行处理，如 <code>require(&#39;./utils&#39;)</code> 会解析到 <code>PATH/TO/project/utils.js</code>，而 <code>require(&#39;project-utils&#39;)</code> 会解析到 <code>PATH/TO/project/node_modules/project-utils/src/index.js</code>，以及内置模块等。需要注意的是在浏览器中，require <strong>需要带上完整的后缀名</strong>（浏览器并不能查找服务器的文件），但一般 bundler 会帮你处理好。</li><li>基于绝对路径，去 <code>require.cache</code> 这个全局变量中，查找此文件是否已经已缓存，并在存在时直接使用缓存的文件内容（即这个文件的导出信息等）。</li><li>Loading，基于绝对路径实例化一个 Module 类实例，基于路径后缀名调用内置的处理函数。比如 js、json 文件都是通过 <code>fs.readFileSync</code> 读取文件内容。</li><li>Wrapping，对于 js 文件，将文件内容字符串外层包裹一个函数，执行这个函数。对于 Json 文件，将内容包裹挂载到 <code>module.exports</code> 下。</li><li>Evaluating，执行这个文件内容。</li><li>Caching，对于未曾缓存的文件，将其执行结果缓存起来。</li></ul><p>在上述过程中进行操作拦截，就可以实现很多有用的功能。比如对 <code>.ts</code> 文件去注册自定义的处理函数，将其编译为可以直接执行的 js 代码（<code>ts-node/register</code>），对 <code>.js</code> 代码进行预处理（babel-register），在代码执行时进行覆盖率统计（istanbul）。以及，对 <code>require.cache</code> 进行缓存清除来实现 node 服务的热更新（decache），但这里涉及到 require cache 的缓存策略，与本小册的主题没有太大关联，就不做展开啦。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/22.%E8%AE%A9%20ESLint%20%E6%9D%A5%E7%BA%A6%E6%9D%9F%E4%BD%A0%E7%9A%84%20TypeScript%20%E4%BB%A3%E7%A0%81%EF%BC%9A%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%A7%84%E5%88%99%E9%9B%86%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/22.%E8%AE%A9%20ESLint%20%E6%9D%A5%E7%BA%A6%E6%9D%9F%E4%BD%A0%E7%9A%84%20TypeScript%20%E4%BB%A3%E7%A0%81%EF%BC%9A%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%A7%84%E5%88%99%E9%9B%86%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>关于 ESLint 是什么，我想应该没有过多介绍的必要，即使你没有主动了解过它，也一定被动接触过。它带给你的印象并不一定很好，有可能是满屏的红色波浪线，也可能是成千上万条的报错输出。但你可能也很享受经过 ESLint 检查与格式化后工工整整的代码，那简直叫一个赏心悦目。</p><p>对于 ESLint ，我认为它就是现代前端工程必备的一样工具，无论是简单的寥寥几行配置，还是精心挑选了最适合自己或者团队风格的规则集，它都是不可缺少的一环。ESLint 的作用其实可以划分为两个部分：<strong>风格统一</strong>与<strong>代码优化</strong>。</p><p>风格统一不必多说，单双引号、缩进、逗号等编码风格的统一十分有必要，看到一会单引号一会双引号的代码，很难不怀疑作者的代码水平。而代码优化则就是一个比较宽泛的概念了，它可以指<strong>让你的代码更简洁</strong>，比如不允许未使用的变量，也可以指<strong>让你的代码更严谨</strong>，比如不允许未声明的全局变量。很多人可能存在一个误区，即认为 ESLint 只会要求减少代码，但实际上在很多场景，尤其是在 TypeScript 场景下，很多时候 ESLint 反而会要求你写<strong>更多的代码</strong>，如要求你为函数的返回值显式声明类型等等。</p><p>实际上，这也是 Lint 工具的核心功能，我们后面会介绍的 Prettier 也是（但 Prettier 只关心风格统一部分），我们希望通过一种<strong>自动化的、存在确定规范</strong>的方式，来提升项目中的代码质量。接下来，我们会了解如何配置 ESLint，如何进一步提升工程的约束能力，以及 TypeScript ESLint 下的规则集介绍。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Fblob%2Fmain%2Fpackages%2F19-eslint-config-ts-ruleset%2Findex.js">ESLint Ruleset</a></p></blockquote><h2 id="基本的-ESLint-配置"><a href="#基本的-ESLint-配置" class="headerlink" title="基本的 ESLint 配置"></a>基本的 ESLint 配置</h2><p>最简单的方式就是通过 ESLint 自带的初始化功能，然后回答一系列问题即可。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npx eslint <span class="token parameter variable">--init</span><span class="token function">npm</span> init @eslint/config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35a35cdc4e764431aa795f61c8a8d8e9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>如果你选择了使用 TypeScript，它会自动为你安装 <code>@typescript-eslint/</code> 一系列工具。比如上面我们最终安装了这些依赖：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/383031f761d94c568f24921e5b138809~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>对于已有 ESLint 配置的项目，如果要配置 TypeScript ESLint 其实也很简单，安装以下依赖：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i @typescript-eslint/eslint-plugin @typescript-eslint/parser --save-dev<span class="token function">yarn</span> <span class="token function">add</span> @typescript-eslint/eslint-plugin @typescript-eslint/parser --save-dev<span class="token function">pnpm</span> i @typescript-eslint/eslint-plugin @typescript-eslint/parser --save-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后更改你的 ESLint 配置：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  root<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  parser<span class="token operator">:</span> <span class="token string">'@typescript-eslint/parser'</span><span class="token punctuation">,</span>  plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'@typescript-eslint'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token keyword">extends</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token comment">// ...其他已有的配置</span>    <span class="token string">'plugin:@typescript-eslint/recommended'</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于部分 TS ESLint 的规则和 ESLint 中基础的规则有冲突，我们需要修改配置文件的规则，最终的基本示例如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">root</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token keyword">extends</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">'plugin:react/recommended'</span><span class="token punctuation">,</span>    <span class="token string">'plugin:@typescript-eslint/recommended'</span><span class="token punctuation">,</span>    <span class="token string">'prettier'</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token literal-property property">parser</span><span class="token operator">:</span> <span class="token string">'@typescript-eslint/parser'</span><span class="token punctuation">,</span>  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'react'</span><span class="token punctuation">,</span> <span class="token string">'@typescript-eslint'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token literal-property property">rules</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token string-property property">'react/react-in-jsx-scope'</span><span class="token operator">:</span> <span class="token string">'off'</span><span class="token punctuation">,</span>    <span class="token literal-property property">indent</span><span class="token operator">:</span> <span class="token string">'off'</span><span class="token punctuation">,</span>    <span class="token string-property property">'@typescript-eslint/indent'</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token literal-property property">quotes</span><span class="token operator">:</span> <span class="token string">'off'</span><span class="token punctuation">,</span>    <span class="token string-property property">'@typescript-eslint/quotes'</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token string">'single'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token literal-property property">semi</span><span class="token operator">:</span> <span class="token string">'off'</span><span class="token punctuation">,</span>    <span class="token string-property property">'@typescript-eslint/semi'</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'error'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">settings</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">react</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">version</span><span class="token operator">:</span> <span class="token string">'detect'</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Indent 这条规则有一个需要注意的地方，其配置项还可以是 <code>&#39;tab&#39;</code> <code>&#39;space&#39;</code> 等，如果你把上面的 2 改成 <code>&#39;tab&#39;</code>，大概率项目中会出现巨量报错，如 <em>Expected indentation of 1 tab but found 2 spaces</em>。这是因为 Tab 和 Space 并不是等价的，也和你的编辑器配置有关。而我们这里的 2 ，其具体意义为 2 spaces。</p></blockquote><p>完成配置后，我们需要确定接受 ESLint 检查的项目文件，我个人的习惯是只让 ESLint 检查核心代码文件，包括 js/jsx，ts/tsx 文件。因此我们需要忽略掉部分文件，创建 <code>.eslintignore</code> 文件：</p><pre class="line-numbers language-ini" data-language="ini"><code class="language-ini">*.json*.html*rc.js*.svg*.css<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 package.json 中的 scripts 中添加以下命令：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"eslint"</span><span class="token operator">:</span> <span class="token string">"eslint src/** --ext .js, .jsx, .ts, .tsx --cache"</span><span class="token punctuation">,</span>    <span class="token property">"eslint:fix"</span><span class="token operator">:</span> <span class="token string">"npm run eslint -- --fix"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>npm run eslint</code> 即是仅检查，而 <code>eslint:fix</code> 则是检查同时尽可能修复错误。这样我们就完成了基础的 TypeScript ESLint 配置。但在实际项目中，光靠 ESLint 可没法确保代码质量。</p><h2 id="配置-Prettier-与-Git-Hooks"><a href="#配置-Prettier-与-Git-Hooks" class="headerlink" title="配置 Prettier 与 Git Hooks"></a>配置 Prettier 与 Git Hooks</h2><p>通常在实际项目开发时，我们并不会仅仅使用 ESLint，还有一系列辅助的工具。比如我们可以同时使用 Prettier 与 ESLint，以及使用 Git Hooks 与 Lint Staged 确保项目代码在提交前被格式化过。这一部分我们就来介绍在 ESLint 基础上再添加 Prettier 与 Git Hooks。</p><p>首先是 Prettier，它同样是代码格式化工具，但和 ESLint 并不完全等价。除 JS/TS 代码文件以外，Prettier 也支持 CSS、Less 这样的样式文件，DSL 声明如 HTML、GraphQL 等等。我个人的习惯是将除核心代码文件以外的部分，如 JSON、HTML、MarkDown 等全交给 Prettier 进行格式化。</p><p>对于 JS/TS 文件，Prettier 与 ESLint 的核心差异在于它并不包括 <code>no-xxx</code>（不允许某些语法），<code>prefer-xxx</code>（对于多种功能一致的语法，推荐使用其中某一种）这些<strong>涉及具体代码逻辑</strong>的规则，而是专注于 indent、quote、comma（逗号）、printWidth（每行允许的字符串长度） 等规则。</p><p>首先安装 Prettier，如果你想要让 Prettier 也参与格式化代码文件，还需要安装 eslint-config-prettier ，这一配置包禁用了部分 ESLint 中会与 Prettier 产生冲突的规则。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> prettier eslint-config-prettier --save-dev<span class="token function">yarn</span> <span class="token function">add</span> prettier eslint-config-prettier --save-dev<span class="token function">pnpm</span> <span class="token function">install</span> prettier eslint-config-prettier --save-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>创建 Prettier 配置文件 .prettierrc.js，我们选择一小部分常用的：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 单行最多 80 字符</span>  <span class="token literal-property property">printWidth</span><span class="token operator">:</span> <span class="token number">80</span><span class="token punctuation">,</span>  <span class="token comment">// 一个 Tab 缩进 2 个空格</span>  <span class="token literal-property property">tabWidth</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token comment">// 每一行结尾需要有分号</span>  <span class="token literal-property property">semi</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token comment">// 使用单引号</span>  <span class="token literal-property property">singleQuote</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token comment">// 在对象属性中，仅在必要时才使用引号，如 "prop-foo"</span>  <span class="token literal-property property">quoteProps</span><span class="token operator">:</span> <span class="token string">'as-needed'</span><span class="token punctuation">,</span>  <span class="token comment">// 在 jsx 中使用双引号</span>  <span class="token literal-property property">jsxSingleQuote</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token comment">// 使用 es5 风格的尾缀逗号，即数组和对象的最后一项成员后也需要逗号</span>  <span class="token literal-property property">trailingComma</span><span class="token operator">:</span> <span class="token string">'es5'</span><span class="token punctuation">,</span>  <span class="token comment">// 大括号内首尾需要空格</span>  <span class="token literal-property property">bracketSpacing</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token comment">// HTML 标签（以及 JSX，Vue 模板等）的反尖括号 > 需要换行</span>  <span class="token literal-property property">bracketSameLine</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token comment">// 箭头函数仅有一个参数时也需要括号，如 (arg) => &#123;&#125;</span>  <span class="token comment">// 使用 crlf 作为换行符</span>  <span class="token literal-property property">endOfLine</span><span class="token operator">:</span> <span class="token string">'crlf'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于更多配置，参见 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fprettier.io%2Fdocs%2Fen%2Foptions.html">Prettier 配置</a>。</p><p>同时为了避免和 ESLint 冲突，我们还需要通过 <code>eslint-config-prettier</code> 禁用掉部分 ESLint 规则，修改 ESLint 配置：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">extends</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">'plugin:react/recommended'</span><span class="token punctuation">,</span>    <span class="token string">'plugin:@typescript-eslint/recommended'</span><span class="token punctuation">,</span>    <span class="token string">'prettier'</span><span class="token punctuation">,</span> <span class="token comment">// 新增这一行</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建忽略文件 .prettierignore：</p><pre class="line-numbers language-init" data-language="init"><code class="language-init">builddistout# 如果你不希望 prettier 检查代码文件的话# *.ts# *.tsx# *.jsx# *.js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时更新 NPM Scripts：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"eslint"</span><span class="token operator">:</span> <span class="token string">"eslint src/** --no-error-on-unmatched-pattern --ext .js, .jsx, .ts, .tsx --cache"</span><span class="token punctuation">,</span>    <span class="token property">"eslint:fix"</span><span class="token operator">:</span> <span class="token string">"npm run eslint -- --fix"</span><span class="token punctuation">,</span>    <span class="token property">"prettier"</span><span class="token operator">:</span> <span class="token string">"prettier --check ."</span><span class="token punctuation">,</span>    <span class="token property">"prettier:fix"</span><span class="token operator">:</span> <span class="token string">"prettier --write ."</span><span class="token punctuation">,</span>    <span class="token property">"lint"</span><span class="token operator">:</span> <span class="token string">"npm run eslint &amp;&amp; npm run prettier"</span><span class="token punctuation">,</span>    <span class="token property">"lint:fix"</span><span class="token operator">:</span> <span class="token string">"npm run eslint:fix &amp;&amp; npm run prettier:fix"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似的，<code>npm run prettier</code> 是仅检查，而 <code>prettier:fix</code> 才是进入修改。同时我们还增加了 <code>lint</code> 和 <code>lint:fix</code> 来一次性执行两个工具。</p><p>即使配置了 ESLint 和 Prettier，还是可能出现每个人提交代码都不一样的情况。这是因为这些 scripts 需要手动执行，非常容易忘记或者绕过去。而如果我们能让所有开发同学每次提交代码时都自动执行一次格式化，就能确保所有人成功提交上去的代码风格一致。</p><p>要实现这一能力，我们需要 Git Hooks 与 Lint Staged。</p><p>首先是 Git Hooks，它和 React Hooks 可不一样，它更贴近生命周期的概念，即在某一个操作前后执行的额外逻辑。如我们要实现在 commit 前格式化，就可以使用 <code>pre-commit</code> 这个钩子，如果钩子执行失败，就不会真地执行 commit 。常用的 Git Hooks 还有 <code>commit-msg</code>（可以用于检查 commit 信息是否规范，如需要符合 <code>feat(core): enhancement</code> 这种格式）、<code>pre-push</code>以及在服务端 Git 仓库执行的 <code>pre-receive</code>、<code>update</code>、 <code>post-receive</code> 等。</p><p>直接写 Git Hooks 不太优雅，我们可以通过 <a href="https://link.juejin.cn/?target=https%3A%2F%2Ftypicode.github.io%2Fhusky%2F">Husky</a> 来实现相对简便的配置。关于各种初始化方式，你可以阅读文档了解更多，我们这里只介绍自动安装的方式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npx husky-init <span class="token operator">&amp;&amp;</span> <span class="token function">npm</span> <span class="token function">install</span>       <span class="token comment"># npm</span>npx husky-init <span class="token operator">&amp;&amp;</span> <span class="token function">yarn</span>              <span class="token comment"># Yarn 1</span><span class="token function">yarn</span> dlx husky-init <span class="token parameter variable">--yarn2</span> <span class="token operator">&amp;&amp;</span> <span class="token function">yarn</span> <span class="token comment"># Yarn 2+</span><span class="token function">pnpm</span> dlx husky-init <span class="token operator">&amp;&amp;</span> <span class="token function">pnpm</span> <span class="token function">install</span> <span class="token comment"># pnpm</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样做只是安装了 Huksy 以及配置了相关环境，我们实际上还没有添加 Git Hooks。Huksy 也提供了快速创建的方式，我们直接把后面要执行的命令先添加进来：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npx husky <span class="token function">add</span> .husky/pre-commit <span class="token string">'./node_modules/.bin/lint-staged'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在你应该拥有了一个 .huksy 文件夹，以及内部的 pre-commit 文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/env sh</span><span class="token builtin class-name">.</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">dirname</span> -- <span class="token string">"<span class="token variable">$0</span>"</span><span class="token variable">)</span></span>/_/husky.sh"</span>./node_modules/.bin/lint-staged<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，我们实际上要执行的就是 lint-staged 这个命令，而 Lint Staged 的作用即是<strong>找出你添加到暂存区（git add）的文件，然后执行对应的 lint</strong>，接着我们来学习如何将它添加到项目里。</p><p>首先还是安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev lint-staged<span class="token function">yarn</span> <span class="token function">add</span> --save-dev lint-staged<span class="token function">pnpm</span> <span class="token function">install</span> --save-dev lint-staged<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后在 package.json 中新增这段配置：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"lint-staged"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"*.&#123;js,jsx,ts,tsx&#125;"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token string">"eslint --cache --fix"</span><span class="token punctuation">,</span>      <span class="token string">"prettier --write --list-different"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"*.&#123;json,md,html,css,scss,sass,less,styl&#125;"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token string">"prettier --write --list-different"</span>    <span class="token punctuation">]</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段配置的大意是，对于暂存区的核心代码文件，先使用 ESLint 格式化，再使用 Prettier 格式化，而对于其他文件，统一使用 Prettier 进行格式化。现在你可以试着提交一次了：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c44b7cd1263402884dbd71148f8b93e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>加上 Prettier、Git Hooks 与 Lint Staged 后，我们的项目约束才能说基本搞定了。虽然 Git Hooks 也可以通过 <code>git commit -m &#39;xx&#39; --no-verify</code> 这种方式绕过去，但至少现在我们有办法让大家提交的代码都一致了，不用再被格式化导致的冲突折磨了。但我们并不应该满足于知道如何配置，也需要理解这些配置的原理，以及内部都包含了什么。比如，Husky 是如何简化 Git Hooks 配置的？Lint Staged 是如何工作的？</p><p>在接下来，我们会介绍一批 TypeScript 下的 ESLint 规则，了解它们的作用，以及我们为什么需要这些规则。</p><h2 id="TypeScript-下的-ESLint-规则集推荐"><a href="#TypeScript-下的-ESLint-规则集推荐" class="headerlink" title="TypeScript 下的 ESLint 规则集推荐"></a>TypeScript 下的 ESLint 规则集推荐</h2><p>在前面我们只是介绍了如何配置 ESLint 相关的工程，还没有具体介绍 TypeScript 下应使用哪些 ESLint 规则。为了帮助你更好地挑选适用于自己需要的规则，接下来我们会来介绍一批推荐使用的 TypeScript ESLint 规则，包括其意图（如何约束代码）与配置等。我也简单对这些规则做了分类：基础版与进阶版，基础版为约束程度较低的规则，而进阶版则较为严格。</p><p>如果你想直接使用现成的配置，我也将下面介绍的规则发布到了 npm，首先安装配置集：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">npm i eslint<span class="token operator">-</span>config<span class="token operator">-</span>ts<span class="token operator">-</span>ruleset <span class="token operator">--</span>save<span class="token operator">--</span>devyarn add eslint<span class="token operator">-</span>config<span class="token operator">-</span>ts<span class="token operator">-</span>ruleset <span class="token operator">--</span>save<span class="token operator">--</span>devpnpm i eslint<span class="token operator">-</span>config<span class="token operator">-</span>ts<span class="token operator">-</span>ruleset <span class="token operator">--</span>save<span class="token operator">--</span>dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后在 ESLint 配置中启用：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">root</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token keyword">extends</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">'plugin:@typescript-eslint/recommended'</span><span class="token punctuation">,</span>    <span class="token string">'prettier'</span><span class="token punctuation">,</span>    <span class="token comment">// 基础规则</span>    <span class="token string">'ts-ruleset'</span><span class="token punctuation">,</span>    <span class="token comment">// 严格规则</span>    <span class="token string">'ts-ruleset/strict'</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token literal-property property">parser</span><span class="token operator">:</span> <span class="token string">'@typescript-eslint/parser'</span><span class="token punctuation">,</span>  <span class="token literal-property property">parserOptions</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">project</span><span class="token operator">:</span> <span class="token string">'./tsconfig.json'</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'react'</span><span class="token punctuation">,</span> <span class="token string">'@typescript-eslint'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token literal-property property">rules</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token string-property property">'react/react-in-jsx-scope'</span><span class="token operator">:</span> <span class="token string">'off'</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TypeScript ESLint 规则主要由四个部分组成：</p><ul><li>仅在 ESLint 约束基础上支持了 TypeScript 语法解析，如缩进 indent、单双引号 quote、逗号 comma 等，这些规则我们不会做额外介绍，因为已经被包含在 <code>&#39;plugin:@typescript-eslint/recommended&#39;</code> 中</li><li>对语法的统一约束，比如类型断言有 as 和尖括号两种，可以通过规则来约束只能使用一种断言语法。以及对于某些对实际逻辑无影响，可加可不加的语法约束，如 for 循环和 <code>for...of</code> 的比较 。</li><li>对类型标注的约束，如禁止某些类型被用于进行标注，以及在函数返回值处要求你显式标注类型等</li><li>对能力的约束，如对于仅类型导入、类型声明的约束，以及非空断言、常量断言等功能的使用</li></ul><p>基础部分的规则多是简单的语法检查和类型检查，因此我们就不做讲解。接下来我们会来了解的是严格规则组内的规则，我们进一步将其划分为<strong>一般严格</strong>与<strong>较为严格</strong>。</p><h3 id="一般严格组"><a href="#一般严格组" class="headerlink" title="一般严格组"></a>一般严格组</h3><h4 id="语法统一约束"><a href="#语法统一约束" class="headerlink" title="语法统一约束"></a>语法统一约束</h4><h5 id="array-type"><a href="#array-type" class="headerlink" title="array-type"></a>array-type</h5><p>TypeScript 中同时支持使用 <code>Array&lt;T&gt;</code> 与 <code>T[]</code> 两种方式声明数组类型，此规则约束项目中对这两种数组类型声明的使用，包括仅使用 <code>Array&lt;T&gt;</code> 或 <code>T[]</code> 其中一种，或者对于原始类型与类型别名使用 <code>T[]</code>，对于联合类型、对象类型、函数类型等使用 <code>Array&lt;T&gt;</code>。</p><p>这是为什么呢？对于这种效果完全一致仅仅在使用上有差异的语法，我们需要的只是确定一个规范，然后在所有地方使用这一规范。实际上，这一类规则（还有后面的类型断言语法）就类似于单引号 / 双引号，加不加分号这种基础规则，如果你不能接受上一行代码单引号这一行代码双引号，那么也没理由能接受这里一个 <code>Array&lt;number&gt;</code> 那里一个 <code>number[]</code>。</p><h5 id="await-thenable"><a href="#await-thenable" class="headerlink" title="await-thenable"></a>await-thenable</h5><p>只允许对异步函数、Promise、PromiseLike 使用 await 调用（也就是实现了 Thenable 接口，存在 then 方法的对象），可以避免无意义的 await 调用，同时还能帮助你发现某个异步函数忘记加 async 了。</p><h5 id="consistent-type-assertions"><a href="#consistent-type-assertions" class="headerlink" title="consistent-type-assertions"></a>consistent-type-assertions</h5><p>TypeScript 支持通过 <code>as</code> 与 <code>&lt;&gt;</code> 两种不同的语法进行类型断言，如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">as</span> Foo<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token operator">&lt;</span>Foo<span class="token operator">></span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token keyword">const</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token comment">// 常量断言</span><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token keyword">const</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一规则约束使用统一的类型断言语法，我一般在 Tsx 中使用 <code>as</code> ，在其他时候尽可能的使用 <code>&lt;&gt;</code>，原因则是 <code>&lt;&gt;</code> 更加简洁。</p><p>类似于 array-type，这条规则也是主要做语法统一，但需要注意的是在 Tsx 项目中使用 <code>&lt;&gt;</code> 断言会导致报错，因为此时无法像泛型那样通过 <code>&lt;T extends Foo&gt;</code> 来显式告知编译器这里是泛型语法而非一个 JSX 组件。</p><h5 id="consistent-type-definitions"><a href="#consistent-type-definitions" class="headerlink" title="consistent-type-definitions"></a>consistent-type-definitions</h5><p>TypeScript 支持通过 type 与 interface 声明对象类型，此规则可将其收束到统一的声明方式，即仅使用其中的一种。先说我是怎么做的，在绝大部分场景下，使用 interface 来声明对象类型，type 应当用于声明联合类型、函数类型、工具类型等，如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">IFoo</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">Partial<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">LiteralBool</span> <span class="token operator">=</span> <span class="token string">'true'</span> <span class="token operator">|</span> <span class="token string">'false'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原因主要有这么几点。</p><ul><li><p>配合 naming-convention 规则（检查接口是否按照规范命名），我们要求接口的名称需要以大写字母 <code>I</code> 开头，我们能够在看见 <code>IFoo</code> 时立刻知道它是一个 接口，看见 <code>Bar</code> 时立刻知道它是一个类型别名。额外配置如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>  <span class="token string-property property">"@typescript-eslint/naming-convention"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"error"</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>      <span class="token string-property property">"selector"</span><span class="token operator">:</span> <span class="token string">"interface"</span><span class="token punctuation">,</span>      <span class="token string-property property">"format"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"PascalCase"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token string-property property">"custom"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token string-property property">"regex"</span><span class="token operator">:</span> <span class="token string">"^I[A-Z]"</span><span class="token punctuation">,</span>        <span class="token string-property property">"match"</span><span class="token operator">:</span> <span class="token boolean">false</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>接口在类型编程中的作用非常局限，仅支持 extends、泛型等简单的能力，它也只应当被用于定义确定的结构体。而类型别名能够使用除 extends 以外所有的类型编程语法。同时，“类型别名”的含义也意味着，我们实际上是使用它来<strong>归类类型</strong>（联合类型）、<strong>抽象类型</strong>（函数类型、类类型）以及<strong>封装工具类型</strong>。</p></li></ul><h5 id="prefer-for-of"><a href="#prefer-for-of" class="headerlink" title="prefer-for-of"></a>prefer-for-of</h5><p>在你使用 for 循环遍历数组时，如果索引仅仅用来访问数组成员，则应该替换为 <code>for...of</code>：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// ×</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// √</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> x <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不是为了兼容性考虑，在仅访问索引的情况下，我们的确没有必要使用 for 循环，而应当使用语法更加简单的 <code>for...of</code>。</p><h5 id="prefer-nullish-coalescing-与-prefer-optional-chain"><a href="#prefer-nullish-coalescing-与-prefer-optional-chain" class="headerlink" title="prefer-nullish-coalescing 与 prefer-optional-chain"></a>prefer-nullish-coalescing 与 prefer-optional-chain</h5><p>使用 <code>??</code> 而不是 <code>||</code>，使用 <code>a?.b</code> 而不是 <code>a &amp;&amp; a.b</code>。这是因为，逻辑或 <code>||</code> 会将 0 与 <code>&quot;&quot;</code> 视为 false 而导致错误地应用默认值，而 <code>??</code> 则只会在 null 和 undefined 时使用默认值。可选链 <code>?.</code> 相比于逻辑与 <code>&amp;&amp;</code> ，则能够带来更简洁的语法（尤其是在属性访问嵌套多层时，如 <code>res?.data?.status</code>），以及与 <code>??</code> 更好的协作：<code>const foo = a?.b?.c?.d ?? &#39;default&#39;;</code>。</p><p>在 TypeScript 与 ECMAScript 纠葛一节中，我们还会详细介绍可选链与空值合并这两个语法。</p><h5 id="consistent-type-imports"><a href="#consistent-type-imports" class="headerlink" title="consistent-type-imports"></a>consistent-type-imports</h5><p>约束使用 <code>import type &#123;&#125;</code> 进行类型的导入，如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// √</span><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> CompilerOptions <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'typescript'</span><span class="token comment">// x</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> CompilerOptions <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'typescript'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就像我们在类型声明那一节所了解的，<code>import type</code> 能够帮助你更好地组织你的项目头部的导入结构。值导入与类型导入在 TypeScript 中使用不同的空间来存放，因此无须担心循环依赖（所以你可以<strong>父组件导入子组件，子组件导入定义在父组件中的类型</strong>这样）。</p><p>类似的，我们也可以通过 <code>consistent-type-exports</code> 规则，来约束只能使用 <code>export type</code> 导出类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Foo</span> <span class="token operator">=</span> <span class="token builtin">string</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> Foo <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一个简单的、良好组织了导入语句的示例：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useEffect <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Button<span class="token punctuation">,</span> Dialog <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'ui'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ChildComp <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./child'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> store <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@/store'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useCookie <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@/hooks/useCookie'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> <span class="token constant">SOME_CONSTANTS</span> <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@/utils/constants'</span><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> Foo <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@/typings/foo'</span><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> Shared <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@/typings/shared'</span><span class="token keyword">import</span> styles <span class="token keyword">from</span> <span class="token string">'./index.module.scss'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="non-nullable-type-assertion-style"><a href="#non-nullable-type-assertion-style" class="headerlink" title="non-nullable-type-assertion-style"></a>non-nullable-type-assertion-style</h5><p>此规则要求在类型断言仅起到去空值作用，如将 <code>string | undefined</code> 类型断言为 <code>string</code>时，将其替换为非空断言 <code>!</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> foo<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token string">'foo'</span><span class="token comment">// √</span>foo<span class="token operator">!</span><span class="token comment">// x</span>foo <span class="token keyword">as</span> <span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非空断言的目的就是提供快速去除类型中 null、undefined 值的类型断言能力，这一规则的本质是检查<strong>经过断言后的类型子集是否仅剔除了空值部分</strong>。因此，无需担心对于多种有实际意义的类型分支的联合类型误判。</p><h5 id="promise-function-async"><a href="#promise-function-async" class="headerlink" title="promise-function-async"></a>promise-function-async</h5><p>返回 Promise 的函数必须被标记为 async。当你的函数显式返回了一个 Promise，就说明它应当是一个异步过程，就应当被标记为 async。</p><h5 id="prefer-literal-enum-member"><a href="#prefer-literal-enum-member" class="headerlink" title="prefer-literal-enum-member"></a>prefer-literal-enum-member</h5><p>对于枚举成员值，只允许使用普通字符串、数字、null、正则，而不允许变量复制、模板字符串等需要计算的操作。虽然 TypeScript 是允许使用各种合法表达式作为枚举成员的，但由于枚举的编译结果拥有自己的作用域，因此可能导致错误的赋值，如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> imOutside <span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">enum</span> Foo <span class="token punctuation">&#123;</span>  outer <span class="token operator">=</span> imOutside<span class="token punctuation">,</span>  a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>  b <span class="token operator">=</span> a<span class="token punctuation">,</span>  c <span class="token operator">=</span> b<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里 <code>c == Foo.b == Foo.c == 1</code>，还是 <code>c == b == 2</code> ? 观察下编译结果：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token string">'use strict'</span><span class="token keyword">const</span> imOutside <span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">var</span> Foo<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>Foo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Foo<span class="token punctuation">[</span><span class="token punctuation">(</span>Foo<span class="token punctuation">[</span><span class="token string">'outer'</span><span class="token punctuation">]</span> <span class="token operator">=</span> imOutside<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'outer'</span>  Foo<span class="token punctuation">[</span><span class="token punctuation">(</span>Foo<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'a'</span>  Foo<span class="token punctuation">[</span><span class="token punctuation">(</span>Foo<span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'b'</span>  Foo<span class="token punctuation">[</span><span class="token punctuation">(</span>Foo<span class="token punctuation">[</span><span class="token string">'c'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'c'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Foo <span class="token operator">||</span> <span class="token punctuation">(</span>Foo <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译结果也说明了，枚举对象内部也是有作用域的，优先级当然比外部作用域同名变量更高。</p><h5 id="prefer-as-const"><a href="#prefer-as-const" class="headerlink" title="prefer-as-const"></a>prefer-as-const</h5><p>对于常量断言，使用 as const 而不是 <code>&lt;const&gt;</code>，这一点类似于上面约束类型断言语法的 consistent-type-assertions 规则。</p><h4 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h4><h5 id="no-unnecessary-type-arguments"><a href="#no-unnecessary-type-arguments" class="headerlink" title="no-unnecessary-type-arguments"></a>no-unnecessary-type-arguments</h5><p>不允许与默认值一致的泛型参数，如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">foo</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token builtin">number</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token generic-function"><span class="token function">foo</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>与默认值一致的泛型参数是没有意义的，因为我们直接把鼠标悬浮上去就能看到实际应用的泛型类型。</p><h4 id="能力约束"><a href="#能力约束" class="headerlink" title="能力约束"></a>能力约束</h4><h5 id="ban-ts-comment"><a href="#ban-ts-comment" class="headerlink" title="ban-ts-comment"></a>ban-ts-comment</h5><p>禁止 <code>@ts-</code> 指令的使用，或者允许其在提供了说明的情况下被使用，如：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">// @ts-expect-error 这里的类型太复杂，日后补上// @ts-nocheck 未完成迁移的文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此规则推荐与 <code>prefer-ts-expect-error</code> 一同搭配使用，让你的项目里不再出现 ts-ignore 指令。而如果说乱写 any 叫 AnyScript，那么乱写 <code>@ts-ignore</code> 就可以叫 IgnoreScript 了。</p><h5 id="prefer-ts-expect-error"><a href="#prefer-ts-expect-error" class="headerlink" title="prefer-ts-expect-error"></a>prefer-ts-expect-error</h5><p>使用 <code>@ts-expect-error</code> 而不是 <code>@ts-ignore</code>。</p><p>在类型声明与类型指令一节我们已经了解到， <code>@ts-ignore</code> 与 <code>@ts-expect-error</code> 二者的区别主要在于，前者是 ignore，直接放弃了下一行的类型检查而无论下一行是否真的有错误，而后者则是期望下一行确实存在一个错误，并且会在实际不存在错误时反而抛出一个错误。</p><p>这一类干涉代码检查指令的使用本就应该慎之又慎，在任何情况下都不应该被作为逃生舱门（因为它真的比 any 还好用）。如果你一定要用，也要确保用得恰当。</p><h5 id="no-extra-non-null-assertion"><a href="#no-extra-non-null-assertion" class="headerlink" title="no-extra-non-null-assertion"></a>no-extra-non-null-assertion</h5><p>不允许额外的重复非空断言：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// x</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>bar<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> bar<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> bar<span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>额外的非空断言是无意义的，只要一次非空断言就能移除掉 null 与 undefined 类型了。</p><h5 id="no-non-null-asserted-nullish-coalescing"><a href="#no-non-null-asserted-nullish-coalescing" class="headerlink" title="no-non-null-asserted-nullish-coalescing"></a>no-non-null-asserted-nullish-coalescing</h5><p>不允许非空断言与空值合并同时使用，如 <code>bar! ?? tmp</code>。</p><p>非空断言可以用于移除掉一个类型中的 null 与 undefined，而空值合并则在左侧值为 null 或 undefined 时应用一个默认值，这么结合使用将非常有害，你的同事看到它会陷入思考：<strong>bar 到底会不会有空值的时候</strong>？</p><h5 id="no-non-null-asserted-optional-chain"><a href="#no-non-null-asserted-optional-chain" class="headerlink" title="no-non-null-asserted-optional-chain"></a>no-non-null-asserted-optional-chain</h5><p>不允许非空断言与可选链同时使用，如 <code>foo?.bar!</code>。和上一条规则类似，属于非常有害的结合使用方式。同时这也意味着，你对 <code>!</code> <code>??</code> <code>?.</code> 的理解存在着不当之处。</p><h5 id="no-unnecessary-type-assertion"><a href="#no-unnecessary-type-assertion" class="headerlink" title="no-unnecessary-type-assertion"></a>no-unnecessary-type-assertion</h5><p>不允许与实际值一致的类型断言，如：<code>const foo = &#39;foo&#39; as string</code>。类似于不允许默认值一致的泛型，这条规则的目的也是减少不必要的类型代码。</p><h5 id="no-unnecessary-type-constraint"><a href="#no-unnecessary-type-constraint" class="headerlink" title="no-unnecessary-type-constraint"></a>no-unnecessary-type-constraint</h5><p>不允许与默认约束一致的泛型约束，如：<code>interface FooAny&lt;T extends any&gt; &#123;&#125;</code>。仍然是出于简化代码的考虑，在 TS 3.9 版本以后，对于未指定的泛型约束，默认使用 <code>unknown</code> ，在这之前则是 <code>any</code>，这也就意味着没必要再多写 <code>extends unknown</code> 了。</p><h3 id="较为严格组"><a href="#较为严格组" class="headerlink" title="较为严格组"></a>较为严格组</h3><h4 id="语法统一约束-1"><a href="#语法统一约束-1" class="headerlink" title="语法统一约束"></a>语法统一约束</h4><h5 id="method-signature-style"><a href="#method-signature-style" class="headerlink" title="method-signature-style"></a>method-signature-style</h5><p>方法签名的声明方式有 method 与 property 两种，区别如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// method</span><span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token punctuation">&#123;</span>  <span class="token function">func</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token comment">// property</span><span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">func</span><span class="token operator">:</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此规则将声明方式进行约束，推荐使用第二种的 property 方式。</p><p>其实这一规则的核心原因，我们在协变与逆变一节已经了解过了。首先，method 方式类似于在 Class 中定义方法，而 property 则是就像定义普通的接口属性，只不过它的值是函数类型。推荐使用 property 的最重要原因是，通过使用 属性 + 函数值 的方式定义，作为值的函数的类型能享受到更严格的类型校验（ <code>strictFunctionTypes</code>），此配置会使用逆变（<em>contravariance</em>）而非协变（<em>covariance</em>）的方式进行函数参数的检查。</p><h4 id="类型约束-1"><a href="#类型约束-1" class="headerlink" title="类型约束"></a>类型约束</h4><h5 id="ban-types"><a href="#ban-types" class="headerlink" title="ban-types"></a>ban-types</h5><p>禁止部分值被作为类型标注，此规则能够对每一种被禁用的类型提供特定的说明来在触发此规则报错时给到良好的提示。</p><p>这条规则常见的场景是禁用 <code>&#123;&#125;</code>、<code>Function</code>、<code>object</code> 这些类型。</p><ul><li>使用 <code>&#123;&#125;</code> 会让你寸步难行：<code>类型 &#123;&#125; 上不存在属性 &#39;foo&#39;</code>，所以用了 <code>&#123;&#125;</code> 你大概率在下面还需要类型断言回去或者变 any。同时别忘了 <code>&#123;&#125;</code> 作为万物起源的特性。</li><li><code>object</code> 的使用在大部分情况下都是错误的，别忘了它实际上表示所有非原始类型的类型。对于未知的对象类型，应使用 <code>Record&lt;string, unknown&gt;</code> 或者 <code>Record&lt;string, any&gt;</code>。</li><li>对于函数类型，应使用入参、返回值被标注出来的具体类型：<code>type SomeFunc = (arg1: string) =&gt; void</code> ，或在入参与返回值类型未知的场景下使用 <code>type SomeFunc = (...args: any[]) =&gt; any</code>。</li></ul><h5 id="no-empty-interface"><a href="#no-empty-interface" class="headerlink" title="no-empty-interface"></a>no-empty-interface</h5><p>不允许定义空的接口，可配置为允许单继承下的空接口：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// x</span><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// √</span><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token keyword">extends</span> <span class="token class-name">Bar</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>没有父类型的空接口实际上就等于 <code>&#123;&#125;</code>，虽然无法不确定你使用它是为了什么，但它显然是不对的。而单继承的空接口场景则更常见，比如可以先确定下继承关系，再在后续添加成员。</p><h5 id="no-explicit-any"><a href="#no-explicit-any" class="headerlink" title="no-explicit-any"></a>no-explicit-any</h5><p>不允许显式的 any 类型。</p><p>此前我们已经了解过 any 类型的弊端，甚至 TypeScript 专门引入了 unknown 类型来尝试堵上一些口子。然而即使这样，很多场景下考虑到成本，我们还是会使用 any 。因此实际上这条规则只被设置为 warn 等级，真的做到一个 any 不用，或是全部替换成 unknown + 类型断言，都是成本极高的，需要团队所有人都有着严格的代码质量意识。如果你真的想这么做，我推荐配合 tsconfig 的 <code>--noImplicitAny</code> 来检查隐式 any ，来尽可能抹除代码中 的 any。</p><h5 id="no-inferrable-types"><a href="#no-inferrable-types" class="headerlink" title="no-inferrable-types"></a>no-inferrable-types</h5><p>不允许不必要的类型标注，但可配置为允许类的属性成员、函数的属性成员进行额外标注。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> foo<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  prop1<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于普通变量来说，与实际赋值一致的类型标注确实是没有意义的，TypeScript 的控制流分析能很好地进行类型自动推导。而对于函数参数与类属性，允许其进行类型标注则主要是为了确保一致性，即函数的所有参数（包括重载的各个声明）、类的所有属性都有类型标注，而不是仅为不存在初始值的参数/属性进行标注。</p><h5 id="explicit-module-boundary-types"><a href="#explicit-module-boundary-types" class="headerlink" title="explicit-module-boundary-types"></a>explicit-module-boundary-types</h5><p>函数与类方法的返回值需要被显式指定，而不是依赖类型推导，如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Foo <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过显式指定返回值类型，我们可以直观区分函数的功能，如是否携带副作用，以及是否有返回值等，同时显式指定的函数返回值类型也能在一定程度上提升 TypeScript Compiler 性能。</p><p>在这一点上可能会有比较大的分歧，认为它成本太高。而我认为首先 TypeScript 强大的类型推导能力是能够直接为你推导出最终返回值类型的，你完全可以直接复制上去。其次，显式标注返回值类型也能够通过上下文类型的能力（即实际 return 的值类型和你自己标注的返回值类型是否一致），帮助你确保最终返回的类型一定是你预期的那个类型。</p><h4 id="能力约束-1"><a href="#能力约束-1" class="headerlink" title="能力约束"></a>能力约束</h4><h5 id="no-unnecessary-boolean-literal-compare"><a href="#no-unnecessary-boolean-literal-compare" class="headerlink" title="no-unnecessary-boolean-literal-compare"></a>no-unnecessary-boolean-literal-compare</h5><p>不允许对布尔类型变量的 === 比较，如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">const</span> someCondition<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token keyword">if</span> <span class="token punctuation">(</span>someCondition <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>首先，记住我们是在写 TypeScript，所以不要想着你的变量值还有可能是 null，所以需要这样判断，如果真的发生了，那么说明你的 TS 类型标注并不准确——这条规则是通过变量类型来进行判断的。虽然此规则的配置项允许 <code>boolean | null</code> 这样的值与 true / false 进行比较，但还是让你的类型更精确一些更好。</p><h5 id="no-throw-literal"><a href="#no-throw-literal" class="headerlink" title="no-throw-literal"></a>no-throw-literal</h5><p>不允许直接 throw 一个字符串如：<code>throw &#39;err&#39;</code>，只能抛出 Error 或基于 Error 派生类的实例，如：<code>throw new Error(&#39;Oops!&#39;)</code>。</p><p>抛出的 Error 实例能够自动的收集调用栈信息，同时借助 <strong><a href="https://link.juejin.cn/?target=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fgithub.com%2Ftc39%2Fproposal-error-cause">proposal-error-cause</a></strong> 提案，还能够跨越调用栈来附加错误原因传递上下文信息。</p><h5 id="switch-exhaustiveness-check"><a href="#switch-exhaustiveness-check" class="headerlink" title="switch-exhaustiveness-check"></a>switch-exhaustiveness-check</h5><p>switch 的判定变量为联合类型时，其每一个类型分支都需要被处理。如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">PossibleTypes</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span> <span class="token operator">|</span> <span class="token string">'qiongxin'</span> <span class="token operator">|</span> <span class="token string">'developer'</span><span class="token keyword">let</span> value<span class="token operator">:</span> PossibleTypes<span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">case</span> <span class="token string">'linbudu'</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    result <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">break</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">case</span> <span class="token string">'qiongxin'</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    result <span class="token operator">=</span> <span class="token number">2</span>    <span class="token keyword">break</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">case</span> <span class="token string">'developer'</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    result <span class="token operator">=</span> <span class="token number">3</span>    <span class="token keyword">break</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>联合类型变量中每一条类型分支可能都需要特殊的处理逻辑，此规则可以避免你新增了一个类型分支却没有为它分配对应的处理逻辑。</p><p>在内置类型一节，我们还了解了通过 TypeScript 中的 never 类型来实现编译时的检验：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> strOrNumOrBool<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'str!'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'num!'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">'boolean'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bool!'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> _exhaustiveCheck<span class="token operator">:</span> <span class="token builtin">never</span> <span class="token operator">=</span> strOrNumOrBool  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Unknown input type: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>_exhaustiveCheck<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="restrict-template-expressions"><a href="#restrict-template-expressions" class="headerlink" title="restrict-template-expressions"></a>restrict-template-expressions</h5><p>模板字符串中的计算表达式其返回值必须是字符串，此规则可以被配置为允许数字、布尔值、可能为 null 的值以及正则表达式，或者你也可以允许任意的值，但这样这条规则就形同虚设了。</p><p>在模板表达式中，非字符串与数字以外的值很容易带来潜在的问题，如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'linbudu'</span> <span class="token punctuation">&#125;</span><span class="token comment">// 'arr: 1,2,3'</span><span class="token keyword">const</span> str1 <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">arr: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>arr<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token comment">// 'obj: [object Object]'</span><span class="token keyword">const</span> str2 <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">obj: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>obj<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无论哪种情况都不会是你想看到的。推荐在规则配置中仅开启 <code>allowNumber</code> 来允许数字，而禁止掉其他的类型，你需要确保在把其他类型变量填入模板插槽中时，进行一次具有实际逻辑的转化。</p><h5 id="prefer-reduce-type-parameter"><a href="#prefer-reduce-type-parameter" class="headerlink" title="prefer-reduce-type-parameter"></a>prefer-reduce-type-parameter</h5><p>我们在泛型一节中曾经介绍过数组 reduce 方法的各种重载，比如下面这种：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> arr<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token comment">// 报错：不能将 number 类型的值赋值给 never 类型</span><span class="token keyword">const</span> result <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> curr<span class="token punctuation">,</span> idx<span class="token punctuation">,</span> arr<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span>prev<span class="token punctuation">,</span> curr<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然我们知道 result 最终的结果会仍然是 <code>number[]</code> 类型，但这里仍然会有类型报错，原因就在于这里 reduce 通过 <code>[]</code> 进行类型推导，得到了一个 <code>never[]</code> 类型，要解决也很简单，只要给 reduce 显式传入泛型参数即可：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> result <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">reduce</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> curr<span class="token punctuation">,</span> idx<span class="token punctuation">,</span> arr<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span>prev<span class="token punctuation">,</span> curr<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这一规则就是为了确保在所有情况下你都显式为 reduce 调用传入了泛型，这样一来你就能自己确定它最终的返回值类型，而不是依赖类型推导了。</p><h5 id="triple-slash-reference"><a href="#triple-slash-reference" class="headerlink" title="triple-slash-reference"></a>triple-slash-reference</h5><p>这一规则的目的在于禁止你使用三斜线指令，而是使用 import 来进行类型的导入。正如我们上一节所了解的那样：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// × 不推荐使用</span><span class="token comment">/// &lt;reference types="vite/client" /></span><span class="token comment">// √ 使用 import type 来声明对这个声明文件的依赖</span><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token operator">*</span> <span class="token keyword">as</span> ViteClientEnv <span class="token keyword">from</span> <span class="token string">'vite/client'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节，我们学习了 TypeScript 下的 ESLint 配置，以及为了实现更好约束引入的 Prettier 与 Git Hooks。实际上，它们就是你开始提升自己代码质量的第一步，也是团队协作开发下的基础要求之一。除了如何配置，我们还了解了一批推荐使用的 TypeScript ESLint 规则，明白了它们的功能与意义。</p><p>在下一节，我们会在工程实践的道路上更进一步，了解一批基本涵盖了整个 TypeScript 项目开发周期的工具库，说不定就有你刚好在找的那个。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/21.%E5%9C%A8%20React%20%E4%B8%AD%E6%84%89%E5%BF%AB%E5%9C%B0%E4%BD%BF%E7%94%A8%20TypeScript%EF%BC%9A%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%B3%9B%E5%9E%8B%E5%9D%91%E4%BD%8D/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/21.%E5%9C%A8%20React%20%E4%B8%AD%E6%84%89%E5%BF%AB%E5%9C%B0%E4%BD%BF%E7%94%A8%20TypeScript%EF%BC%9A%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%B3%9B%E5%9E%8B%E5%9D%91%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<p>这一节我们要介绍的是 React 项目中的 TypeScript 集成，React 和 TypeScript 能进行非常紧密而自然的协作，毕竟 tsx 文件本质上也是一个 ts 文件，因此可以直接享受到 TypeScript 的类型检查能力。也因此，在 React 中使用 TypeScript 并没有非常复杂的地方，我们主要关注三个方面：<strong>组件声明</strong>、<strong>泛型坑位</strong>与<strong>内置类型定义</strong>，对于 React + TypeScript 的工程规范，我们也会简要介绍。</p><p>组件声明指的是我们声明一个 React 组件的方式。如何结合 TypeScript 来进行组件属性、返回元素的有效性检查？这些组件声明方式都存在哪些特殊用法？需要注意的是，我们只会介绍函数式组件相关，而不会有 Class 组件出现。</p><p>泛型坑位即 React API 中预留出的泛型坑位，就像我们在前面学习的一样，这些泛型可以通过输入一个值来隐式推导，也可以直接显式声明来约束后续的值输入。而内置类型定义则主要是事件信息的类型定义以及内置工具类型两个部分，比如，在你的 onClick 函数中应当如何为参数声明类型？onChange 函数呢？</p><p>当然，我们会首先从项目搭建开始，但我们的关注点<strong>并非代码的实际运行</strong>，而只是结合 TypeScript 的 tsx 代码书写，因此你也可以直接阅读仓库中的代码，本节的内容主要在 components 与 types 两个文件夹中。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F18-react-ts">React TypeScript</a></p></blockquote><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>这里我们使用 Vite 来进行项目搭建，在终端输入以下代码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npx create-vite<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入项目名，选择 <code>react-ts</code> 模板即可。最终的项目结构是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">├── index.html├── package.json├── src│   ├── App.css│   ├── App.tsx│   ├── favicon.svg│   ├── index.css│   ├── logo.svg│   ├── main.tsx│   └── vite-env.d.ts├── tsconfig.json├── tsconfig.node.json└── vite.config.ts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，你也可以使用 Create-React-App、Parcel 等工具进行项目搭建，对于 Create-React-App 运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i create-react-app <span class="token parameter variable">-g</span>create-react-app your-project <span class="token parameter variable">--template</span><span class="token operator">=</span>typescript<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于基于 Parcel 的搭建，参考我的这个 demo：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FLinbuduLab%2FParcel-Tsx-Template">Parcel-Tsx-Template</a>。</p><blockquote><p>本质上，Vite、Create-React-App、Parcel 代表了三种不同思路的 Bundler，分别是基于浏览器 ESM 支持的 Bundleless 、大而全的 Webpack 以及零配置的 Parcel ，我们会在扩展阅读一节了解更多。</p></blockquote><h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><p>先不急着开始，我们先观察基于 Vite 创建的初始项目里都包含了哪些配置。</p><p>首先是依赖，可以看到在 devDependencies 中包含了 <code>@types/react</code> 与 <code>@types/react-dom</code> 。对于 <code>@types</code> 包的作用我们在前面一节已经了解过，TypeScript 会自动加载 <code>node_modules/@types</code> 下的类型定义来在全局使用。而除了这一点，当我们从 react 中导出一个类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> <span class="token constant">FC</span> <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> <span class="token constant">FC</span> <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上这个类型也来自于 <code>@types/react</code> 。接着是项目内的 <code>vite-env.d.ts</code> 声明文件，我们会发现它只有短短的一行：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">/// &lt;reference types="vite/client" /></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>三斜线指令的作用我们在前面一节了解过，现在我们就看看 <code>vite/client</code> 中都包含了什么：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">/// &lt;reference lib="dom" /></span><span class="token comment">/// &lt;reference path="./types/importMeta.d.ts" /></span><span class="token comment">// CSS modules</span><span class="token keyword">type</span> <span class="token class-name">CSSModuleClasses</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token keyword">readonly</span> <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#125;</span><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'*.module.css'</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> classes<span class="token operator">:</span> CSSModuleClasses  <span class="token keyword">export</span> <span class="token keyword">default</span> classes<span class="token punctuation">&#125;</span><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'*.module.scss'</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> classes<span class="token operator">:</span> CSSModuleClasses  <span class="token keyword">export</span> <span class="token keyword">default</span> classes<span class="token punctuation">&#125;</span><span class="token comment">// ...</span><span class="token comment">// CSS</span><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'*.css'</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> css<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token keyword">export</span> <span class="token keyword">default</span> css<span class="token punctuation">&#125;</span><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'*.scss'</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> css<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token keyword">export</span> <span class="token keyword">default</span> css<span class="token punctuation">&#125;</span><span class="token comment">// ...</span><span class="token comment">// Built-in asset types</span><span class="token comment">// see `src/constants.ts`</span><span class="token comment">// images</span><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'*.jpg'</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> src<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token keyword">export</span> <span class="token keyword">default</span> src<span class="token punctuation">&#125;</span><span class="token comment">// ...</span><span class="token comment">// fonts</span><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'*.woff'</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> src<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token keyword">export</span> <span class="token keyword">default</span> src<span class="token punctuation">&#125;</span><span class="token comment">// ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你会发现，其实这里面包含的就是对于非实际代码文件导入的类型定义，包括了 CSS Modules、图片、视频等类型，通过这里的类型封装，在你导入这些文件时就也能获得基本的类型保障。</p><p>三斜线指令并不是导入类型的唯一方式，我们前面也提到了，可以使用 import 的方式来导入类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// vite-env.d.ts</span><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> ViteClientEnv <span class="token keyword">from</span> <span class="token string">'vite/client'</span><span class="token comment">// 或使用 import type</span><span class="token class-name"><span class="token keyword">import</span></span> <span class="token keyword">type</span> <span class="token operator">*</span> <span class="token keyword">as</span> ViteClientEnv <span class="token keyword">from</span> <span class="token string">'vite/client'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>类型定义包与类型声明其实就是这个脚手架所进行的额外工作，也是在日常开发中我们会重度依赖的部分。而除了这两者以外还有 tsconfig.json 相关配置，我们会在后面有专门的一节进行分析。</p><p>接下来，我们就开始学习如何在 React 中优雅地使用 TypeScript 。</p><h2 id="组件声明"><a href="#组件声明" class="headerlink" title="组件声明"></a>组件声明</h2><p>首先我们来想想，在 React 中如何声明一个（函数）组件。最简单的方式肯定是直接声明一个函数：</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx"><span class="token keyword">const</span> <span class="token function-variable function">Container</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">林不渡！</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对于组件的 props 类型，我们可以就像在函数中标注参数类型一样：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">IContainerProps</span> <span class="token punctuation">&#123;</span>  visible<span class="token operator">:</span> <span class="token builtin">boolean</span>  <span class="token function-variable function">controller</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token function-variable function">Container</span> <span class="token operator">=</span> <span class="token punctuation">(</span>props<span class="token operator">:</span> IContainerProps<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>p<span class="token operator">></span>林不渡！<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>属性默认值（defaultProps）也可以通过参数默认值的形式非常自然地进行声明：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token function-variable function">Container</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  visible <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token function-variable function">controller</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token operator">:</span> IContainerProps<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>p<span class="token operator">></span>林不渡！<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这么做看起来很朴素，但 TypeScript 仍然能把返回值类型推导出来，以上函数的类型可以被正确地推导为 <code>() =&gt; JSX.Element</code>。</p><p>但这样只能说明它是一个函数，并不能从类型层面上标明它是一个 React 组件，也无法约束它必须返回一个合法的组件。我们可以加上显式的类型标注来确保它返回一个有效组件：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> Container <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">JSX</span><span class="token punctuation">.</span>Element <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>p<span class="token operator">></span>林不渡！<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>JSX 是一个命名空间，来自于 <code>@types/react</code>。</p></blockquote><p>除了这种方式， React 中还提供了 FC 这一类型来支持更精确的类型声明：</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">IContainerProps</span> <span class="token punctuation">&#123;</span>  visible<span class="token operator">:</span> <span class="token builtin">boolean</span>  <span class="token function-variable function">controller</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> Container<span class="token operator">:</span> React<span class="token punctuation">.</span><span class="token constant">FC</span><span class="token operator">&lt;</span>IContainerProps<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  visible <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token function-variable function">controller</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token operator">:</span> IContainerProps<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">林不渡！</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>FC 是 FunctionComponent 的缩写，而 FunctionComponent 同样被作为一个类型导出，其使用方式是一致的，接受的唯一泛型参数即为这个组件的属性类型。</p><blockquote><p>其实还存在 StatelessComponent 、SFC 这两个同样指函数组件，使用方式也和 FC 一致的类型，但已经不推荐使用。</p></blockquote><p>我们来看 FC 的声明是什么样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">FunctionComponent<span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">(</span>props<span class="token operator">:</span> PropsWithChildren<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">,</span> context<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> ReactElement<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span>  propTypes<span class="token operator">?</span><span class="token operator">:</span> WeakValidationMap<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">undefined</span>  contextTypes<span class="token operator">?</span><span class="token operator">:</span> ValidationMap<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">undefined</span>  defaultProps<span class="token operator">?</span><span class="token operator">:</span> Partial<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">undefined</span>  displayName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，代表着属性类型的泛型参数 P 实际上就是直接传给了类型别名 PropsWithChildren ，而它其实就是为 Props 新增了一个 children 属性：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">PropsWithChildren<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">P</span> <span class="token operator">&amp;</span> <span class="token punctuation">&#123;</span> children<span class="token operator">?</span><span class="token operator">:</span> ReactNode <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也就是说我们连这个组件的 children 都约束了：</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx"><span class="token keyword">const</span> <span class="token function-variable function">App</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Container</span></span> <span class="token attr-name">visible</span> <span class="token attr-name">controller</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">TypeScript + React!</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Container</span></span><span class="token punctuation">></span></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但如果我们并不想这个组件接受 children，正如上面这个组件并没有消费 <code>props.children</code> ，此时应该怎么做？这就要说到，为什么在更严格的场景下其实不推荐使用 FC 了，请参考扩展阅读部分。</p><h3 id="组件泛型"><a href="#组件泛型" class="headerlink" title="组件泛型"></a>组件泛型</h3><p>使用简单函数和使用 FC 的重要差异之一就在于，使用 FC 时你无法再使用组件泛型。组件泛型即指，为你的组件属性再次添加一个泛型，比如这样：</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> PropsWithChildren <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">interface</span> <span class="token class-name">ICellProps<span class="token operator">&lt;</span>TData<span class="token operator">></span></span> <span class="token punctuation">&#123;</span>  <span class="token comment">//</span>  field<span class="token operator">:</span> <span class="token keyword">keyof</span> TData<span class="token punctuation">&#125;</span><span class="token keyword">const</span> Cell <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">></span></span><span class="token operator">></span><span class="token punctuation">(</span>  props<span class="token operator">:</span> PropsWithChildren<span class="token operator">&lt;</span>ICellProps<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">>></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">IDataStruct</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token function-variable function">App</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text">      &lt;Cell&lt;IDataStruct> field="name"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Cell</span></span><span class="token punctuation">></span></span><span class="token plain-text">      &lt;Cell&lt;IDataStruct> field="age"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Cell</span></span><span class="token punctuation">></span></span><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Cell 组件中，其 field 属性在接口结构中约束为 <code>keyof TData</code>，如在 App 中使用时我们基于 IDataStruct 进行约束，此时 Cell 组件的 field 属性就<strong>只能传入 name 与 age 两个值</strong>。也就是说，我们可以为这个组件显式声明泛型参数，来获得填充属性时的类型提示与检查。</p><p>但很明显，使用 FC 我们并不能做到这一点。</p><blockquote><p>以上示例代码来自于 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgeist-ui.dev%2Fzh-cn%2Fcomponents%2Ftable%23typescript-%E7%A4%BA%E4%BE%8B">Geist-UI</a>，一个我认为最符合自己审美的 UI 组件库。</p></blockquote><p>关于更多简单函数声明与 FC 的差异，我们会在扩展阅读中了解。另外，Class Component 不在本节要介绍的范围中。</p><p>现在我们进入下一个部分，看看 React 中都有哪些泛型坑位？</p><h2 id="泛型坑位"><a href="#泛型坑位" class="headerlink" title="泛型坑位"></a>泛型坑位</h2><p>常见的泛型坑位主要还是来自于日常使用最多的 Hooks，我们一个个来看。</p><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p>首先是 useState，可以由输入值隐式推导或者显式传入泛型：</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx"><span class="token keyword">const</span> <span class="token function-variable function">Container</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 推导为 string 类型</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>state1<span class="token punctuation">,</span> setState1<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">)</span>  <span class="token comment">// 此时类型为 string | undefined</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>state2<span class="token punctuation">,</span> setState2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是在显式传入泛型时，如果像上面的例子一样没有提供初始值，那么 state2 的类型实际上会是 <code>string | undefined</code>，这是因为在 useState 声明中对是否提供初始值的两种情况做了区分重载：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 提供了默认值</span><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>  initialState<span class="token operator">:</span> <span class="token constant">S</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">S</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">,</span> Dispatch<span class="token operator">&lt;</span>SetStateAction<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">>></span><span class="token punctuation">]</span><span class="token comment">// 没有提供默认值</span><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">S</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span>  <span class="token constant">S</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>  Dispatch<span class="token operator">&lt;</span>SetStateAction<span class="token operator">&lt;</span><span class="token constant">S</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">>></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外一个常见的场景是对于在初始阶段是一个空对象的状态，你可能会使用断言来这么做：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token punctuation">[</span>data<span class="token punctuation">,</span> setData<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span>IData<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">as</span> IData<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这么做的坏处在于，后续的调用方中会认为这是一个完整实现了 IData 结构的对象，可能会出现遗漏的未赋值属性，此时你也可以使用 Partial 类型标记它为可选：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token punctuation">[</span>data<span class="token punctuation">,</span> setData<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span>Partial<span class="token operator">&lt;</span>IData<span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你需要消费 useState 返回值的类型，可以搭配 ReturnType：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 相当于 useState(0) 的返回值类型</span><span class="token keyword">type</span> <span class="token class-name">State</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token keyword">typeof</span> useState<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">>></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="useCallback-与-useMemo"><a href="#useCallback-与-useMemo" class="headerlink" title="useCallback 与 useMemo"></a>useCallback 与 useMemo</h3><p>然后是 useCallback 与 useMemo，它们的泛型参数分别表示包裹的函数和计算产物，使用方式类似，也分为<strong>隐式推导</strong>与<strong>显式提供</strong>两种：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token function-variable function">Container</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 泛型推导为 (input: number) => boolean</span>  <span class="token keyword">const</span> handler1 <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> input <span class="token operator">></span> <span class="token number">599</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// 显式提供为 (input: number, compare: boolean) => boolean</span>  <span class="token keyword">const</span> handler2 <span class="token operator">=</span> useCallback<span class="token operator">&lt;</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> compare<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">boolean</span><span class="token operator">></span><span class="token punctuation">(</span>    <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> input <span class="token operator">></span> <span class="token number">599</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token punctuation">)</span>  <span class="token comment">// 推导为 string</span>  <span class="token keyword">const</span> result1 <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token string">'some-expensive-process'</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// 显式提供</span>  <span class="token keyword">const</span> result2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useMemo</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token punctuation">&#123;</span> name<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#125;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常情况下，我们不会主动为 useCallback 提供泛型参数，因为其传入的函数往往已经确定。而为 useMemo 提供泛型参数则要常见一些，因为我们可能希望通过这种方式来约束 useMemo 最后的返回值。</p><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p>useReducer 可以被视为更复杂一些的 useState，它们关注的都是数据的变化。不同的是 useReducer 中只能由 reducer 按照特定的 action 来修改数据，但 useState 则可以随意修改。useReducer 有三个泛型坑位，分别为 reducer 函数的类型签名、数据的结构以及初始值的计算函数，我们直接看实际使用即可：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useReducer <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">const</span> initialState <span class="token operator">=</span> <span class="token punctuation">&#123;</span> count<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">Actions</span> <span class="token operator">=</span>  <span class="token operator">|</span> <span class="token punctuation">&#123;</span>      type<span class="token operator">:</span> <span class="token string">'inc'</span>      payload<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        count<span class="token operator">:</span> <span class="token builtin">number</span>        max<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token operator">|</span> <span class="token punctuation">&#123;</span>      type<span class="token operator">:</span> <span class="token string">'dec'</span>      payload<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        count<span class="token operator">:</span> <span class="token builtin">number</span>        min<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">reducer</span><span class="token punctuation">(</span>state<span class="token operator">:</span> <span class="token keyword">typeof</span> initialState<span class="token punctuation">,</span> action<span class="token operator">:</span> Actions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token string">'inc'</span><span class="token operator">:</span>      <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>        count<span class="token operator">:</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>max          <span class="token operator">?</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>count<span class="token punctuation">,</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>max<span class="token punctuation">)</span>          <span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>count<span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span>    <span class="token keyword">case</span> <span class="token string">'dec'</span><span class="token operator">:</span>      <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>        count<span class="token operator">:</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>min          <span class="token operator">?</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>count<span class="token punctuation">,</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>min<span class="token punctuation">)</span>          <span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">-</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>count<span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span>    <span class="token keyword">default</span><span class="token operator">:</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Unexpected Action Received.'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> initialState<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span><span class="token operator">></span>      Count<span class="token operator">:</span> <span class="token punctuation">&#123;</span>state<span class="token punctuation">.</span>count<span class="token punctuation">&#125;</span>      <span class="token operator">&lt;</span>button        onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>          <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> type<span class="token operator">:</span> <span class="token string">'dec'</span><span class="token punctuation">,</span> payload<span class="token operator">:</span> <span class="token punctuation">&#123;</span> count<span class="token operator">:</span> <span class="token number">599</span><span class="token punctuation">,</span> min<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token operator">></span>        <span class="token operator">-</span><span class="token punctuation">(</span>min<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>      <span class="token operator">&lt;</span>button        onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>          <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>            type<span class="token operator">:</span> <span class="token string">'inc'</span><span class="token punctuation">,</span>            payload<span class="token operator">:</span> <span class="token punctuation">&#123;</span>              count<span class="token operator">:</span> <span class="token number">599</span><span class="token punctuation">,</span>              max<span class="token operator">:</span> <span class="token number">599</span><span class="token punctuation">,</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>          <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token operator">></span>        <span class="token operator">+</span><span class="token punctuation">(</span>max<span class="token operator">:</span> <span class="token number">599</span><span class="token punctuation">)</span>      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子中，useReducer 的泛型参数分别被填充为 reducer 函数的类型签名，以及其初始状态：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Reducer<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>prevState<span class="token operator">:</span> <span class="token constant">S</span><span class="token punctuation">,</span> action<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">S</span><span class="token keyword">type</span> <span class="token class-name">ReducerState<span class="token operator">&lt;</span><span class="token constant">R</span> <span class="token keyword">extends</span> Reducer<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">>></span></span> <span class="token operator">=</span> <span class="token constant">R</span> <span class="token keyword">extends</span> <span class="token class-name">Reducer<span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">S</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">></span></span>  <span class="token operator">?</span> <span class="token constant">S</span>  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">useReducer</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">R</span> <span class="token keyword">extends</span> Reducer<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span>  reducer<span class="token operator">:</span> <span class="token constant">R</span><span class="token punctuation">,</span>  initialState<span class="token operator">:</span> ReducerState<span class="token operator">&lt;</span><span class="token constant">R</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span>ReducerState<span class="token operator">&lt;</span><span class="token constant">R</span><span class="token operator">></span><span class="token punctuation">,</span> Dispatch<span class="token operator">&lt;</span>ReducerAction<span class="token operator">&lt;</span><span class="token constant">R</span><span class="token operator">>></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析一下这里的填充：R 被填充为了一整个函数类型，而 <code>ReducerState&lt;R&gt;</code> 实际上就是提取了 reducer 中代表 state 的参数，即状态的类型，在这里即是 <code>&#123; count: number &#125;</code> 这么一个结构。</p><p>需要注意的是，在 reducer 中其实也应用了我们此前提到过的<strong>可辨识联合类型概念</strong>，这里的 <code>action.type</code> 即为可辨识属性，通过 type 判断，我们就能在每一个 case 语句中获得联合类型对应分支的类型。</p><h3 id="useRef-与-useImperativeHandle"><a href="#useRef-与-useImperativeHandle" class="headerlink" title="useRef 与 useImperativeHandle"></a>useRef 与 useImperativeHandle</h3><p>useRef 的常见使用场景主要包括两种，存储一个 DOM 元素引用和持久化保存一个值。这两者情况对应的类型其实也是不同的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token function-variable function">Container</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> domRef <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span>HTMLDivElement<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> valueRef <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">599</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token function-variable function">operateRef</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    domRef<span class="token punctuation">.</span>current<span class="token operator">?.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    valueRef<span class="token punctuation">.</span>current <span class="token operator">+=</span> <span class="token number">1</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">&#123;</span>domRef<span class="token punctuation">&#125;</span><span class="token operator">></span>      <span class="token operator">&lt;</span>p<span class="token operator">></span>林不渡<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 domRef，此时其类型（current）会被推断为 <code>RefObject&lt;HTMLDivElement&gt;</code>，而 valueRef 的值类型则为 <code>MutableRefObject&lt;number&gt;</code>，这是完全符合预期的。因为我们并不会去修改挂载了 DOM 引用的 ref，而确实会修改值引用的 ref ，所以后者会是 Mutable 的。</p><p>然而实际上，这一差异并不是通过判断是否被应用在了 DOM 引用来实现的（也不需要做到如此智能），从 useRef 的类型定义可以看出，对于初始值为 null 的 useRef，其类型均会被推导为 RefObject：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>initialValue<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> MutableRefObject<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>initialValue<span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token operator">:</span> RefObject<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> MutableRefObject<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>HTMLDivElement 这一类型来自于 TypeScript 内置，在使用 ref 来引用 DOM 元素时，你应当使用尽可能精确的元素类型，如 HTMLInputElement、HTMLIFrameElement 等，而不是 HTMLElement 这样宽泛的定义，因为这些精确元素定义的内部封装了更加具体的类型定义，包括 HTML 属性、事件入参等。</p></blockquote><p>对于 useImperativeHandle ，可能很多同学并不熟悉，可以参考 <a href="https://juejin.cn/post/6888616874171432973">useRef 三兄弟</a> 这篇文章来了解具体使用。简单地说，这个 hook 接受一个 ref 、一个函数、一个依赖数组。这个函数的返回值会被挂载到 ref 上，常见的使用方式是用于实现<strong>父组件调用子组件方法</strong>：子组件将自己的方法挂载到 ref 后，父组件就可以通过 ref 来调用此方法。</p><p>我们来看具体的例子而后依次讲解：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>  useRef<span class="token punctuation">,</span>  useImperativeHandle<span class="token punctuation">,</span>  forwardRef<span class="token punctuation">,</span>  ForwardRefRenderFunction<span class="token punctuation">,</span><span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">interface</span> <span class="token class-name">IRefPayload</span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">controller</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token function-variable function">Parent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> childRef <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span>IRefPayload<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token function-variable function">invokeController</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    childRef<span class="token punctuation">.</span>current<span class="token operator">?.</span><span class="token function">controller</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span><span class="token operator">></span>      <span class="token operator">&lt;</span>Child ref<span class="token operator">=</span><span class="token punctuation">&#123;</span>childRef<span class="token punctuation">&#125;</span> <span class="token operator">/</span><span class="token operator">></span>      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span>invokeController<span class="token punctuation">&#125;</span><span class="token operator">></span>invoke controller<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">IChildPropStruct</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">IExtendedRefPayload</span> <span class="token keyword">extends</span> <span class="token class-name">IRefPayload</span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">disposer</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> Child <span class="token operator">=</span> <span class="token generic-function"><span class="token function">forwardRef</span><span class="token generic class-name"><span class="token operator">&lt;</span>IRefPayload<span class="token punctuation">,</span> IChildPropStruct<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> ref<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token function-variable function">internalController</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Internal Controller!'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token generic-function"><span class="token function">useImperativeHandle</span><span class="token generic class-name"><span class="token operator">&lt;</span>IRefPayload<span class="token punctuation">,</span> IExtendedRefPayload<span class="token operator">></span></span></span><span class="token punctuation">(</span>    ref<span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>        controller<span class="token operator">:</span> internalController<span class="token punctuation">,</span>        <span class="token function-variable function">disposer</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>IRefPayload 描述了我们将会在 ref 上挂载的对象结构。</li><li>在函数组件中，接受 ref 的函数组件（子组件）需要被 forwardRef 包裹才能正确接收到 ref 对象，其接受两个泛型参数，分别为 ref 的类型与此组件的属性类型。</li><li>useImperativeHandle 中传入了 ref 以及一个返回两个方法的函数，它具有两个泛型参数，分别从传入的 ref 以及函数的返回值类型中进行类型推导。在这里我们显式传入了与推导不一致的第二个泛型参数，以此提供了额外的返回值类型检查。</li></ul><p>useImperativeHandle 并非常用的 hook，但在某些场景下也确实有奇效。</p><p>除了以上介绍的这些 hooks 以外，还有 useContext、useEffect 等常用的 hooks，但它们或是过于简单或是不存在泛型坑位。这里我们就不做介绍，如果你有兴趣，直接阅读其类型源码即可。</p><h2 id="内置类型定义"><a href="#内置类型定义" class="headerlink" title="内置类型定义"></a>内置类型定义</h2><p>除了上面介绍的泛型坑位以外，在 React 中想要用好 TypeScript 的另一个关键因素就是使用 <code>@types/react</code> 提供的类型定义，最常见的就是事件类型，比如输入框值变化时的 ChangeEvent 和鼠标事件通用的 MouseEvent：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useState <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> ChangeEvent<span class="token punctuation">,</span> MouseEvent <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">const</span> <span class="token function-variable function">Container</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>v<span class="token punctuation">,</span> setV<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token function-variable function">handleChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token operator">:</span> ChangeEvent<span class="token operator">&lt;</span>HTMLInputElement<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token operator">:</span> MouseEvent<span class="token operator">&lt;</span>HTMLButtonElement<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span><span class="token operator">></span>      <span class="token operator">&lt;</span>input value<span class="token operator">=</span><span class="token punctuation">&#123;</span>v<span class="token punctuation">&#125;</span> onChange<span class="token operator">=</span><span class="token punctuation">&#123;</span>handleChange<span class="token punctuation">&#125;</span> <span class="token operator">/</span><span class="token operator">></span>      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">&#123;</span>handleClick<span class="token punctuation">&#125;</span><span class="token operator">></span>Click me<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，ChangeEvent 和 MouseEvent 上还具有一个泛型坑位，用于指定发生此事件的元素类型，我们可以在这里进一步传入 <strong>HTMLButtonElement</strong> 这样更精确的元素类型获得更严格的类型检查。</p><p>除了使用 ChangeEvent 作为参数类型，React 还提供了整个函数的类型签名，如 ChangeEventHandler：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> handleChange<span class="token operator">:</span> ChangeEventHandler<span class="token operator">&lt;</span>HTMLInputElement<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于上下文类型的存在，此时就无需再为 e 声明类型了，它会自动被推导为 <code>ChangeEvent&lt;HTMLInputElement&gt;</code> 。</p><p>类似的事件定义还有非常多，如 FormEvent、TouchEvent、DragEvent 等，但无需对所有定义都了解，在实际用到时再去导入即可。需要注意的是，由于 InputEvent <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FInputEvent">并非在所有浏览器都得到了支持</a>，因此并不存在对应的类型定义，你可以使用 KeyboardEvent 来代替。</p><p>除了这些事件类型以外，还有一个常见的类型是在你声明组件属性中的样式时会用到的，那就是 CSSProperties ，它描述了所有的 CSS 属性及对应的属性值类型，你也可以直接用它来检查 CSS 样式时的值：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> CSSProperties <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">IContainerProps</span> <span class="token punctuation">&#123;</span>  style<span class="token operator">:</span> CSSProperties<span class="token punctuation">&#125;</span><span class="token keyword">const</span> css<span class="token operator">:</span> CSSProperties <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  display<span class="token operator">:</span> <span class="token string">'flex'</span><span class="token punctuation">,</span>  alignContent<span class="token operator">:</span> <span class="token string">'center'</span><span class="token punctuation">,</span>  justifyContent<span class="token operator">:</span> <span class="token string">'center'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token function-variable function">Container</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span> style <span class="token punctuation">&#125;</span><span class="token operator">:</span> IContainerProps<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token punctuation">&#123;</span>style<span class="token punctuation">&#125;</span><span class="token operator">></span>林不渡！<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="其他内置类型"><a href="#其他内置类型" class="headerlink" title="其他内置类型"></a>其他内置类型</h3><p>还有一部分内置类型并不是日常开发中常用的，而是仅在组件库开发等场景时才会使用到，这里我们也做简单地介绍。</p><h4 id="ComponentProps"><a href="#ComponentProps" class="headerlink" title="ComponentProps"></a>ComponentProps</h4><p>当你基于原生 HTML 元素去封装组件时，通常会需要将这个原生元素的所有 HTML 属性都保留下来作为组件的属性，此时你肯定不能一个个声明所有属性，那么就可以使用 ComponentProps 来提取出一个元素上所有的属性：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> ComponentProps <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">interface</span> <span class="token class-name">IButtonProps</span> <span class="token keyword">extends</span> <span class="token class-name">ComponentProps<span class="token operator">&lt;</span><span class="token string">'button'</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span>  size<span class="token operator">?</span><span class="token operator">:</span> <span class="token string">'small'</span> <span class="token operator">|</span> <span class="token string">'large'</span>  link<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token function-variable function">Button</span> <span class="token operator">=</span> <span class="token punctuation">(</span>props<span class="token operator">:</span> IButtonProps<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>button <span class="token punctuation">&#123;</span><span class="token operator">...</span>props<span class="token punctuation">&#125;</span><span class="token operator">></span><span class="token punctuation">&#123;</span>props<span class="token punctuation">.</span>children<span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了对原生 DOM 元素使用以外，这一用法在使用组件库时也有奇效，比如组件库只导出了这个组件而没有导出这个组件的属性类型定义，而我们又需要基于这个组件进行定制封装，此时就可以使用 ComponentProps 去提取它的属性类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Button <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'ui-lib'</span><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> ComponentProps <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">interface</span> <span class="token class-name">IButtonProps</span> <span class="token keyword">extends</span> <span class="token class-name">ComponentProps<span class="token operator">&lt;</span>Button<span class="token operator">></span></span> <span class="token punctuation">&#123;</span>  display<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token function-variable function">EnhancedButton</span> <span class="token operator">=</span> <span class="token punctuation">(</span>props<span class="token operator">:</span> IButtonProps<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>Button <span class="token punctuation">&#123;</span><span class="token operator">...</span>props<span class="token punctuation">&#125;</span><span class="token operator">></span><span class="token punctuation">&#123;</span>props<span class="token punctuation">.</span>children<span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>由于 React 中 ref 的存在，有些时候我们会希望区分组件使用 ref 和没使用 ref 的情况，此时可以使用内置类型 ComponentPropsWithRef 或 ComponentPropsWithoutRef ，其使用方式与 ComponentProps 一致。</p></blockquote><p>ComponentProps 也可以用来提取一个 React 组件的属性类型，其内部实现对 HTML 元素和 React 组件这两种情况也做了区分：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ComponentProps<span class="token operator">&lt;</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">JSX</span><span class="token punctuation">.</span>IntrinsicElements <span class="token operator">|</span> JSXElementConstructor<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span><span class="token operator">></span></span> <span class="token operator">=</span>  <span class="token comment">// React 组件</span>  <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">JSXElementConstructor<span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">P</span><span class="token operator">></span></span>    <span class="token operator">?</span> <span class="token constant">P</span>    <span class="token operator">:</span> <span class="token comment">// HTML 元素</span>    <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">JSX</span><span class="token punctuation">.</span>IntrinsicElements    <span class="token operator">?</span> <span class="token constant">JSX</span><span class="token punctuation">.</span>IntrinsicElements<span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">]</span>    <span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ReactElement-与-ReactNode"><a href="#ReactElement-与-ReactNode" class="headerlink" title="ReactElement 与 ReactNode"></a>ReactElement 与 ReactNode</h4><p>在前面的例子中你可能注意到了 ReactElement 与 ReactNode 这两个类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">PropsWithChildren<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">P</span> <span class="token operator">&amp;</span> <span class="token punctuation">&#123;</span> children<span class="token operator">?</span><span class="token operator">:</span> ReactNode <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">FunctionComponent<span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">(</span>props<span class="token operator">:</span> PropsWithChildren<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">,</span> context<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> ReactElement<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ReactElement 是 createElement、cloneElement 等 factory 方法的返回值类型，它本质上指的是一个有效的 JSX 元素，即 <code>JSX.Element</code>。而 ReactNode 可以认为包含了 ReactElement ，它还包含 null、undefined 以及 ReactFragment 等一些特殊的部分，其类型定义如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ReactText</span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token keyword">type</span> <span class="token class-name">ReactChild</span> <span class="token operator">=</span> ReactElement <span class="token operator">|</span> ReactText<span class="token keyword">type</span> <span class="token class-name">ReactNode</span> <span class="token operator">=</span>  <span class="token operator">|</span> ReactChild  <span class="token operator">|</span> ReactFragment  <span class="token operator">|</span> ReactPortal  <span class="token operator">|</span> <span class="token builtin">boolean</span>  <span class="token operator">|</span> <span class="token keyword">null</span>  <span class="token operator">|</span> <span class="token keyword">undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="其他工程实践"><a href="#其他工程实践" class="headerlink" title="其他工程实践"></a>其他工程实践</h2><p>介绍了上面的项目配置与组件声明、泛型坑位相关内容以后，我们其实已经基本了解了 React 项目中使用 TypeScript 的注意事项。然而，还有一些概念涉及到项目的规范部分，我们在这里统一进行讲解。</p><p>需要注意的是，这些项目规范具有强烈的个人偏好风格，它们并不是必须严格遵守的规则，只是我个人在项目开发中习惯使用的一套规范，你可以按照自己的喜好来调整这些规范。</p><h3 id="项目中的类型声明文件"><a href="#项目中的类型声明文件" class="headerlink" title="项目中的类型声明文件"></a>项目中的类型声明文件</h3><p>在实际应用中使用 TypeScript 进行开发时，我们往往需要大量的类型代码，而如何存放这些类型代码，其实就需要预先有一个明确的规范。目前我使用的方式是，在项目中使用一个专门的文件夹存放类型代码，其中又按照这些类型的作用进行了划分，其分布大致是这样的：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">PROJECT├── src│   ├── types│   │   ├── shared.ts│   │   ├── [biz].ts│   │   ├── request.ts│   │   ├── tool.ts│   ├── typings.d.ts└── tsconfig.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们来依次讲解下这些类型声明文件的作用：</p><ul><li><p><code>shared.ts</code>，被其他类型定义所使用的类型，如简单的联合类型封装、简单的结构工具类型等。</p></li><li><p><code>[biz].ts</code>，与业务逻辑对应的类型定义，比如 <code>user.ts</code> <code>module.ts</code> 等，推荐的方式是在中大型项目中尽可能按照业务模型来进行细粒度的拆分。</p></li><li><p><code>request.ts</code>，请求相关的类型定义，推荐的方式是定义响应结构体，然后使用 biz 中的业务逻辑类型定义进行填充：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> Status <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./shared'</span><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">IRequestStruct<span class="token operator">&lt;</span>TData <span class="token operator">=</span> <span class="token builtin">never</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span>  status<span class="token operator">:</span> Status  code<span class="token operator">:</span> <span class="token builtin">number</span>  data<span class="token operator">:</span> TData<span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">IPaginationRequestStruct<span class="token operator">&lt;</span>TData <span class="token operator">=</span> <span class="token builtin">never</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span>  status<span class="token operator">:</span> Status  curPage<span class="token operator">:</span> <span class="token builtin">number</span>  totalCount<span class="token operator">:</span> <span class="token builtin">number</span>  hasNextPage<span class="token operator">:</span> <span class="token builtin">boolean</span>  data<span class="token operator">:</span> TData<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际使用时：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> IPaginationRequestStruct <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"@/types/request"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> IUserProfile <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"@/types/user"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">function</span> fetchUserList<span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>IPaginationRequestStruct<span class="token operator">&lt;</span>IUserProfile<span class="token operator">>></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过这种方式，你的类型代定义之间就能够建立起清晰的、和业务逻辑一致的引用关系。</p></li><li><p><code>tool.ts</code>，工具类型定义，一般是推荐把比较通用的工具类型抽离到专门的工具类型库中，这里只存放使用场景特殊的部分。</p></li><li><p><code>typings.d.ts</code>，全局的类型声明，包括非代码文件的导入、无类型 npm 包的类型声明、全局变量的类型定义等等，你也可以进一步拆分为 <code>env.d.ts</code> <code>runtime.d.ts</code> <code>module.d.ts</code> 等数个各司其职的声明文件。</p></li></ul><p>在实际场景中，这一规范的粒度并不一定能够满足你的需要，但你仍然可以按照这一思路进行类型定义的梳理和妥善放置。另外，我们并不需要将所有的类型定义都专门放到这个文件夹里，比如仅被组件自身消费的类型就应该使用就近原则，直接和组件代码一起即可。</p><h3 id="组件与组件类型"><a href="#组件与组件类型" class="headerlink" title="组件与组件类型"></a>组件与组件类型</h3><p>在 React 父子组件中一个常见的场景是，父组件导入各个子组件，传递属性时会进行额外的数据处理，其结果的类型被这多个子组件共享，而这个类型又仅被父子组件消费，不应当放在全局的类型定义中。此时我推荐的方式是，将这个类型定义在父组件中，子组件使用仅类型导入去导入这个类型，由于值空间与类型空间是隔离的，因此我们并不需要担心循环引用：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// Parent.tsx</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ChildA <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./ChildA'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ChildB <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./ChildB'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ChildC <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./ChildC'</span><span class="token comment">//  被多个子组件消费的类型</span><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">ISpecialDataStruct</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token function-variable function">Parent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> data<span class="token operator">:</span> ISpecialDataStruct <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span><span class="token operator">></span>      <span class="token operator">&lt;</span>ChildA inputA<span class="token operator">=</span><span class="token punctuation">&#123;</span>data<span class="token punctuation">&#125;</span> <span class="token operator">/</span><span class="token operator">></span>      <span class="token operator">&lt;</span>ChildB inputB<span class="token operator">=</span><span class="token punctuation">&#123;</span>data<span class="token punctuation">&#125;</span> <span class="token operator">/</span><span class="token operator">></span>      <span class="token operator">&lt;</span>ChildC inputC<span class="token operator">=</span><span class="token punctuation">&#123;</span>data<span class="token punctuation">&#125;</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// ChildA.tsx</span><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> ISpecialDataStruct <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./parent'</span><span class="token keyword">interface</span> <span class="token class-name">IAProp</span> <span class="token punctuation">&#123;</span>  inputA<span class="token operator">:</span> ISpecialDataStruct<span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">const</span> ChildA<span class="token operator">:</span> <span class="token constant">FC</span><span class="token operator">&lt;</span>IAProp<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节中，我们了解了 React 与 TypeScript 结合使用的方式，包括了项目的基础配置、组件声明方式及其优劣、Hooks 中的泛型坑位以及内置类型等等。这些概念其实本质上还是来自于 TypeScript 提供的能力，因此在你学习完毕小册前半部分的类型工具与类型编程概念后，这些对你来说已经不是特别复杂的知识，你需要的依旧只是在实践中去熟悉这些工具。因此，本着“渐进式学习”的理念，不妨再次找出你的 React 项目开始改造，看看是否有什么地方可以写得更优雅健壮一些。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="FC-并不是完美的"><a href="#FC-并不是完美的" class="headerlink" title="FC 并不是完美的"></a>FC 并不是完美的</h3><p>在前面组件声明部分我们已经了解了使用函数声明组件，以及使用 FC 声明组件的两种形式，也明确了主要差异：</p><ul><li>函数声明组件需要额外的返回值类型标注（<code>JSX.Element</code>）才能校验组件合法，并且可以再使用组件泛型来进一步确保类型安全。</li><li>FC 可以简化函数的声明，但是无法使用组件泛型。</li></ul><p>在这一部分，我们再来了解下这两者更多的差异，以及为什么说 FC 并不是完美的 （举例来说，在 Create-React-App 的最新模板代码里，已经不再使用 FC 了）。</p><p>我们再来看一看 FC 的类型定义：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">PropsWithChildren<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">P</span> <span class="token operator">&amp;</span> <span class="token punctuation">&#123;</span> children<span class="token operator">?</span><span class="token operator">:</span> ReactNode <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">FunctionComponent<span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">(</span>props<span class="token operator">:</span> PropsWithChildren<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">,</span> context<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> ReactElement<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你会发现 FC 的属性中是默认包含了 children 这一属性的（对应到 Vue 中则是插槽 slot 的概念），但并不是所有时候我们的组件都会包含一个 children：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token function-variable function">App</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span><span class="token operator">></span>      <span class="token operator">&lt;</span>ContainerWithoutChildren <span class="token operator">/</span><span class="token operator">></span>      <span class="token operator">&lt;</span>ContainerWithChildren<span class="token operator">></span>linbudu<span class="token operator">&lt;</span><span class="token operator">/</span>ContainerWithChildren<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你为 ContainerWithoutChildren 也传入了 children，虽然不会报错，但这个 children 实际上并不会渲染出来。</p><p>如果想让代码尽可能精准，实际上我们应该区分这两种情况，即组件是否会接受 children 并消费。而在 FC 中并没有进行区分，因此 React 中又提供了 VFC，即 VoidFunctionComponent ，它和 FC 的区别就在于属性中不包含 children：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">VFC</span><span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token operator">></span></span> <span class="token operator">=</span> VoidFunctionComponent<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token keyword">interface</span> <span class="token class-name">VoidFunctionComponent<span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">(</span>props<span class="token operator">:</span> <span class="token constant">P</span><span class="token punctuation">,</span> context<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> ReactElement<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span>  propTypes<span class="token operator">?</span><span class="token operator">:</span> WeakValidationMap<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">undefined</span>  contextTypes<span class="token operator">?</span><span class="token operator">:</span> ValidationMap<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">undefined</span>  defaultProps<span class="token operator">?</span><span class="token operator">:</span> Partial<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">undefined</span>  displayName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在 <code>@types/react</code> 18 版本后， FC 内部不再隐式包含 children 属性，因此 VFC 也就不再推荐使用。</p></blockquote><p>在组件库中还有一个常见场景，即我们使用组件同时作为命名空间，如 <code>Table.Column</code>，<code>Form.Item</code> 这样，如果使用 FC，你需要使用交叉类型补充上这些命名空间内的子组件：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">const</span> Table<span class="token operator">:</span> React<span class="token punctuation">.</span><span class="token constant">FC</span><span class="token operator">&lt;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token operator">></span> <span class="token operator">&amp;</span> <span class="token punctuation">&#123;</span>  Column<span class="token operator">:</span> React<span class="token punctuation">.</span><span class="token constant">FC</span><span class="token operator">&lt;</span>IColumnProps<span class="token operator">></span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">IColumnProps</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> Column<span class="token operator">:</span> React<span class="token punctuation">.</span><span class="token constant">FC</span><span class="token operator">&lt;</span>IColumnProps<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">&#125;</span>Table<span class="token punctuation">.</span>Column <span class="token operator">=</span> Column<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但对于简单函数来说就不需要如此：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> Table <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">JSX</span><span class="token punctuation">.</span>Element <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">IColumnProps</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> Column <span class="token operator">=</span> <span class="token punctuation">(</span>props<span class="token operator">:</span> IColumnProps<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">JSX</span><span class="token punctuation">.</span>Element <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">&#125;</span>Table<span class="token punctuation">.</span>Column <span class="token operator">=</span> Column<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下我们并不需要通过额外的类型标注，因为我们就只是简单地把一个组件挂到这个组件的属性上。</p><p>总的来说，FC 并不是在所有场景都能完美胜任的，当然除了上面提到的缺点以外，FC 也是有着一定优点的，如它还提供了 defaultProps、displayName 等一系列合法的 React 属性声明。而我的意见则是不使用 FC，直接使用简单函数和返回值标注的方式，这样一来你的函数组件就能够完全享受到作为一个函数的额外能力，包括但不限于泛型等等。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23.全链路 TypeScript 工具库，找到适合你的工具</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/23.%E5%85%A8%E9%93%BE%E8%B7%AF%20TypeScript%20%E5%B7%A5%E5%85%B7%E5%BA%93%EF%BC%8C%E6%89%BE%E5%88%B0%E9%80%82%E5%90%88%E4%BD%A0%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/23.%E5%85%A8%E9%93%BE%E8%B7%AF%20TypeScript%20%E5%B7%A5%E5%85%B7%E5%BA%93%EF%BC%8C%E6%89%BE%E5%88%B0%E9%80%82%E5%90%88%E4%BD%A0%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>在前面两节，我们了解了 TypeScript 在 React 与 ESLint 中的集成，而在实际项目开发时，我们还会接触许多与 TypeScript 相关的工具。如果按照作用场景来进行划分，这些工具大致可以划分为开发、校验、构建、类型四类。在这一节我们将介绍一批 TypeScript 工具库，讲解它们的基本使用，你可以在这里查找是否有符合你需求的工具。</p><p>本节的定位类似于 GitHub 上的 awesome-xxx 系列，我们更多是在简单介绍工具的作用与使用场景，不会有深入的讲解与分析。同时，本节的内容会持续更新，如果你还使用过其他好用的工具库，欢迎在评论区留言，我会随着更新不断收录更多的工具库。</p><h2 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h2><p>这一部分的工具主要在项目开发阶段使用。</p><h3 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h3><ul><li><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FTypeStrong%2Fts-node">ts-node</a> 与 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwclr%2Fts-node-dev">ts-node-dev</a>：我们在环境搭建一节中已经介绍过，用于直接执行 .ts 文件。其中 ts-node-dev 基于 ts-node 和 node-dev（类似于 nodemon）封装，能够实现监听文件改动并重新执行文件的能力。</p></li><li><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgilamran%2Ftsc-watch">tsc-watch</a>：它类似于 ts-node-dev，主要功能也是监听文件变化然后重新执行，但 tsc-watch 的编译过程更明显，也需要自己执行编译后的文件。你也可以通过 onSuccess 与 onFailure 参数，来在编译过程成功与失效时执行不同的逻辑。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">## 启动 tsc --watch，然后在成功时执行编译产物</span>tsc-watch <span class="token parameter variable">--onSuccess</span> <span class="token string">"node ./dist/server.js"</span><span class="token comment">## 在失败时执行</span>tsc-watch <span class="token parameter variable">--onFailure</span> <span class="token string">"echo 'Beep! Compilation Failed'"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fesbuild-kit%2Fesno">esno</a>，antfu 的作品。核心能力同样是执行 .ts 文件，但底层是 ESBuild 而非 tsc，因此速度上会明显更快。</p></li><li><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ftyped-install">typed-install</a>，我们知道有些 npm 包的类型定义是单独的 <code>@types/</code> 包，但我们并没办法分辨一个包需不需要额外的类型定义，有时安装了才发现没有还要再安装一次类型也挺烦躁的。typed-install 的功能就是在安装包时自动去判断这个包是否有额外的类型定义包，并为你自动地进行安装。其实我也写过一个类似的：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Finstall-with-typing">install-with-typing</a>。</p></li><li><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fkawamataryo%2Fsuppress-ts-errors">suppress-ts-error</a>，自动为项目中所有的类型报错添加 <code>@ts-expect-error</code> 或 <code>@ts-ignore</code> 注释，重构项目时很有帮助。</p></li><li><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmattpocock%2Fts-error-translator">ts-error-translator</a>，将 TS 报错翻译成更接地气的版本，并且会根据代码所在的上下文来详细说明报错原因，目前只有英文版本，中文版本感觉遥遥无期，因为 TS 的报错实在太多了……</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a32aab7b4974a2e90f4110aab24dbc0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="image.png"></p></li></ul><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><ul><li><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FYousefED%2Ftypescript-json-schema">typescript-json-schema</a>，从 TypeScript 代码生成 JSON Schema，如以下代码：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">Shape</span> <span class="token punctuation">&#123;</span>  <span class="token comment">/**   * The size of the shape.   *   * @minimum 0   * @TJS-type integer   */</span>  size<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会生成以下的 JSON Schema：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"$ref"</span><span class="token operator">:</span> <span class="token string">"#/definitions/Shape"</span><span class="token punctuation">,</span>  <span class="token property">"$schema"</span><span class="token operator">:</span> <span class="token string">"http://json-schema.org/draft-07/schema#"</span><span class="token punctuation">,</span>  <span class="token property">"definitions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"Shape"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"size"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>          <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"The size of the shape."</span><span class="token punctuation">,</span>          <span class="token property">"minimum"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"integer"</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"object"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbcherny%2Fjson-schema-to-typescript">json-schema-to-typescript</a>，和上面那位反过来，从 JSON Schema 生成 TypeScript 代码：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"Example Schema"</span><span class="token punctuation">,</span>  <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"object"</span><span class="token punctuation">,</span>  <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"firstName"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"string"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token property">"lastName"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"string"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token property">"age"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"Age in years"</span><span class="token punctuation">,</span>      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"integer"</span><span class="token punctuation">,</span>      <span class="token property">"minimum"</span><span class="token operator">:</span> <span class="token number">0</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token property">"hairColor"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"enum"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"black"</span><span class="token punctuation">,</span> <span class="token string">"brown"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"string"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"additionalProperties"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token property">"required"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"firstName"</span><span class="token punctuation">,</span> <span class="token string">"lastName"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">ExampleSchema</span> <span class="token punctuation">&#123;</span>  firstName<span class="token operator">:</span> <span class="token builtin">string</span>  lastName<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token comment">/**   * Age in years   */</span>  age<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span>  hairColor<span class="token operator">?</span><span class="token operator">:</span> <span class="token string">'black'</span> <span class="token operator">|</span> <span class="token string">'brown'</span> <span class="token operator">|</span> <span class="token string">'blue'</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>需要注意的是，JSON Schema 并不是我们常见到的。描述实际值的 JSON，它更像是 TS 类型那样的<strong>结构定义</strong>，存在着值类型、可选值、访问性等相关信息的描述，如 required、type、description 等字段，因此才能够它才能够与 TypeScript 之间进行转换。</p><h2 id="类型相关"><a href="#类型相关" class="headerlink" title="类型相关"></a>类型相关</h2><p>以下工具库主要针对类型，包括提供通用工具类型与对工具类型进行测试。</p><ul><li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsindresorhus%2Ftype-fest">type-fest</a>，不用多介绍了，目前 star 最多下载量最高的工具类型库，Sindre Sorhus 的作品，同时也是个人认为最接地气的一个工具类型库。</li><li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpiotrwitek%2Futility-types">utility-types</a>，包含的类型较少，但这个库是我类型编程的启蒙课，我们此前对 FunctionKeys、RequiredKeys 等工具类型的实现就来自于这个库。</li><li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fts-essentials">ts-essentials</a></li><li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpelotom%2Ftype-zoo">type-zoo</a></li><li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmillsp%2Fts-toolbelt">ts-toolbelt</a>，目前包含工具类型数量最多的一位，基本上能满足你的所有需要。</li><li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ftsd">tsd</a>，用于进行类型层面的单元测试，即验证工具类型计算结果是否是符合预期的类型，也是 Sindre Sorhus 的作品，同时 type-fest 中工具类型的单元测试就是基于它。</li><li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fdsherret%2Fconditional-type-checks">conditional-type-checks</a>，类似于 tsd，也是用于对类型进行单元测试。</li></ul><h2 id="校验阶段"><a href="#校验阶段" class="headerlink" title="校验阶段"></a>校验阶段</h2><p>以下这些工具通常用于在项目逻辑中进行具有实际逻辑的校验（而不同于 tsd 仅在类型层面）。</p><h3 id="逻辑校验"><a href="#逻辑校验" class="headerlink" title="逻辑校验"></a>逻辑校验</h3><ul><li><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fcolinhacks%2Fzod">zod</a>，核心优势在于与 TypeScript 的集成，如能从 Schema 中直接提取出类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> z <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'zod'</span><span class="token keyword">const</span> User <span class="token operator">=</span> z<span class="token punctuation">.</span><span class="token function">object</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  username<span class="token operator">:</span> z<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>User<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> username<span class="token operator">:</span> <span class="token string">'Ludwig'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// extract the inferred type</span><span class="token class-name"><span class="token keyword">type</span></span> User <span class="token operator">=</span> z<span class="token punctuation">.</span>infer<span class="token operator">&lt;</span><span class="token keyword">typeof</span> User<span class="token operator">></span><span class="token comment">// &#123; username: string &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我个人比较看好的一个库，在 tRPC、Blitz 等前后端一体交互的框架中能同时提供类型保障和 Schema 校验，同时和 Prisma 这一类库也有着很好地集成。最重要的是社区生态非常丰富，有许多自动生成的工具（<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frsinohara%2Fjson-to-zod">json-to-zod</a>、<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fkbkk%2Fabitia%2Ftree%2Fmaster%2Fpackages%2Fzod-dto">zod-nest-dto</a> 等）。</p></li><li><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftypestack%2Fclass-validator">class-validator</a>，TypeStack 的作品，基于装饰器来进行校验，我们会在后面的装饰器一节了解如何基于装饰器进行校验。</p></li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Post</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Length</span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>  title<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Contains</span></span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>  text<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">IsInt</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Min</span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Max</span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>  rating<span class="token operator">:</span> <span class="token builtin">number</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">IsEmail</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  email<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> post <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Post</span><span class="token punctuation">(</span><span class="token punctuation">)</span>post<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">'Hello'</span> <span class="token comment">// 错误</span>post<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">'this is a great post about hell world'</span> <span class="token comment">// 错误</span>post<span class="token punctuation">.</span>rating <span class="token operator">=</span> <span class="token number">11</span> <span class="token comment">// 错误</span>post<span class="token punctuation">.</span>email <span class="token operator">=</span> <span class="token string">'google.com'</span> <span class="token comment">// 错误</span><span class="token function">validate</span><span class="token punctuation">(</span>post<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>errors<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 查看是否返回了错误</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>errors<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'校验失败，错误信息: '</span><span class="token punctuation">,</span> errors<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'校验通过！'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fianstormtaylor%2Fsuperstruct">superstruct</a>，功能与使用方式类似于 zod，更老牌一些。</p></li><li><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsindresorhus%2Fow">ow</a>，用于函数参数的校验，我通常在 CLI 工具里大量使用。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> ow <span class="token keyword">from</span> <span class="token string">'ow'</span><span class="token keyword">const</span> <span class="token function-variable function">unicorn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token function">ow</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> ow<span class="token punctuation">.</span><span class="token builtin">string</span><span class="token punctuation">.</span><span class="token function">minLength</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// …</span><span class="token punctuation">&#125;</span><span class="token function">unicorn</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">//=> ArgumentError: Expected `input` to be of type `string` but received type `number`</span><span class="token function">unicorn</span><span class="token punctuation">(</span><span class="token string">'yo'</span><span class="token punctuation">)</span><span class="token comment">//=> ArgumentError: Expected string `input` to have a minimum length of `5`, got `yo`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpelotom%2Fruntypes">runtypes</a>，类似于 Zod，也是运行时的类型与 Schema 校验。</p></li></ul><h3 id="类型覆盖检查"><a href="#类型覆盖检查" class="headerlink" title="类型覆盖检查"></a>类型覆盖检查</h3><ul><li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Falexcanessa%2Ftypescript-coverage-report">typescript-coverage-report</a>，检查你的项目中类型的覆盖率，如果你希望项目的代码质量更高，可以使用这个工具来检查类型的覆盖程度，从我个人使用经验来看，大概 95% 左右就是一个比较平衡的程度了。类似于 Lint 工具，如果使用这一工具来约束项目代码质量，也可以放在 pre-commit 中进行。</li><li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fplantain-00%2Ftype-coverage">type-coverage</a>，前者的底层依赖，可以用来定制更复杂的场景。</li></ul><h2 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h2><p>以下工具主要在构建阶段起作用。</p><ul><li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fesbuild.github.io%2F">ESBuild</a>，应该无需过多介绍。需要注意的是 ESBuild 和 TypeScript Compiler 还是存在一些构建层面的差异，比如 ESBuild 无法编译装饰器（但可以使用插件，对含有装饰器的文件回退到 tsc 编译）。</li><li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fswc.rs%2F">swc</a>，也无需过多介绍。SWC 的目的是替代 Babel，因此它是可以直接支持装饰器等特性的。</li><li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ffork-ts-checker-webpack-plugin">fork-ts-checker-webpack-plugin</a>，Webpack 插件，使用额外的子进程来进行 TypeScript 的类型检查（需要禁用掉 ts-loader 自带的类型检查）。</li><li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fprivatenumber%2Fesbuild-loader">esbuild-loader</a>，基于 ESBuild 的 Webpack Loader，放在这里是因为它基本可以完全替代 ts-loader 来编译 ts 文件。</li><li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Frollup-plugin-dts">rollup-plugin-dts</a>，能够将你项目内定义与编译生成的类型声明文件重新进行打包。</li><li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fparceljs.org%2F">Parcel</a>，一个 Bundler，与 Webpack、Rollup 的核心差异是零配置，不需要任何 loader 或者 plugin 配置就能对常见基本所有的样式方案、语言方案、框架方案进行打包。我在之前搭过一个基于 Parcel 的项目起手式：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FLinbuduLab%2FParcel-Tsx-Template">Parcel-Tsx-Template</a>，可以来感受一下<strong>零配置</strong>是什么体验。</li></ul><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>这一节我们汇总了各个场景下的 TypeScript 工具库，就像开头所说，本节的内容会持续更新，如果你还使用过其它让你赞不绝口的工具库，欢迎在评论区或答疑群提交给我。</p><p>下一节，我们会来了解一个对你来说可能熟悉又陌生的名词：ECMAScript，包括它到底代表了什么，和 TypeScript 的关系如何，TypeScript 中的 ECMAScript 语法如何使用，以及未来的 ECMAScript 怎么样。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>24.说说 TypeScript 和 ECMAScript 之间那些事儿</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/24.%E8%AF%B4%E8%AF%B4%20TypeScript%20%E5%92%8C%20ECMAScript%20%E4%B9%8B%E9%97%B4%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/24.%E8%AF%B4%E8%AF%B4%20TypeScript%20%E5%92%8C%20ECMAScript%20%E4%B9%8B%E9%97%B4%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
      
        <content type="html"><![CDATA[<p>这一节，我们来讲解 TypeScript 与 ECMAScript 之间的关系。</p><p>首先，我们来理清经常看到的 ES / ECMAScript / TC39 等等概念到底是个啥。然后，一起看看 TypeScript 都提前实现了哪些 ECMAScript 语法，它们怎么用，到底有多好用。最后，在扩展阅读中，我们会聊到更多有趣的、正在进行中的 TC39 提案。要相信，未来的 JavaScript 一定会变得越来越好。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F20-ecmascript">ECMAScript</a></p></blockquote><h2 id="ECMAScript-与-TC39"><a href="#ECMAScript-与-TC39" class="headerlink" title="ECMAScript 与 TC39"></a>ECMAScript 与 TC39</h2><p>首先是 ECMAScript 这个单词，虽然 JavaScript 和 Java 没有关系，但 ECMAScript 和 ECMA （正确发音近似于<strong>诶可码</strong>（Script））确实是有关系的。ECMA 的全称是 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.ecma-international.org%2F">European Computer Manufacturers Association</a>，即<strong>欧洲计算机制造商协会</strong>。它并不是为了卖货而生的，这一国际组织的存在主要是维护各种计算机的相关标准，从硬件到软件到编程语言等等。</p><p>最初创建 JavaScript 这门语言的公司是网景（Netscape），主推产品即为网景浏览器。由于在和微软 IE 的竞争中落得下风，为了避免从此 Web 脚本的主导权从此落入微软手中，在 1996 年，网景将 JavaScript 的标准制定权交给了 ECMA 协会，因此有了 ECMAScript —— 也就是 JavaScript 的语言规范。<strong>而 ECMAScript 并不是一门语言，而是一门规范。</strong> 我们说的 ES5 / ES6 / ESNext 等等概念，实际上指的都是 JavaScript 这门语言规范的新版本。</p><p>ECMA 维护着数百条规范，这些规范的领域差异非常大。因此 ECMA 采用技术小组（<strong>Technical Committee，也称为技术委员会</strong>）的方式来管理这个规范，ECMAScript 对应的技术小组即是 TC39。目前 TC39 委员会的绝大部分成员来自于浏览器引擎厂商、互联网巨头公司等等，并且定期召开会议来讨论各个提案的进展。</p><p>那么，提案又是什么？首先，ECMAScript 中的新语法并不是委员会成员坐下来开个简单的会就决定引入到 JavaScript 中的。一个新语法必须先从草稿，也就是从提案开始。你可以把新语法想象成一条新法律，得要有人首先提出这条法律能解决目前的某一问题，然后法律专家、法院、国家都要通过，它才能最终被写到法律条文中。在 ECMAScript 中，一个提案被纳入规范要经历 5 个阶段。</p><ul><li>stage 0（<strong>strawman</strong>）：任何 TC39 的成员都可以提交。</li><li>stage 1（<strong>proposal</strong>）：进入此阶段就意味着这一提案被认为是<strong>正式</strong>的了，需要对此提案的场景与 API 进行详尽描述。要想进入 Stage 1，需要一位 TC39 成员作为负责人（champion）对这个提案具体的<strong>语法、语义和现有语法的冲突风险</strong>都进行详细讨论分析。</li><li>stage 2（<strong>draft</strong>）：要进入 Stage 2，需要完成<strong>包含提案所有内容的标准文本的初稿</strong>。理论上来说，这一阶段的提案，如果能最终被纳入规范，这之后的阶段中就不会被大改了，只接受增量修改。因为如果要大改，往往需要废弃掉整个提案，让 V2 版本从 Stage 0 开始重新来一遍（有点像删号重开）。</li><li>stage 3（<strong>candidate</strong>）：这一阶段的提案只有在遇到了重大问题才会修改，需要撰写非常完善的规范文档。进入 Stage 3 的前提条件是在规范文档的基础上，ECMAScript 官方的编辑以及指定 TC39 委员会成员签署了同意意见。通常来说提案进入这一阶段后，我们就能通过 Babel 插件或者各种 Polyfill 等提前试用上。</li><li>stage 4（<strong>finished</strong>）：这一阶段的提案将会被纳入到 ES 每年发布的规范之中，正式与大家见面。想要完成这最后一步，需要完成所有对应到提案内容的测试用例（用来给引擎产商们检查实现的兼容程度），以及官方编辑同意将其合并到 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftc39%2Fecma262">tc39/ecma262</a> 仓库。</li></ul><p>目前 TC39 会议的频率大概是两月一次，并且由于疫情的原因也从线上、线下结合改成了完全线上的模式。上面我们提到的 ecma262，这里的 262 意为 ECMAScript 是 ECMA 维护的第 262 条标准，目前它的最新版本是 2022 年发布的<a href="https://link.juejin.cn/?target=https%3A%2F%2F262.ecma-international.org%2F13.0%2F">第 13 版</a>，即 ES2022 或 ES13。当然，各位同学最熟悉的肯定还是 2015 年发布的 ES2015，即 ES6 这一版本。网上很多说法是将 ES2015 后的版本统称为 ES6，我不太认同的原因也就在于此。</p><p>说了这么多，想必你现在至少对 ECMAScript 和 TC39 到底是什么、它们的存在意义以及工作方式等等都有了一个大致了解。如果你想了解更多历史故事，我推荐阅读雪碧老师的作品： <a href="https://link.juejin.cn/?target=https%3A%2F%2Fcn.history.js.org%2Fpart-1.html">JavaScript 二十年</a>。</p><p>那么，ECMAScript 和 TypeScript 的关系又是啥？知道了 ECMAScript 的具体意义就比较好懂了。上面说到一个新语法从提出到最终成为 ECMAScript 的一部分，需要走完漫长的 Stage 0-4，如果这个语法真的究极无敌好用（比如我们下面要说的可选链、空值合并以及装饰器），实在是等不及想用怎么办？</p><p>聪明的你一定会想到 Babel，它能够将 ECMAScript 未纳入标准的语法进行降级（或将标准语法按照运行时环境降级），这样我们就可以放心使用未来的新语法，Babel 会帮我们编译好的。而 TypeScript 也支持这么个功能，或者说这就是它的核心功能之一。正如我们在开篇说的那样，TypeScript 其实就是类型能力加上一些新语法，而这些新语法绝大部分都来自于 ECMAScript，并且是在这些语法提案还没正式进入标准时，TypeScript 就对其进行了支持。在编译时，类型标注会直接被抹除，而这些新语法也会按照我们在 <code>tsconfig</code> 中的 <code>target</code> 配置进行对应降级。</p><p>那么，有哪些语法享受到了这一待遇？下面我们就来聊一聊 TypeScritp 中的部分 ESMAScript 语法，感受一下它们是不是真的如此好用。</p><h2 id="TypeScript-中的-ECMAScript-语法"><a href="#TypeScript-中的-ECMAScript-语法" class="headerlink" title="TypeScript 中的 ECMAScript 语法"></a>TypeScript 中的 ECMAScript 语法</h2><p>目前在 TypeScript 中，已经合入的 ECMAScript 语法主要有这么几个：</p><ul><li>可选链 Optional Chainning，即 <code>?.</code> 语法。</li><li>空值合并 Nullish Coalescing，即 <code>??</code> 语法。</li><li>逻辑赋值 Logical Assignment，即 <code>&amp;&amp;=</code>, <code>??=</code> 这一类语法。</li><li>装饰器，我们会用两节专门来讲解。</li><li>一些新增的方法，如 replaceAll 等。</li><li>Class 相关，如基于 <code>#</code> 的私有成员标注等。</li></ul><p>这篇文章中我们并不关注新增的方法以及 Class 相关语法，因为它们真的就是看一下文档的事。对于这些新增的方法，TypeScript 中可以通过在 <code>tsconfig</code> 的 <code>compilerOptions.lib</code> 配置中新增 <code>es2021</code>（对应的 es 版本）/<code>esnext</code> 来启用这些新的语法，而在 JavaScript 中想要使用则需要运行时支持或者使用 Polyfill（CoreJs，ES-Shims 等）。</p><p>对于可选链、空值合并以及逻辑赋值，前两者在 TS 3.7 版本引入，逻辑赋值则在 4.0 版本被引入，它们早在 ECMAScript 2021 就被正式吸收，你现在甚至可以在浏览器控制台使用这几个语法。而装饰器就是比较特殊的一位了，我们会在下一节装饰器一章详细地聊聊它的演进历史。</p><p>接下来，我们就来讲一讲可选链、空值合并以及逻辑赋值这三个语法，感受一下这些语法糖到底有多甜。</p><h3 id="可选链-Optional-Chainning"><a href="#可选链-Optional-Chainning" class="headerlink" title="可选链 Optional Chainning"></a>可选链 Optional Chainning</h3><p>在 JavaScript 中，如果访问一个嵌套多层的属性，为了避免出现 <code>Cannot read property of undefined</code> 这样的错误，我们通常会使用<strong>逻辑与</strong> <code>&amp;&amp;</code> 语法来确保在某一层出现空值时及时短路掉访问：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> inner <span class="token operator">=</span> obj <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">.</span>data <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">.</span>data<span class="token punctuation">.</span>innerProperty<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种写法虽然丑陋，但它确实能在一定程度上避免对空值的读取，但也只是一定程度上，为什么这么说？</p><p>上面的代码看起来很安全，但在某一步访问出现空值时，它返回的是上一步的值，而在属性的读取过程中，我们通常希望的是如果某一环节短路了，那返回一个 undefined 给我就好。否则，如果下面还存在对 <code>inner</code> 进行真值假值判断（<code>if(inner)</code>）的话，反而容易引发 Bug。</p><p>另外，逻辑与短路在属性嵌套过深时简直就是噩梦，使用可选链的 <code>?.</code> 语法，我们可以把它改写成这样：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> inner <span class="token operator">=</span> obj<span class="token operator">?.</span>data<span class="token operator">?.</span>innerProperty<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>除了更简洁的写法以外，可选链也更符合我们的预期：<strong>它会在短路时返回一个 undefined</strong>。可选链不仅能应用在属性访问，也可以用在计算属性访问以及方法调用上：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">obj<span class="token operator">?.</span><span class="token punctuation">[</span>expr<span class="token punctuation">]</span>obj<span class="token operator">?.</span><span class="token punctuation">[</span><span class="token operator">++</span>a<span class="token punctuation">]</span><span class="token comment">// 对应到 obj.func &amp;&amp; obj.func()</span>obj<span class="token operator">?.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在所有情况下，如果 <code>?.</code> 的左侧发生了短路，那么就会直接停止后续操作，比如不会去运行并计算表达式 <code>expr</code> 以及 <code>++a</code> 。通常可选链和空值合并搭配有奇效，我们继续往下看。</p><h3 id="空值合并-Nullish-Coalescing"><a href="#空值合并-Nullish-Coalescing" class="headerlink" title="空值合并 Nullish Coalescing"></a>空值合并 Nullish Coalescing</h3><p>如果说可选链是为了取代<strong>逻辑与</strong>（<code>&amp;&amp;</code>），那么空值合并就是为了取代<strong>逻辑或</strong>（<code>||</code>）。而逻辑或的主要使用场景之一就是提供默认值，如：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> foo <span class="token operator">=</span> someValue <span class="token operator">||</span> fallbackValue<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>逻辑或会在 <code>||</code> 左边被判断为 false 时，执行右边的逻辑，在这里即是赋值行为。看起来一切好像都很美好，但别忘了，由于 JavaScript 中无处不在的隐式转换，如果 <code>||</code> 左边是 <code>&quot;&quot;</code>/ <code>0</code> / <code>false</code>，都会被视为 false（false 虽然是 false，但它也是个值！），而我们希望的是<strong>仅在左边为 undefined 或 null 时，才去应用默认值</strong>。</p><p>大部分情况下我们可以直接使用 <code>??</code> 代替 <code>||</code>：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> foo <span class="token operator">=</span> someValue <span class="token operator">??</span> fallbackValue<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配合可选链：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> bar <span class="token operator">=</span> obj<span class="token operator">?.</span>a<span class="token operator">?.</span>b<span class="token operator">?.</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">??</span> fallbackValue<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>空值合并就如它的名字一样，只会对真正意义上的空值（null 与 undefined）进行处理。</p><p>而空值合并的语法如此近似于逻辑操作（<code>||</code>, <code>&amp;&amp;</code>），会不会有些基于逻辑操作的语法也能直接套用空值合并？当然可以，不然我们怎么介绍下面的逻辑赋值。</p><h3 id="逻辑赋值-Logical-Assignment"><a href="#逻辑赋值-Logical-Assignment" class="headerlink" title="逻辑赋值 Logical Assignment"></a>逻辑赋值 Logical Assignment</h3><p>实际上，逻辑赋值是在复合赋值的基础上演进而来（或者说关系一致）的，都是将一个操作符和赋值符号结合在一起。比如我们最常见的复合赋值：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">a <span class="token operator">=</span> a <span class="token operator">+</span> ba <span class="token operator">+=</span> ba <span class="token operator">=</span> a <span class="token operator">-</span> ba <span class="token operator">-=</span> ba <span class="token operator">=</span> a <span class="token operator">*</span> ba <span class="token operator">*=</span> b<span class="token comment">// 还有除法运算，就不演示了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复合赋值其实就是先执行操作，再将操作结果赋值给左边的变量。如 <code>a += b</code> 就是执行 <code>a + b</code>，然后将结果赋值给 <code>a</code>。</p><p>而逻辑赋值也是一样：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">a <span class="token operator">=</span> a <span class="token operator">||</span> ba <span class="token operator">||=</span> ba <span class="token operator">=</span> a <span class="token operator">&amp;&amp;</span> ba <span class="token operator">&amp;&amp;=</span> b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类比一下，逻辑赋值就是<strong>先执行逻辑操作，然后将结果赋值给左边的变量</strong>。这一语法其实在实际开发中有奇效，如 <code>a ||= b</code> 其实可以替代掉以下这段代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>a<span class="token punctuation">)</span> a <span class="token operator">=</span> b<span class="token comment">// 或者</span>a <span class="token operator">=</span> a <span class="token operator">?</span> a <span class="token operator">:</span> b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>既然逻辑操作符可以，那没道理我空值合并不行，毕竟我们长得这么像：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">a <span class="token operator">=</span> a <span class="token operator">??</span> ba <span class="token operator">??=</span> b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个时候为了区分逻辑赋值，我们可以称其为<strong>短路赋值</strong>。短路赋值在一些需要懒初始化的场景中非常好用，比如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">let</span> arr<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">(</span>arr <span class="token operator">??=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">)</span><span class="token comment">// 等价于以下这段</span>arr <span class="token operator">=</span> arr <span class="token operator">??</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 假设 arr 有可能在多处被初始化</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样，秉持着“一点一点精通 TypeScript ”的思路，我仍然推荐你在学习完本节后，使用可选链、空值合并以及短路赋值来替换部分老项目中的代码，并且在未来遇到短路与默认值场景时首先考虑这三位新同学。</p><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>这一节，我们了解了让人傻傻分不清楚的 ECMAScript、TypeScript、TC39 等概念之间的联系与实际意义，认识了三位对你来说或许是首次见面的新朋友：可选链、空值合并以及短路赋值。从现在开始，你可以在接下来的项目开发中不断提醒自己去使用它们，毕竟，兼得更简洁的语法以及更安全的逻辑，有谁会拒绝呢？</p><p>在下一节，我们会用很长的篇幅来聊聊 TypeScript 中的装饰器，从演进到了解、从原理到熟悉，最后来写一个你自己的依赖注入容器，让这些高大上的概念彻底为你所用。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="演进中的-TC39-提案"><a href="#演进中的-TC39-提案" class="headerlink" title="演进中的 TC39 提案"></a>演进中的 TC39 提案</h3><p>除了我们上面讲到的可选链、空值合并，以及大家都至少听说过的装饰器以外，还有许多演进中的 TC39 提案，我们可以简单归类为语法糖、新的内置方法、新的 API 等。在了解完本篇的核心内容以后，我们不妨来瞅几个有意思的提案，看看未来的 JavaScript 可能会是什么样的？</p><blockquote><p>以下介绍的提案状态均以本文写作时（2022-06-29，最近一次 TC39 会议为 2022 年 6 月召开）为准。另外，如果你想了解更多提案，可以阅读我此前的文章：<a href="https://juejin.cn/post/6974330720994983950">聊一聊进行中的 TC39 提案（stage1/2/3）</a>。</p></blockquote><h4 id="Record-和-Tuple：内置的不可变数据类型（Stage-2）"><a href="#Record-和-Tuple：内置的不可变数据类型（Stage-2）" class="headerlink" title="Record 和 Tuple：内置的不可变数据类型（Stage 2）"></a>Record 和 Tuple：内置的不可变数据类型（Stage 2）</h4><p>Record 与 Tuple 为 JavaScript 中引入了两个新的<strong>原始</strong>数据类型，分别对应到对象与数组（差异仅仅是声明时多了个 <code>#</code>）：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// Record</span><span class="token keyword">const</span> proposal <span class="token operator">=</span> #<span class="token punctuation">&#123;</span>  <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1234</span><span class="token punctuation">,</span>  <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'Record &amp; Tuple proposal'</span><span class="token punctuation">,</span>  <span class="token literal-property property">contents</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">...</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>  <span class="token literal-property property">keywords</span><span class="token operator">:</span> #<span class="token punctuation">[</span><span class="token string">'ecma'</span><span class="token punctuation">,</span> <span class="token string">'tc39'</span><span class="token punctuation">,</span> <span class="token string">'proposal'</span><span class="token punctuation">,</span> <span class="token string">'record'</span><span class="token punctuation">,</span> <span class="token string">'tuple'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token comment">// Tuple</span><span class="token keyword">const</span> measures <span class="token operator">=</span> #<span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">67</span><span class="token punctuation">,</span> <span class="token string">'measure error: foo happened'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，它们是原始类型，也就是说是按值比较而非对象那样按引用地址比较的。即 <code>#[1,2,3] === #[1,2,3]</code>，<code>#&#123; foo: &quot;bar&quot; &#125; === #&#123; foo: &quot;bar&quot; &#125;</code> 都是成立的。</p><p>这一提案自从在 2020 年 7 月会议上进入到 Stage 2 后，在后续直到最近的会议中，都一直没有取得进一步进展。原因之一即是这是两个全新的数据类型，它们的实现成本对于浏览器引擎产商来说是较高的。</p><h4 id="面向表达式的-Do-Expression-与-Throw-Expression（Stage-1）"><a href="#面向表达式的-Do-Expression-与-Throw-Expression（Stage-1）" class="headerlink" title="面向表达式的 Do Expression 与 Throw Expression（Stage 1）"></a>面向表达式的 Do Expression 与 Throw Expression（Stage 1）</h4><p>在 TC39 中，有相当一部分提案实际上有着函数式编程的理念背景，很难说这对 JavaScript 开发者来说是否是刚需，但它们确实能带给你另一种截然不同的编程范式。</p><p>这一提案的理念背景是函数式编程中的面向表达式（Expression-Oriented）语法，它长这个样子：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// do expression</span><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> tmp <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  tmp <span class="token operator">*</span> tmp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token function">h</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// async do expression</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">await</span> <span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'in.txt'</span><span class="token punctuation">)</span>  <span class="token keyword">let</span> query <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">ask</span><span class="token punctuation">(</span><span class="token string">'???'</span><span class="token punctuation">)</span>  <span class="token comment">// etc</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// throw expression</span><span class="token keyword">function</span> <span class="token function">getEncoder</span><span class="token punctuation">(</span><span class="token parameter">encoding</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> encoder <span class="token operator">=</span>    encoding <span class="token operator">===</span> <span class="token string">'utf8'</span>      <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">UTF8Encoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token operator">:</span> encoding <span class="token operator">===</span> <span class="token string">'utf16le'</span>      <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">UTF16Encoder</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>      <span class="token operator">:</span> encoding <span class="token operator">===</span> <span class="token string">'utf16be'</span>      <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">UTF16Encoder</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>      <span class="token operator">:</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Unsupported encoding'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显，这种语法能够帮助我们更好地组织代码与逻辑块的结构。但由于其毕竟带来了新的编程理念与语法，目前提案进度感人（其异步版本 async do expression 甚至还没有开始推进）。</p><h4 id="响应式编程与-Observable（Stage-1）"><a href="#响应式编程与-Observable（Stage-1）" class="headerlink" title="响应式编程与 Observable（Stage 1）"></a>响应式编程与 Observable（Stage 1）</h4><p>如果你了解过 RxJs，那么肯定马上就 get 到了这个提案想要干啥。<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftc39%2Fproposal-observable">proposal-observable</a> 这一提案尝试引入原生的 Observable 支持，你可以简单理解为这是用于处理较复杂异步场景的神器。但是，如果不是工作中确实需要处理复杂的异步场景，我个人并不推荐去深入学习 Observable 与 RxJs 相关的概念，简单了解即可。原因则是如果你没有实战场景，那么基本上对于 RxJs 的海量 API 只能抓瞎，或者学完之后很快就忘干净了（就像我一样）。</p><p>回到这个提案，它引入了部分 RxJs 中的核心概念，除 Observable 外还有 Observer、Subscriber 以及部分 Operators（目前只有 of、from 等基础的操作符）。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">listen</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> eventName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Observable</span><span class="token punctuation">(</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> <span class="token function-variable function">handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=></span> observer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span>    element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>eventName<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      element<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span>eventName<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="函数式理念的进一步发展"><a href="#函数式理念的进一步发展" class="headerlink" title="函数式理念的进一步发展"></a>函数式理念的进一步发展</h4><p>如果你对面向表达式的语法感到兴趣，那么我想下面这几个函数式操作符相关的提案也会引起你的关注。如果你想详细了解它们的使用与差异，可以阅读笔者此前的文章：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FFQiHCs0o8dJF3PSIJVwcXQ">你应该了解的 ECMAScript 函数操作符相关提案的最新进展</a>。</p><p>首先是 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftc39%2Fproposal-pipeline-operator">Pipeline Operator, proposal-pipeline-operator</a>，它引入了 <code>|&gt;</code> 语法来实现数据流编程的范式，如以下的 JavaScript 代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">double</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> __ <span class="token operator">=</span> <span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_ <span class="token operator">=</span> <span class="token function">double</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span>_ <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 Pipeline Operator ，我们能将以上代码改写为这样：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> __ <span class="token operator">=</span> <span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">></span> <span class="token function">double</span><span class="token punctuation">(</span><span class="token operator">%</span><span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">></span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">%</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中，<code>%</code> 表示上一个操作单元返回的值。</p><p>类似于 Pipeline Operator，<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjs-choi%2Fproposal-function-pipe-flow">Function Pipe/Flow, proposal-function-pipe-flow</a> 提案引入了两个 Function 对象上的系列方法：<code>pipe</code>/<code>pipeAsync</code> 与 <code>flow</code>/<code>flowAsync</code>。</p><p>其中，<code>Function.pipe</code> 接受一个输入值与一系列的一元函数，并从第一个一元函数开始，将上一次的调用结果传给下一个一元函数作为参数。<code>Function.pipe</code> 会在原地执行这些一元函数：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> pipe <span class="token punctuation">&#125;</span> <span class="token operator">=</span> Function<span class="token function">pipe</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> f0<span class="token punctuation">,</span> f1<span class="token punctuation">,</span> f2<span class="token punctuation">)</span> <span class="token comment">// 等同于 f2(f1(f0(5)))</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">// 等同于 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个系列 <code>Function.flow</code>，它接受一系列函数并组合成一个新的高阶函数，同时仍然保持传入的调用顺序。<code>Function.flow</code> 并不会立即执行这些一元函数，而是返回一个新的函数（类似于 <code>Lodash.flow</code>）。</p><p>对于首个函数，它可以是任意元函数（有任意个参数），而对于余下的函数都必须是一元函数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> flow <span class="token punctuation">&#125;</span> <span class="token operator">=</span> Function<span class="token keyword">const</span> f <span class="token operator">=</span> <span class="token function">flow</span><span class="token punctuation">(</span>f0<span class="token punctuation">,</span> f1<span class="token punctuation">,</span> f2<span class="token punctuation">)</span><span class="token comment">// 等同于 f = (...args) => f2(f1(f0(...args)))</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token keyword">const</span> g <span class="token operator">=</span> <span class="token function">flow</span><span class="token punctuation">(</span>g0<span class="token punctuation">)</span><span class="token comment">// 等同于 g = (...args) => g0(...args)</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而 pipeAsync、flowAsync 则分别是它们的异步版本，即应用对象变成了异步函数，这里不再赘述。</p><p>这两个提案都代表了数据流编程的理念，<strong>数据流编程（Dataflow Programming）</strong> 将程序拆分为数个独立的操作单元，而数据在操作单元间以有向图的形式流转，程序设计关注的重点在于动态的数据。想象流水线上的玩具，经过一个个工人手中后，一个木头架子依次被装上了四肢、脑袋、眼睛、开关…，这其实就是数据流在一个个独立单元之间的流动。而在数据流编程中，实际上我们关注的也是如何建立这个数据流转关系，包括需要存在的程序单元（函数）与程序执行的先后次序等。</p><h3 id="TC39-中的类型提案"><a href="#TC39-中的类型提案" class="headerlink" title="TC39 中的类型提案"></a>TC39 中的类型提案</h3><p>在 2022 年 3 月会议中，由 TypeScript 团队推进的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftc39%2Fproposal-type-annotations">Type Annotations</a> 也成功进入到 Stage1，这一提案的目的是引入和 TypeScript 中一样，会在编译时被擦除的类型标注，其语法也和 TypeScript 基本一致：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> Foo <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'foo'</span><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token operator">*</span> <span class="token keyword">as</span> Bar <span class="token keyword">from</span> <span class="token string">'bar'</span><span class="token keyword">let</span> x<span class="token operator">:</span> <span class="token builtin">string</span>x <span class="token operator">=</span> <span class="token string">'hello'</span>x <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">function</span> <span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> x <span class="token operator">===</span> y<span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">CoolBool</span> <span class="token operator">=</span> <span class="token builtin">boolean</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一提案其实也支持了泛型，但就目前来看，泛型还是过于激进了，可能会在后续拆分成独立的提案进行独立地迭代。另外，此提案目前不包括涉及到运行时代码（枚举，namespace 等）的功能，因为它真的就<strong>只是想引入编译时擦除类型</strong>。</p><p>我个人对于这一提案其实是持支持态度的，因为 TypeScript 其实就包含类型和新的 ECMAScript 语法两个部分，对应到编译时就是类型擦除和语法降级（类似 Babel）。随着浏览器等运行时对 ECMAScript 语法的支持越来越好，语法降级功能不再是刚需，那就只剩下类型擦除了。如果这一提案能够持续推进，成为语法降级的一部分，甚至运行时也直接原生支持此语法，那我觉得简直不要太美丽。当然，类型语法肯定是可选的，所以我们还是随时可以回到无拘无束的 JavaScript。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>25.装饰器与反射元数据：了解装饰器基本原理与应用</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/25.%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%B0%84%E5%85%83%E6%95%B0%E6%8D%AE%EF%BC%9A%E4%BA%86%E8%A7%A3%E8%A3%85%E9%A5%B0%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/25.%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%B0%84%E5%85%83%E6%95%B0%E6%8D%AE%EF%BC%9A%E4%BA%86%E8%A7%A3%E8%A3%85%E9%A5%B0%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>上一节我们了解了 TypeScript 与 ECMAScript 的关系，以及可选链与空值合并这两个 TypeScript 中的 ECMAScript 提案。其实，还有一个 ECMAScript 提案也已经成为 TypeScript 中相当重要的一部分，它就是装饰器。</p><p>装饰器语法在 Python、Java 等语言中都能见到，但在 JavaScript 中并没有被大量使用。一方面是因为，装饰器其实还不能被称为 JavaScript 的一部分，另一方面则是它对应用场景有着一定要求，比如只能使用在 Class 上，而 Class 并不是 JavaScript 中大量使用的语法。</p><p>至于为什么说装饰器还不是 JavaScript 的一部分，我们会在扩展阅读中介绍更多。这一节我们只关注 TypeScript 中的装饰器，从基础语法到不同种类的装饰器，从反射到反射元数据，再到基于这些概念实现依赖注入、IoC 容器等等。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F21-decorators">Decorators</a></p></blockquote><p>首先我们需要明确的是，<strong>装饰器的本质其实就是一个函数</strong>，只不过它的入参是提前确定好的。同时，TypeScript 中的装饰器目前<strong>只能在类以及类成员上使用</strong>。</p><p>装饰器通过 <code>@</code> 语法来使用：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Deco</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Deco</span></span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样的装饰器只能起到固定的功能，我们实际上使用更多的是 Decorator Factory，即装饰器工厂的形式：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Deco</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Deco</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下，程序执行时会先执行 <code>Deco()</code> ，再用内部返回的函数作为装饰器的实际逻辑。这样，我们就可以通过入参来灵活地调整装饰器的作用。接下来，我们就来学习一下 TypeScript 中的装饰器是如何使用的，它们分别有什么作用？</p><h2 id="装饰器大起底"><a href="#装饰器大起底" class="headerlink" title="装饰器大起底"></a>装饰器大起底</h2><p>TypeScript 中的装饰器可以分为<strong>类装饰器</strong>、<strong>方法装饰器</strong>、<strong>访问符装饰器</strong>、<strong>属性装饰器</strong>以及<strong>参数装饰器</strong>五种，最常见的主要还是类装饰器、方法装饰器以及属性装饰器。接下来，我们会依次介绍这几种装饰器的具体使用。</p><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>类装饰器是直接作用在类上的装饰器，它在执行时的入参只有一个，那就是这个类本身（而不是类的原型对象）。因此，我们可以通过类装饰器来覆盖类的属性与方法，如果你在类装饰器中返回一个新的类，它甚至可以篡改掉整个类的实现。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">AddProperty</span></span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">)</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">AddMethod</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">AddMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> ClassDecorator <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    target<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">newInstanceMethod</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Let's add a new instance method!"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    target<span class="token punctuation">.</span><span class="token function-variable function">newStaticMethod</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Let's add a new static method!"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">AddProperty</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> ClassDecorator <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    target<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>newInstanceProperty <span class="token operator">=</span> value    target<span class="token punctuation">.</span>newStaticProperty <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">static </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>value<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，我们通过 TypeScript 内置的 ClassDecorator 类型定义来进行类型标注，由于类装饰器只有一个参数，我们也不想使用过多的类型代码，这里我就直接 any 了。我们的函数返回了一个 ClassDecorator ，因此这个装饰器就是一个 Decorator Factory，在实际执行时需要以 <code>@Deco()</code> 的形式调用。</p><p>在 AddMethod 与 AddProperty 方法中，我们分别在 target、<code>target.prototype</code> 上添加了方法与属性，还记得 ES6 中 Class 的本质仍然是基于原型的吗？在这里 target 上的属性实际上是<strong>静态成员</strong>，也就是其实例上不会获得的方法，而 <code>target.prototype</code> 上的属性才是会随着继承与实例化过程被传递的<strong>实例成员</strong>。</p><p>我们来调用一下看看：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> foo<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>foo<span class="token punctuation">.</span><span class="token function">newInstanceMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span>Foo<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>newInstanceProperty<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span>Foo<span class="token punctuation">)</span><span class="token punctuation">.</span>newStaticProperty<span class="token punctuation">)</span><span class="token punctuation">;</span>Let's add a <span class="token keyword">new</span> <span class="token class-name">instance</span> method<span class="token operator">!</span>Let's add a <span class="token keyword">new</span> <span class="token class-name"><span class="token keyword">static</span></span> method<span class="token operator">!</span>linbudu<span class="token keyword">static</span> linbudu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们在这里调用的方法并没有直接在 Foo 中定义，而是通过装饰器来强行添加！我们也可以在装饰中返回一个子类：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token function-variable function">OverrideBar</span> <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token keyword">extends</span></span> target <span class="token punctuation">&#123;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">overridedPrint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'This is Overrided Bar!'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">OverrideBar</span></span><span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token punctuation">&#123;</span>  <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'This is Bar!'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 被覆盖了，现在是一个空方法</span><span class="token keyword">new</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// This is Overrided Bar!</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span><span class="token keyword">new</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">overridedPrint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 React Class 组件时代，其实你会发现有许多功能也是通过装饰器实现的。如 Mobx 的 <code>@observer</code> 与 <code>@observable</code>，React-Redux 的 <code>@connect</code> 等。</p><h3 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h3><p>方法装饰器的入参包括<strong>类的原型</strong>、<strong>方法名</strong>以及<strong>方法的属性描述符</strong>（PropertyDescriptor），而通过属性描述符你可以控制这个方法的内部实现（即 value）、可变性（即 writable）等信息。</p><p>能拿到原本实现，也就意味着，我们可以在执行原本方法的同时，插入一段新的逻辑，比如计算这个方法的执行耗时：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">ComputeProfiler</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">async</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'RES'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">ComputeProfiler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> MethodDecorator <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    _target<span class="token punctuation">,</span>    methodIdentifier<span class="token punctuation">,</span>    descriptor<span class="token operator">:</span> TypedPropertyDescriptor<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span>  <span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> originalMethodImpl <span class="token operator">=</span> descriptor<span class="token punctuation">.</span>value<span class="token operator">!</span><span class="token punctuation">;</span>    descriptor<span class="token punctuation">.</span><span class="token function-variable function">value</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">originalMethodImpl</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行原本的逻辑</span>      <span class="token keyword">const</span> end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>        <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token function">String</span><span class="token punctuation">(</span>methodIdentifier<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> Time: </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>        end<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fetch Time<span class="token operator">:</span>  <span class="token number">3003</span><span class="token constant">RES</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，方法装饰器的 target 是<strong>类的原型而非类本身</strong>。</p><h3 id="访问符装饰器"><a href="#访问符装饰器" class="headerlink" title="访问符装饰器"></a>访问符装饰器</h3><p>访问符装饰器并不常见，甚至访问符对于部分同学来说也是陌生的，但它其实就是 <code>get value()&#123;&#125;</code> 与 <code>set value(v)=&gt;&#123;&#125;</code> 这样的方法，其中 getter 在你访问这个属性 <code>value</code> 时触发，而 setter 在你对 <code>value</code> 进行赋值时触发。访问符装饰器本质上仍然是方法装饰器，它们使用的类型定义也相同。</p><p>需要注意的是，访问符装饰器只能同时应用在一对 getter / setter 的其中一个，即要么装饰 getter 要么装饰 setter 。这是因为，不论你是装饰哪一个，装饰器入参中的属性描述符都会包括 getter 与 setter 方法：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  _value<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_value  <span class="token punctuation">&#125;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">HijackSetter</span></span><span class="token punctuation">(</span><span class="token string">'LIN_BU_DU'</span><span class="token punctuation">)</span>  <span class="token keyword">set</span> <span class="token function">value</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_value <span class="token operator">=</span> input  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">HijackSetter</span><span class="token punctuation">(</span>val<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> MethodDecorator <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> methodIdentifier<span class="token punctuation">,</span> descriptor<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> originalSetter <span class="token operator">=</span> descriptor<span class="token punctuation">.</span>set    descriptor<span class="token punctuation">.</span><span class="token function-variable function">set</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>newValue<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> composed <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Raw: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>newValue<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">, Actual: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>val<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>newValue<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>      <span class="token function">originalSetter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> composed<span class="token punctuation">)</span>      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">HijackSetter: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>composed<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 篡改 getter，使得这个值无视 setter 的更新，返回一个固定的值</span>    <span class="token comment">// descriptor.get = function () &#123;</span>    <span class="token comment">//   return val;</span>    <span class="token comment">// &#125;;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>foo<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">'LINBUDU'</span> <span class="token comment">// HijackSetter: Raw: LINBUDU, Actual: LIN_BU_DU-LINBUDU</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们通过装饰器劫持了 setter ，在执行原本的 setter 方法修改了其参数。同时，我们也可以在这里去劫持 getter（<code>descriptor.get</code>），这样一来在读取这个值时，会直接返回一个我们固定好的值，而非其实际的值（如被 setter 更新过的）。</p><h3 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h3><p>属性装饰器在独立使用时能力非常有限，它的入参只有<strong>类的原型</strong>与<strong>属性名称</strong>，返回值会被忽略，但你仍然可以通过<strong>直接在类的原型上赋值</strong>来修改属性：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">ModifyNickName</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  nickName<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">ModifyNickName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> PropertyDecorator <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> propertyIdentifier<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    target<span class="token punctuation">[</span>propertyIdentifier<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'林不渡!'</span>    target<span class="token punctuation">[</span><span class="token string">'otherName'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'别名林不渡!'</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>nickName<span class="token punctuation">)</span><span class="token comment">// @ts-expect-error</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>otherName<span class="token punctuation">)</span>林不渡<span class="token operator">!</span>别名林不渡<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们在原型对象上强行写入了属性，但这种方法实际上过于 hack，在后面我们会了解如何通过委托的方式来为一个属性注入值。</p><h3 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h3><p>参数装饰器包括了构造函数的参数装饰器与方法的参数装饰器，它的入参包括<strong>类的原型</strong>、<strong>参数名</strong>与<strong>参数在函数参数中的索引值（即第几个参数）</strong>，如果只是单独使用，它的作用同样非常有限。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token function">handler</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">CheckParam</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">CheckParam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> ParameterDecorator <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> paramIdentifier<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> paramIdentifier<span class="token punctuation">,</span> index<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// &#123;&#125; handler 0</span><span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后面我们会了解如何基于参数装饰器进行参数的默认值注入与校验，现在就先到这儿，思考另一个问题：一个类中可以同时拥有这几种装饰器，那么这些<strong>不同装饰器的执行时机与顺序是如何的</strong>？</p><h3 id="装饰器的执行机制"><a href="#装饰器的执行机制" class="headerlink" title="装饰器的执行机制"></a>装饰器的执行机制</h3><p>装饰器的执行机制中主要包括<strong>执行时机</strong>、<strong>执行原理</strong>以及<strong>执行顺序</strong>这三个概念。</p><p>首先是执行时机，还记得我们在最开始说的吗？装饰器的本质就是一个函数，因此只要在类上定义了它，即使不去实例化这个类或者读取静态成员，它也会正常执行。很多时候，其实我们也并不会实例化具有装饰器的类，而是通过反射元数据的能力来消费，这一点我们后面会讲到。而装饰器的执行原理，我们可以通过编译后的代码来了解：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Cls</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Param</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> init<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Prop</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  prop<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Method</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token function">handler</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Param</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一段代码编译的产物会是这样的（经过简化）：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token string">'use strict'</span><span class="token keyword">var</span> __decorate <span class="token operator">=</span>  <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__decorate<span class="token punctuation">)</span> <span class="token operator">||</span>  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">decorators<span class="token punctuation">,</span> target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> desc</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span><span class="token keyword">var</span> __param <span class="token operator">=</span>  <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__param<span class="token punctuation">)</span> <span class="token operator">||</span>  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">paramIndex<span class="token punctuation">,</span> decorator</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">decorator</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> paramIndex<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">let</span> Foo <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">init</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token function">handler</span><span class="token punctuation">(</span><span class="token parameter">input</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">__decorate</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">Prop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">'prop'</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">__decorate</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">Method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">__param</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">Param</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">'handler'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span>Foo <span class="token operator">=</span> <span class="token function">__decorate</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">Cls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">__param</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">Param</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Foo<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>完整的代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.typescriptlang.org%2Fplay%3F%23code%2FGYVwdgxgLglg9mABAYQDYGcAUBKAXC1AQ3XQBEBTCOAJ0KhsQG8AoRRa8qEapTKQ6gHNO2RAF4AfE0QBfZnOahIsBIgCynABZwAJjnwao2nRSq161Jq3aduvfkJHipjWfOaLw0eEgAK1OAAHfUR-IPJqKABPUxo6BhY2Di4eRD4BYShRSSs2OQUlb1VfAUIAWxCS2jLOCNjzBOtkuzSHTOyXNwUAATQsbGYIIhJEADE4OFzEKjB0KGoQaBpMbqrynEQYMBgoAH58OeotwVFXBTZVgOCBtkCrg-nj8UQAclQtgCMQHRAXjwuwtdrHM6DAIIgQbAIICHkcwIJni9IWDEO8wF8fn9rN1DMYcNZNIQwDpUBEVmsKqItoEQFBYcdTv83Njcbp8WxkeDOQAJIkksmrUqUzZgGl0iGPeGM6z5DyDBBzRDACbPMDkADuYwmOAA3EA">Playground</a></p></blockquote><p>这里的 <code>__decorate</code> 方法，其实就是通过实际入参来判断当前到底执行的是哪种装饰器，然后执行对应的装饰逻辑。而观察这个方法调用时的入参，我们会再次观察到这些装饰器的不同入参：<strong>方法与属性装饰器是类的原型对象</strong>，而<strong>类装饰器才能获得这个类本身作为入参</strong>。而属性装饰器应用时，这个属性还未被初始化（属性需要实例化才会有值），这也是为什么它无法像方法装饰器那样获取到值。</p><p>可以看到，上面的装饰器顺序依次是<strong>实例上的属性、方法、方法参数</strong>，然后是<strong>静态的属性、方法、方法参数</strong>，最后是<strong>类以及类构造函数参数</strong>。</p><p>而从这一编译结果中，我们还能观察到不同类型装饰器的<strong>执行顺序</strong>。首先是实例上的属性、方法、方法参数，然后是静态的属性、方法、方法参数，最后是类以及类构造函数参数。而装饰器的<strong>应用顺序</strong>则略有不同，<strong>方法参数装饰器会先于方法装饰器应用</strong>（<code>__param(0, Param())</code>）。</p><blockquote><p>关于执行顺序与应用顺序，执行是<strong>装饰器求值得到最终装饰器表达式</strong>的过程，而应用则是<strong>最终装饰器逻辑代码执行</strong>的过程：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">deco</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 执行</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 应用</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>实际上，对于实例与静态的属性、方法装饰器而言，它们的执行与应用顺序其实<strong>取决于它们定义的位置</strong>，你可以在上面的例子里把方法定义在属性之前，就会发现执行顺序变成了<strong>方法</strong>-<strong>方法参数</strong>-<strong>属性</strong>，即先定义先执行。</p><p>在 TypeScript 官方文档中对应用顺序给出了详细的定义：</p><ol><li><em>参数装饰器</em>，然后依次是<em>方法装饰器</em>，<em>访问符装饰器</em>，或<em>属性装饰器</em>应用到每个实例成员。</li><li><em>参数装饰器</em>，然后依次是<em>方法装饰器</em>，<em>访问符装饰器</em>，或<em>属性装饰器</em>应用到每个静态成员。</li><li><em>参数装饰器</em>应用到构造函数。</li><li><em>类装饰器</em>应用到类。</li></ol><p>最后，我们再看一个例子，来更深刻地了解执行顺序与应用顺序：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Deco</span><span class="token punctuation">(</span>identifier<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>identifier<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> 执行</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>identifier<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> 应用</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Deco</span></span><span class="token punctuation">(</span><span class="token string">'类装饰器'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Deco</span></span><span class="token punctuation">(</span><span class="token string">'构造函数参数装饰器'</span><span class="token punctuation">)</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Deco</span></span><span class="token punctuation">(</span><span class="token string">'实例属性装饰器'</span><span class="token punctuation">)</span>  prop<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Deco</span></span><span class="token punctuation">(</span><span class="token string">'实例方法装饰器'</span><span class="token punctuation">)</span>  <span class="token function">handler</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Deco</span></span><span class="token punctuation">(</span><span class="token string">'实例方法参数装饰器'</span><span class="token punctuation">)</span> args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上的代码输出是这样的：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">实例属性装饰器 执行实例属性装饰器 应用实例方法装饰器 执行实例方法参数装饰器 执行实例方法参数装饰器 应用实例方法装饰器 应用类装饰器 执行构造函数参数装饰器 执行构造函数参数装饰器 应用类装饰器 应用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行顺序就不再赘述，这里我们主要关注应用顺序。顺序大致是<strong>实例属性-实例方法参数-构造函数参数-类</strong>，好像不对，不是说参数装饰器先应用吗？这是因为在这个例子中，我们是先定义属性和属性装饰器的，因此属性装饰器会先应用。如果方法在前，可不就是方法参数装饰器先应用？</p><p>你会发现，类装饰器是最后应用的。也就是说，如果我们在方法装饰器中标记某些信息，最终的类装饰器是可以消费到，并且基于此信息对类或类的实例进行某些操作的。如标记为 <code>@Deprecated</code> 的方法，我们在最终的类装饰器中可以将这些方法实现替换为一个报错！而标记这些信息的方法则有很多，最简单的如，在全局声明一个 Map，类作为 Key，这些信息作为 Value 也是可以的。当然，后面我们会说到如何使用更好的方式实现。</p><h4 id="多个同类装饰器的执行顺序"><a href="#多个同类装饰器的执行顺序" class="headerlink" title="多个同类装饰器的执行顺序"></a>多个同类装饰器的执行顺序</h4><p>另外，我们也可以使用多个同种装饰器，比如一个类上可以有好多个类装饰器：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Deprecated</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">User</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Internal</span></span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Provide</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种情况下，这些装饰器的执行顺序又是怎样的？其顺序分为两步。首先，<strong>由上至下</strong>依次对装饰器的表达式求值，得到装饰器的实现，<code>@Internal</code> 中实现即为 Internal 方法，而 <code>@Provide()</code> 中实现则需要进行一次求值。</p><p>然后，这些装饰器的具体实现才会<strong>从下往上</strong>调用，如这里是 Provide、Internal、User、Deprecated 的顺序。从这个角度来看，甚至有点像洋葱模型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> MethodDecorator <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo in'</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> propertyKey<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo out'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> MethodDecorator <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar in'</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> propertyKey<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar out'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> Baz<span class="token operator">:</span> <span class="token function-variable function">MethodDecorator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'baz apply'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Foo</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Bar</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Baz</span></span>  <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// foo in</span><span class="token comment">// bar in</span><span class="token comment">// baz apply</span><span class="token comment">// bar out</span><span class="token comment">// foo out</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似的，如果一个方法中的多个参数均存在装饰器，那么同样是 <code>Parma1 in</code> - <code>Param2 in</code>- <code>Param2 out</code> - <code>Param1 out</code> 的顺序，也就是<strong>后面参数的装饰器逻辑</strong>反而先执行。</p><p><strong>但我们通常不会在同种装饰器中进行存在依赖关系的操作。</strong> 对于属性、参数装饰器来说，我们通常只进行信息注册，委托别人处理。对于方法装饰器来说，我们最多只进行方法执行前后的逻辑注入。而这些过程都应当是彼此独立的。</p><p>那么，这里的委托又如何实现呢？这时候我们就要介绍一位新朋友了：<strong>反射（Reflect）</strong>。你可能很早就认识，但没怎么接触过。</p><h2 id="反射-Reflect"><a href="#反射-Reflect" class="headerlink" title="反射 Reflect"></a>反射 Reflect</h2><p>Reflect 在 ES6 中被首次引入，它主要是为了配合 Proxy 保留一份方法原始的实现逻辑，如以下来自阮一峰老师的 ES6 标准入门中 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Freflect">Reflect</a> 一节的代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> name<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> success <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> name<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'property '</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">' on '</span> <span class="token operator">+</span> target <span class="token operator">+</span> <span class="token string">' set to '</span> <span class="token operator">+</span> value<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> success  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Proxy 将修改这个对象的 set 方法，但我们可以通过 <code>Reflect.set</code> 方法获得原本的默认实现（不会被修改），先执行完默认实现逻辑再添加自己的额外逻辑。</p><p>Proxy 上的这些方法会一一对应到 Reflect 中（或者说 Reflect 中只有 Proxy 上方法的对应实现），如 defineProperty、deleteProperty、apply、get、set、has 等等。这些方法其实也可以在别的对象上找到，如 <code>Object.defineProperty</code>、<code>Function.prototype.apply</code> 等等，因此 Reflect 其实也起到了方法收拢的作用。</p><p>如果你有 Java、Go 等语言的基础，一定会反驳说反射才不是用来干这个的呢。别急，我们才刚要开始介绍。</p><p>上面的 Proxy 对象的 set 方法是运行时才实际执行的，也就是说我们通过反射，在<strong>运行时去修改了程序的行为</strong>。这就是反射的核心要素：<strong>在程序运行时去检查以及修改程序行为</strong>，比如在代码运行时通过 <code>Reflect.construct</code> 实例化一个类，通过 <code>Reflect.setPrototypeOf</code> 修改对象原型指向，这些其实都属于反射 API 。</p><blockquote><p>此前 JavaScript 中的反射 API 散落在各个顶级对象的命名空间下，因此我们需要 Reflect 来进行一次统一。</p></blockquote><p>比如通过反射来实例化一个类：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 普通情况</span><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>foo<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 基于反射</span><span class="token keyword">const</span> foo <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token keyword">const</span> hello <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token function">Reflect</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>hello<span class="token punctuation">,</span> foo<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们的主要内容和反射并没有太大的关系，下面要介绍的反射元数据才是本节的重量级角色。但你仍然需要铭记反射的核心理念：<strong>在程序运行时去检查以及修改程序行为</strong>。</p><h2 id="反射元数据-Reflect-Metadata"><a href="#反射元数据-Reflect-Metadata" class="headerlink" title="反射元数据 Reflect Metadata"></a>反射元数据 Reflect Metadata</h2><p>不同于反射，<strong>反射元数据（Reflect Metadata）</strong> 这一提案虽然同样很早就被提出，但至今都未真正的成为 ECMAScript 的一部分，原因在于元数据和装饰器提案的联系非常紧密，随着装饰器提案迟迟不能推进，元数据当然也无法独自向前。因此，想要使用反射元数据，你还需要安装 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frbuckton%2Freflect-metadata">reflect-metadata</a> ，并在入口文件中的顶部 <code>import &quot;reflect-metadata&quot;</code> 。</p><p>反射元数据提案（即 <code>&quot;reflect-metadata&quot;</code> 包）为顶级对象 Reflect 新增了一批专用于元数据读写的 API，如 <code>Reflect.defineMetadata</code>、<code>Reflect.getMetadata</code> 等。那么元数据又是什么？你可以将元数据理解为<strong>用于描述数据的数据</strong>，如某个方法的参数信息、返回值信息就可称为该方法的元数据。</p><p>那么元数据又存储在哪里？提案中专门说明了这一点，为类或类属性添加了元数据后，构造函数（或是构造函数的原型，根据静态成员还是实例成员决定）会具有 <code>[[Metadata]]</code> 属性，该属性内部包含一个 Map 结构，键为属性键，值为元数据键值对。也就是说，<strong>静态成员的元数据信息存储于构造函数</strong>，而<strong>实例成员的元数据信息存储于构造函数的原型上</strong>。</p><p>我们来简单使用下元数据的注册与提取：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token string">'reflect-metadata'</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>Reflect<span class="token punctuation">.</span><span class="token function">defineMetadata</span><span class="token punctuation">(</span><span class="token string">'class:key'</span><span class="token punctuation">,</span> <span class="token string">'class metadata'</span><span class="token punctuation">,</span> Foo<span class="token punctuation">)</span>Reflect<span class="token punctuation">.</span><span class="token function">defineMetadata</span><span class="token punctuation">(</span><span class="token string">'method:key'</span><span class="token punctuation">,</span> <span class="token string">'handler metadata'</span><span class="token punctuation">,</span> Foo<span class="token punctuation">,</span> <span class="token string">'handler'</span><span class="token punctuation">)</span>Reflect<span class="token punctuation">.</span><span class="token function">defineMetadata</span><span class="token punctuation">(</span>  <span class="token string">'proto:method:key'</span><span class="token punctuation">,</span>  <span class="token string">'proto handler metadata'</span><span class="token punctuation">,</span>  Foo<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span>  <span class="token string">'handler'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>defineMetadata 的入参包括元数据 Key、元数据 Value、目标类 Target 以及一个可选的属性，在这里我们的三个调用分别是在 Foo、Foo.handler 以及 Foo.prototype 上注册元数据。而提取则可以通过 getMetadata 方法：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// [ 'class:key' ]</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">getMetadataKeys</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// ['method:key']</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">getMetadataKeys</span><span class="token punctuation">(</span>Foo<span class="token punctuation">,</span> <span class="token string">'handler'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// ['proto:method:key'];</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">getMetadataKeys</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">'handler'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// class metadata</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token string">'class:key'</span><span class="token punctuation">,</span> Foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// handler metadata</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token string">'method:key'</span><span class="token punctuation">,</span> Foo<span class="token punctuation">,</span> <span class="token string">'handler'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// proto handler metadata</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token string">'proto:method:key'</span><span class="token punctuation">,</span> Foo<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">'handler'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，反射元数据正是我们实现属性装饰器中提到的“委托”能力的基础。我们在属性装饰器中去注册一个元数据，然后在真正实例化这个类时，就可以拿到类原型上的元数据，以此对实例化完毕的类再进行额外操作。比如说，我先通过元数据说明，这个属性需要获得变量 a 的值，在实例化时，我们发现有这个元数据，就会对应进行赋值操作。</p><p>正是考虑到这一点，反射元数据中直接就内置了基于装饰器的调用方式：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Reflect</span></span><span class="token punctuation">.</span><span class="token function">metadata</span><span class="token punctuation">(</span><span class="token string">'class:key'</span><span class="token punctuation">,</span> <span class="token string">'METADATA_IN_CLASS'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Reflect</span></span><span class="token punctuation">.</span><span class="token function">metadata</span><span class="token punctuation">(</span><span class="token string">'prop:key'</span><span class="token punctuation">,</span> <span class="token string">'METADATA_IN_PROPERTY'</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> prop<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Reflect</span></span><span class="token punctuation">.</span><span class="token function">metadata</span><span class="token punctuation">(</span><span class="token string">'method:key'</span><span class="token punctuation">,</span> <span class="token string">'METADATA_IN_METHOD'</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>@Reflect.metadata</code> 装饰器会基于应用的位置进行实际的逻辑调用，如在类上装饰时以类作为 target 进行注册，而在静态成员与实例成员中分别使用构造函数、构造函数原型。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// METADATA_IN_CLASS</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token string">'class:key'</span><span class="token punctuation">,</span> Foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// undefined</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token string">'class:key'</span><span class="token punctuation">,</span> Foo<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// METADATA_IN_METHOD</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token string">'method:key'</span><span class="token punctuation">,</span> Foo<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">'handler'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// METADATA_IN_METHOD</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token string">'method:key'</span><span class="token punctuation">,</span> foo<span class="token punctuation">,</span> <span class="token string">'handler'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// METADATA_IN_PROPERTY</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token string">'prop:key'</span><span class="token punctuation">,</span> Foo<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">'prop'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// METADATA_IN_PROPERTY</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token string">'prop:key'</span><span class="token punctuation">,</span> foo<span class="token punctuation">,</span> <span class="token string">'prop'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看起来我们现在拥有了实现委托的基本能力，但实际上这还不够。所有的元数据都需要我们提前定义好，如果我们希望直接用一些已有的信息作为元数据呢？比如下面这个例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">InjectModel</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  userModel<span class="token operator">:</span> UserModel<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我希望将 userModel 属性的类型 UserModel 作为一个元数据信息注入，同时我不会为 <code>@InjectModel()</code> 装饰器提供任何信息，那我们就束手无策了吗？</p><p>还记得我们在介绍反射概念时说的，<strong>反射允许程序去检视自身</strong>，而属性类型作为程序的一部分，也应当是能被反射收集的。为了实现这一目的，反射元数据提案中还内置了基于类型的元数据，你可以通过 <code>design:type</code>、<code>design:paramtypes</code> 以及 <code>design:returntype</code> 这三个内置的元数据 Key，获取到类与类成员的类型、参数类型、返回值类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token string">'reflect-metadata'</span><span class="token keyword">function</span> <span class="token function">DefineType</span><span class="token punctuation">(</span>type<span class="token operator">:</span> Object<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">metadata</span><span class="token punctuation">(</span><span class="token string">'design:type'</span><span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">DefineParamTypes</span><span class="token punctuation">(</span><span class="token operator">...</span>types<span class="token operator">:</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">metadata</span><span class="token punctuation">(</span><span class="token string">'design:paramtypes'</span><span class="token punctuation">,</span> types<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">DefineReturnType</span><span class="token punctuation">(</span>type<span class="token operator">:</span> Object<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">metadata</span><span class="token punctuation">(</span><span class="token string">'design:returntype'</span><span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">DefineParamTypes</span></span><span class="token punctuation">(</span>String<span class="token punctuation">,</span> Number<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">DefineType</span></span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token string">'linbudu'</span>  <span class="token punctuation">&#125;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">DefineType</span></span><span class="token punctuation">(</span><span class="token builtin">Function</span><span class="token punctuation">)</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">DefineParamTypes</span></span><span class="token punctuation">(</span>Number<span class="token punctuation">,</span> Number<span class="token punctuation">)</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">DefineReturnType</span></span><span class="token punctuation">(</span>Number<span class="token punctuation">)</span>  <span class="token function">add</span><span class="token punctuation">(</span>source<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> input<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> source <span class="token operator">+</span> input  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// [ [Function: Number], [Function: Number] ]</span><span class="token keyword">const</span> paramTypes <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token string">'design:paramtypes'</span><span class="token punctuation">,</span> foo<span class="token punctuation">,</span> <span class="token string">'add'</span><span class="token punctuation">)</span><span class="token comment">// [Function: Number]</span><span class="token keyword">const</span> returnTypes <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token string">'design:returntype'</span><span class="token punctuation">,</span> foo<span class="token punctuation">,</span> <span class="token string">'add'</span><span class="token punctuation">)</span><span class="token comment">// [Function: String]</span><span class="token keyword">const</span> type <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token string">'design:type'</span><span class="token punctuation">,</span> foo<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，这一提案实际上并不依赖 TypeScript ，这些类型信息来自于运行时，而非我们的类型标注。同时这些内置元数据取出的值是装箱类型对象，如 String、Number 等。</p><p>TypeScript 为其进行了额外的支持，然后我们才可以获取到类型标注所对应的元数据，如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">DefineType</span></span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span>  prop<span class="token operator">!</span><span class="token operator">:</span> Foo<span class="token punctuation">&#125;</span><span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// [class Foo]</span><span class="token keyword">const</span> type2 <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token string">'design:type'</span><span class="token punctuation">,</span> bar<span class="token punctuation">,</span> <span class="token string">'prop'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这也是为什么我们需要启用 <code>emitDecoratorMetadata</code> 配置的原因之一。上面的装饰器执行机制代码中我们看到了编译后的装饰器代码，而启用 <code>emitDecoratorMetadata</code> 后，产物中会多出这些代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> __metadata <span class="token operator">=</span>  <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__metadata<span class="token punctuation">)</span> <span class="token operator">||</span>  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">k<span class="token punctuation">,</span> v</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Reflect <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> Reflect<span class="token punctuation">.</span>metadata <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">metadata</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token function">__decorate</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>    <span class="token function">Prop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">__metadata</span><span class="token punctuation">(</span><span class="token string">'design:type'</span><span class="token punctuation">,</span> String<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 新增</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span>  <span class="token string">'prop'</span><span class="token punctuation">,</span>  <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">__decorate</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>    <span class="token function">Method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">__param</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">Param</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">__metadata</span><span class="token punctuation">(</span><span class="token string">'design:type'</span><span class="token punctuation">,</span> Function<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 新增</span>    <span class="token function">__metadata</span><span class="token punctuation">(</span><span class="token string">'design:paramtypes'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>String<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 新增</span>    <span class="token function">__metadata</span><span class="token punctuation">(</span><span class="token string">'design:returntype'</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 新增</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span>  <span class="token string">'handler'</span><span class="token punctuation">,</span>  <span class="token keyword">null</span><span class="token punctuation">)</span>Foo <span class="token operator">=</span> <span class="token function">__decorate</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>    <span class="token function">Cls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">__param</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">Param</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">__metadata</span><span class="token punctuation">(</span><span class="token string">'design:paramtypes'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>String<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 新增</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  Foo<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了装饰器、反射元数据以及内置的基于类型的元数据信息，我们就可以实现“委托”的能力了。以看似平平无奇的属性装饰器为例，我们使用元数据来实现基于装饰器的属性校验。</p><p>在这个例子里，我们会实现两种校验逻辑，对必填属性（Required）与属性类型的校验（String / Number / Boolean），其基本使用方式如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Required</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  name<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">ValueType</span></span><span class="token punctuation">(</span>TypeValidation<span class="token punctuation">.</span>Number<span class="token punctuation">)</span>  age<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// @ts-expect-error</span>user<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token string">'18'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们会将 user 实例传递给校验方法，在这里应当给出两处错误：没有提供必填属性 name，以及 age 属性的类型不符。</p><p>如果理解了元数据的作用，那我们的思路就很明确了，装饰器将元数据附加到属性或类上，然后校验方法中遍历属性读取这些元数据，再对比类型是否匹配即可。</p><p>首先是 Required ，我们肯定下意识是这么写：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Required</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> PropertyDecorator <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    Reflect<span class="token punctuation">.</span><span class="token function">defineMetadata</span><span class="token punctuation">(</span><span class="token string">'required'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是在这个属性上定义了一个名为 required 的元数据。但你是否想过，如果实例中根本就没有这个属性呢？就像上面的 user 一样，那这里的元数据不就丢失了？</p><p>要解决这一问题，其实只需要将元数据定义在类上即可。我们用一个专门描述必填属性的元数据，存储这个类内部所有的必填属性即可：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> requiredMetadataKey <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'requiredKeys'</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">Required</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> PropertyDecorator <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> existRequiredKeys<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>      Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span>requiredMetadataKey<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token operator">??</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    Reflect<span class="token punctuation">.</span><span class="token function">defineMetadata</span><span class="token punctuation">(</span>      requiredMetadataKey<span class="token punctuation">,</span>      <span class="token punctuation">[</span><span class="token operator">...</span>existRequiredKeys<span class="token punctuation">,</span> prop<span class="token punctuation">]</span><span class="token punctuation">,</span>      target    <span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而对于属性的校验其实就简单了，由于对类型的校验逻辑可以归到一起，我们就使用<strong>装饰器工厂 + 入参</strong>的形式来注入对应的元数据信息，这次我们只需要在属性层面注入元数据即可：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">enum</span> TypeValidation <span class="token punctuation">&#123;</span>  String <span class="token operator">=</span> <span class="token string">'string'</span><span class="token punctuation">,</span>  Number <span class="token operator">=</span> <span class="token string">'number'</span><span class="token punctuation">,</span>  Boolean <span class="token operator">=</span> <span class="token string">'boolean'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> validationMetadataKey <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'expectedType'</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">ValueType</span><span class="token punctuation">(</span>type<span class="token operator">:</span> TypeValidation<span class="token punctuation">)</span><span class="token operator">:</span> PropertyDecorator <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    Reflect<span class="token punctuation">.</span><span class="token function">defineMetadata</span><span class="token punctuation">(</span>validationMetadataKey<span class="token punctuation">,</span> type<span class="token punctuation">,</span> target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就是校验逻辑了，我们需要一个额外的 validator 方法：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">validator</span><span class="token punctuation">(</span>entity<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">validator</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果校验完全通过，那这一方法的返回值则是一个空数组，否则的话内部会存有报错信息。首先是对于必填属性的校验，我们需要取出注册在类上的，描述必填属性的元数据，再检查这些必填属性是否都存在了：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">validator</span><span class="token punctuation">(</span>entity<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> clsName <span class="token operator">=</span> entity<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>name  <span class="token keyword">const</span> messages<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment">// 先检查所有必填属性</span>  <span class="token keyword">const</span> requiredKeys<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span>    requiredMetadataKey<span class="token punctuation">,</span>    entity  <span class="token punctuation">)</span>  <span class="token comment">// 基于反射拿到所有存在的属性</span>  <span class="token keyword">const</span> existKeys <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>entity<span class="token punctuation">)</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">of</span> requiredKeys<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>existKeys<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      messages<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>clsName<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">.</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>key<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> should be required.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>      <span class="token comment">// throw new Error(`$&#123;key&#125; is required!`);</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> messages<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后是对属性类型的校验，我们的 TypeValidation 枚举中，枚举值就是 <code>typeof</code> 的返回值，因此这里直接使用即可：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">validator</span><span class="token punctuation">(</span>entity<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ...</span>  <span class="token comment">// 接着基于定义在属性上的元数据校验属性类型</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">of</span> existKeys<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> expectedType<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span>      validationMetadataKey<span class="token punctuation">,</span>      entity<span class="token punctuation">,</span>      key    <span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>expectedType<span class="token punctuation">)</span> <span class="token keyword">continue</span>    <span class="token comment">// 枚举也是对象，因此 Object.values 同样可以生效（只不过也会包括键名）</span>    <span class="token comment">// @ts-expect-error</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>TypeValidation<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>expectedType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> actualType <span class="token operator">=</span> <span class="token keyword">typeof</span> entity<span class="token punctuation">[</span>key<span class="token punctuation">]</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>actualType <span class="token operator">!==</span> expectedType<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        messages<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>          <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">expect </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>entity<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">.</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token function">String</span><span class="token punctuation">(</span>            key          <span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> to be </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>expectedType<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">, but got </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>actualType<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">.</span><span class="token template-punctuation string">`</span></span>        <span class="token punctuation">)</span>        <span class="token comment">// throw new Error(`$&#123;String(key)&#125; is not $&#123;expectedType&#125;!`);</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> messages<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终的输出会是这样的：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">[  <span class="token string">'User.name should be required.'</span><span class="token punctuation">,</span>  <span class="token string">'expect User.age to be number, but got string.'</span>]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>除了这两种校验，你也可以通过元数据的帮助来实现更复杂的校验逻辑。如 MinLength、MaxLength、Min、Max 甚至 Email、IP 这样，对属性值内容的校验。思路仍然还是那么简单明了：<strong>注册元数据，消费元数据</strong>。</p><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>这一节，我们了解了装饰器的基本概念，包括 TypeScript 中的五种装饰器，以及这些装饰器的入参、使用场景、执行顺序等等。另外我们还掌握了反射元数据的使用，目前看起来它好像并没有什么特别之处？那么在下一节，我们就会在反射元数据的基础上，去了解一个新的概念：控制反转。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="装饰器的坎坷进历程"><a href="#装饰器的坎坷进历程" class="headerlink" title="装饰器的坎坷进历程"></a>装饰器的坎坷进历程</h3><p>正如我们在开头提到的，装饰器从被作为一个提案提出开始，很是经历了一番风雨，下面我们就来具体介绍一下它到底都经历了些什么。</p><p>首先需要明确的是，目前 JavaScript（ECMAScript）中的装饰器，和我们这节学习的 TypeScript 装饰器基本是两件完全不同的事物。<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftc39%2Fproposal-decorators">装饰器提案</a> 距离最开始提出已经过去了数年，在这期间提案内容，也就是语法、作用与运行时机制等，已经迭代了四个版本。</p><p>第四个版本在 2022 年 3 月份的 TC39 会议中终于如愿进入 Stage 3，也就意味着这一版本的实现基本上就是未来最终落地的版本。此前的版本都在 Stage 2 就胎死腹中，而 TypeScript 与 Babel 中的装饰器则是基于第一版的提案实现的，虽然语法都还是 <code>@</code> ，但这两个版本的装饰器实际上差异非常之大。</p><blockquote><p>如果你有兴趣了解新版装饰器的具体语义，可以阅读我此前发表的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F6PTcjJQTED3WpJH8ToXInw">2022 年 3 月 TC39 会议报告</a> 来了解更多。另外，在 ECMAScript 装饰器进入 Stage 4，或已经有可用的编译支持（Babel / TypeScript ）后，我也会更新关于新版装饰器的使用说明。</p></blockquote><p>通常来说， TypeScript 只会对已经到达 Stage 3 的提案进行提前的支持，如可选链、空值合并、逻辑赋值等。当 TypeScript 最初引入装饰器时大概是在 2015 年，此时装饰器提案位于 Stage 1 阶段。</p><p>促使 TS 提前引入的一个重要原因是，当时存在一门 TS 的超集语言（也就是 JS 的超集的超集？） <a href="https://link.juejin.cn/?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FAtScript">AtScript</a>，它在 TS 的基础上去支持了装饰器语法，来供 Angular 框架使用。TS 团队与 Angular 团队在某种契机下达成一致，决定将装饰器以及相关的注解能力直接引入 TypeScript 中，而 Angular 团队不再维护 AtScript ，这实际上避免了未来可能出现的竞争与社区生态分裂问题。</p><p>虽然这两个版本的装饰器确实差异很大，但你其实无需担心出现未来需要面对断崖式的更新，目前新版装饰器的能力基本上能完全覆盖旧版所能提供的能力，因此升级成本对于用户或者框架开发者来说都不会太高。而如果还想继续使用旧版装饰器怎么办？我猜 TypeScript 会通过引入一个新的 Compiler Option 来控制实际表现与编译产物。</p><h3 id="Reflect-decorate"><a href="#Reflect-decorate" class="headerlink" title="Reflect.decorate"></a>Reflect.decorate</h3><p>如果你去观察了装饰器的编译代码，会发现 <code>__decorate</code> 方法中有一段代码是检查 <code>Reflect.decorate</code> 方法是否存在。这一方法其实也来自于 Reflect Metadata，见 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frbuckton%2Freflect-metadata%2Fblob%2Fmaster%2FReflect.ts%23L115">L115</a>。这一方法的作用就是，通过反射的方式来进行装饰，如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>Reflect<span class="token punctuation">.</span><span class="token function">decorate</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>    <span class="token comment">/** ...一组装饰器 */</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  Foo<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这也就意味着，你甚至可以<strong>在方法内部去装饰某一个类或其成</strong>员，而不是仅仅只能依赖需要提前定义好的装饰器。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>26.控制反转与依赖注入：基于装饰器的依赖注入实现</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/26.%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9A%E5%9F%BA%E4%BA%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/26.%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9A%E5%9F%BA%E4%BA%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>上一节学习了装饰器与反射元数据的基本使用后，这一节我们将在其基础上来了解<strong>控制反转</strong>、<strong>依赖注入</strong>等概念，我们会使用装饰器配合反射元数据实现这一设计模式，以及实现基于装饰器的路由体系与一个简单的控制反转容器。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F21-decorators">Decorators</a></p></blockquote><h2 id="控制反转与依赖注入"><a href="#控制反转与依赖注入" class="headerlink" title="控制反转与依赖注入"></a>控制反转与依赖注入</h2><p>控制反转即 <strong>Inversion of Control</strong>，它是面向对象编程中的一种设计模式，可以用来很好地解耦代码。</p><blockquote><p>由于控制反转出现的时间较晚，因而没有被包括在四人组的设计模式一书当中，但它仍然是一种设计模式。</p></blockquote><p>假设我们存在多个具有依赖关系的类，可能会想当然这么写：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> <span class="token constant">A</span> <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./modA'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> <span class="token constant">B</span> <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./modB'</span><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">A</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">B</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在一共只有三个类，倒还没问题，如果随着开发这些类的数量与依赖关系复杂度暴涨，C 依赖 A B，D 依赖 A C，F 依赖 B C D…，再加上每个类需要实例化的参数可能又有所不同，此时再去手动维护这些依赖关系与实例化过程就是灾难了。</p><p>而控制反转模式则能够很好地解决这一问题，它引入了一个容器的概念，内部自动地维护了这些类的依赖关系，当我们需要一个类的时候，它会帮我们把这个类内部依赖的实例都填充好，我们直接用就行：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">F</span></span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>d <span class="token operator">=</span> Container<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">D</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，我们的实例 D 已经完成了对 A、C 的依赖填充，C 也完成了 A、B 的依赖填充，也就是说所有复杂的依赖关系都被处理完毕了。</p><p>这一模式就叫做<strong>控制反转</strong>。我们此前手动维护关系的模式则成为<strong>控制正转</strong>。举个例子，当我们想要处对象时，会上 Soul 这样的交友平台一个一个找，择偶条件是由我自己决定的，这就叫<strong>控制正转</strong>。现在我觉得这样太麻烦了，直接把自己的介绍、择偶条件上传到世纪佳缘，如果有人认为我不错，就会主动向我发起聊天，而这就是<strong>控制反转</strong>。</p><p>控制反转的实现方式主要有两种，<strong>依赖查找</strong>与<strong>依赖注入</strong>。它们的本质其实均是<strong>将依赖关系的维护与创建独立出来</strong>。</p><p>其中依赖查找在 JavaScript 中并不多见，它其实就是将实例化的过程放到了另外一个新的 Factory 方法中：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Factory</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">static</span> <span class="token function">produce</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">F</span></span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>d <span class="token operator">=</span> Factory<span class="token punctuation">.</span><span class="token function">produce</span><span class="token punctuation">(</span><span class="token string">'D'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，我们的 Factory 类会按照传入的 key 去查找目标对象，然后再进行实例化与赋值过程。而依赖注入的代码则是这样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Provide</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">F</span></span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  d<span class="token operator">:</span> <span class="token constant">D</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到这里我们不需要手动进行赋值，只需要声明这个属性，然后使用装饰器标明它需要被注入一个值即可。</p><p>这里的 Provide 即标明这个类需要被注册到容器中，如果别的地方需要这个类 F 时，其内部的 d 属性需要被注入一个 D 的实例，而 D 的实例又需要 A、C 的实例等等。这一系列的过程是完全交给容器的，我们需要做的就只是用装饰器简单标明下依赖关系即可。</p><p>很明显，相比于依赖查找，依赖注入使用起来更加简洁，几乎不需要额外的业务代码，即不需要一个额外的 Factory 方法去维护实例化逻辑，但其依赖逻辑要更加黑盒。</p><p>而装饰器如何实现依赖注入，我想其实你也能 get 到，不就是我们上面所说的元数据吗？比如在属性中通过 Inject 装饰器注册一份元数据，告诉容器这个类的哪些属性需要被注入，然后容器会在内部存储的类里面对应地进行查找。</p><p>在部分前端框架中同样大量使用了基于装饰器的依赖注入体系，如 Angular、Nest、MidwayJS 等，目前来看在 NodeJs 框架中的使用要更为常见。如 Nest 与 Midway 中基于装饰器实现了路由、生命周期、模块、中间件与拦截器等等功能，举例来说，基于装饰器的路由可能是这么写的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Controller</span></span><span class="token punctuation">(</span><span class="token string">'/user'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token string">'/list'</span><span class="token punctuation">)</span>  <span class="token keyword">async</span> <span class="token function">userList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Post</span></span><span class="token punctuation">(</span><span class="token string">'/add'</span><span class="token punctuation">)</span>  <span class="token keyword">async</span> <span class="token function">addUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这么个路由声明意味着，<code>GET /user/list</code> 时会调用 userList 方法，而 <code>POST /user/add</code> 时则会调用 addUser 方法。</p><p>学习了依赖注入之后，其实我们也可以来自己实现一个装饰器路由体系！</p><h3 id="基于依赖注入的路由实现"><a href="#基于依赖注入的路由实现" class="headerlink" title="基于依赖注入的路由实现"></a>基于依赖注入的路由实现</h3><blockquote><p>本节的代码是我最初在深入浅出 TypeScript 一书中学习到的内容，个人认为非常适合用于加深对依赖注入的理解，因此在其基础上进一步完善后，作为本节的实例代码。</p></blockquote><p>我们的最终目的就是实现上面基于装饰器的路由能力，以及启动一个 Node Server 来完成对这个路由的承接。</p><p>分析一下我们需要哪些能力？最重要的就是把每个方法对应的请求路径、请求方法和具体实现绑定起来，也就是在 <code>GET /user/list</code> 时，我们需要调用 <code>userList</code> 方法，并将返回值作为响应。那么，在方法的装饰器 <code>GET</code> <code>POST</code> 上，我们就可以将请求方法、请求路径、方法名、方法实现等信息注册为元数据，然后通过一个统一的提取手段来将它们组装起来。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">enum</span> <span class="token constant">METADATA_KEY</span> <span class="token punctuation">&#123;</span>  <span class="token constant">METHOD</span> <span class="token operator">=</span> <span class="token string">'ioc:method'</span><span class="token punctuation">,</span>  <span class="token constant">PATH</span> <span class="token operator">=</span> <span class="token string">'ioc:path'</span><span class="token punctuation">,</span>  <span class="token constant">MIDDLEWARE</span> <span class="token operator">=</span> <span class="token string">'ioc:middleware'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">enum</span> <span class="token constant">REQUEST_METHOD</span> <span class="token punctuation">&#123;</span>  <span class="token constant">GET</span> <span class="token operator">=</span> <span class="token string">'ioc:get'</span><span class="token punctuation">,</span>  <span class="token constant">POST</span> <span class="token operator">=</span> <span class="token string">'ioc:post'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">methodDecoratorFactory</span> <span class="token operator">=</span> <span class="token punctuation">(</span>method<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>path<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> MethodDecorator <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>_target<span class="token punctuation">,</span> _key<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 在方法实现上注册 ioc:method - 请求方法 的元数据</span>      Reflect<span class="token punctuation">.</span><span class="token function">defineMetadata</span><span class="token punctuation">(</span><span class="token constant">METADATA_KEY</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">,</span> method<span class="token punctuation">,</span> descriptor<span class="token punctuation">.</span>value<span class="token operator">!</span><span class="token punctuation">)</span>      <span class="token comment">// 在方法实现上注册 ioc:path - 请求路径 的元数据</span>      Reflect<span class="token punctuation">.</span><span class="token function">defineMetadata</span><span class="token punctuation">(</span><span class="token constant">METADATA_KEY</span><span class="token punctuation">.</span><span class="token constant">PATH</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> descriptor<span class="token punctuation">.</span>value<span class="token operator">!</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">const</span> Get <span class="token operator">=</span> <span class="token function">methodDecoratorFactory</span><span class="token punctuation">(</span><span class="token constant">REQUEST_METHOD</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">const</span> Post <span class="token operator">=</span> <span class="token function">methodDecoratorFactory</span><span class="token punctuation">(</span><span class="token constant">REQUEST_METHOD</span><span class="token punctuation">.</span><span class="token constant">POST</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样一来，<code>@Get(&quot;/list&quot;)</code> 其实就是注册了 <code>ioc:method - ioc:get</code>，<code>ioc:path - &quot;list&quot;</code> 这样的两对元数据，分别标识了请求方法与请求路径。需要注意的是，我们是在方法体上去注册的，这样在最终处理时，可以<strong>通过这个类的原型拿到方法体</strong>，继而获得注册的元数据。</p><p>Controller 中就简单一些了，我们只需要拿到它的请求路径信息，然后拼接在这个类中所有请求方法的请求路径前即可：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">const</span> Controller <span class="token operator">=</span> <span class="token punctuation">(</span>path<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> ClassDecorator <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    Reflect<span class="token punctuation">.</span><span class="token function">defineMetadata</span><span class="token punctuation">(</span><span class="token constant">METADATA_KEY</span><span class="token punctuation">.</span><span class="token constant">PATH</span><span class="token punctuation">,</span> path <span class="token operator">??</span> <span class="token string">''</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在最后信息组装时，我们需要做这么几步：</p><ul><li>获取根路径，即 Controller 装饰器的入参</li><li>获取这个类实例的原型对象</li><li>在原型对象上基于方法名获得方法体，继而拿到定义的请求路径、请求方法、请求实现</li></ul><p>来看实际代码：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">AsyncFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span><span class="token keyword">interface</span> <span class="token class-name">ICollected</span> <span class="token punctuation">&#123;</span>  path<span class="token operator">:</span> <span class="token builtin">string</span>  requestMethod<span class="token operator">:</span> <span class="token builtin">string</span>  requestHandler<span class="token operator">:</span> AsyncFunc<span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">const</span> routerFactory <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">object</span><span class="token operator">></span><span class="token punctuation">(</span>ins<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> ICollected<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> prototype <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>ins<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">any</span>  <span class="token keyword">const</span> rootPath <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">(</span>    Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token constant">METADATA_KEY</span><span class="token punctuation">.</span><span class="token constant">PATH</span><span class="token punctuation">,</span> prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span>  <span class="token punctuation">)</span>  <span class="token keyword">const</span> methods <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span>    Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>prototype<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">=></span> item <span class="token operator">!==</span> <span class="token string">'constructor'</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span>  <span class="token keyword">const</span> collected <span class="token operator">=</span> methods<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> requestHandler <span class="token operator">=</span> prototype<span class="token punctuation">[</span>m<span class="token punctuation">]</span>    <span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">></span>Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token constant">METADATA_KEY</span><span class="token punctuation">.</span><span class="token constant">PATH</span><span class="token punctuation">,</span> requestHandler<span class="token punctuation">)</span>    <span class="token keyword">const</span> requestMethod <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">(</span>      Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token constant">METADATA_KEY</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">,</span> requestHandler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>        <span class="token string">'ioc:'</span><span class="token punctuation">,</span>        <span class="token string">''</span>      <span class="token punctuation">)</span>    <span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      path<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>rootPath<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>path<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>      requestMethod<span class="token punctuation">,</span>      requestHandler<span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> collected<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于开始我们给出的路由使用方法，收集到的最终信息是这样的：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span>  <span class="token punctuation">&#123;</span>    path<span class="token operator">:</span> '/user/list'<span class="token punctuation">,</span>    requestMethod<span class="token operator">:</span> 'get'<span class="token punctuation">,</span>    requestHandler<span class="token operator">:</span> <span class="token punctuation">[</span>AsyncFunction<span class="token operator">:</span> userList<span class="token punctuation">]</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>    path<span class="token operator">:</span> '/user/add'<span class="token punctuation">,</span>    requestMethod<span class="token operator">:</span> 'post'<span class="token punctuation">,</span>    requestHandler<span class="token operator">:</span> <span class="token punctuation">[</span>AsyncFunction<span class="token operator">:</span> addUser<span class="token punctuation">]</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们就要来使用一个真正的 Node 服务来检验一下了，直接使用内置的 HTTP 模块启动一个服务器：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> http <span class="token keyword">from</span> <span class="token string">'http'</span>http  <span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'listening'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Server ready at http://localhost:3000 \n'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们需要做的，就是在 createServer 内去依据请求路径与请求方法调用对应的实现了。我们会遍历收集到的信息，查看是否有某一个对象的路径与请求方法都匹配上了，如果有，就调用这个方法返回：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">http  <span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> info <span class="token keyword">of</span> collected<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>        req<span class="token punctuation">.</span>url <span class="token operator">===</span> info<span class="token punctuation">.</span>path <span class="token operator">&amp;&amp;</span>        req<span class="token punctuation">.</span>method <span class="token operator">===</span> info<span class="token punctuation">.</span>requestMethod<span class="token punctuation">.</span><span class="token function">toLocaleUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        info<span class="token punctuation">.</span><span class="token function">requestHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>          res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token string-property property">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'application/json'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>          res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'listening'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Server ready at http://localhost:3000 \n'</span><span class="token punctuation">)</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'GET /user/list at http://localhost:3000/user/list \n'</span><span class="token punctuation">)</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'POST /user/add at http://localhost:3000/user/add \n'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Controller 中新增简单的方法返回：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Controller</span></span><span class="token punctuation">(</span><span class="token string">'/user'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token string">'/list'</span><span class="token punctuation">)</span>  <span class="token keyword">async</span> <span class="token function">userList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      success<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      code<span class="token operator">:</span> <span class="token number">10000</span><span class="token punctuation">,</span>      data<span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          name<span class="token operator">:</span> <span class="token string">'linbudu'</span><span class="token punctuation">,</span>          age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          name<span class="token operator">:</span> <span class="token string">'林不渡'</span><span class="token punctuation">,</span>          age<span class="token operator">:</span> <span class="token number">28</span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Post</span></span><span class="token punctuation">(</span><span class="token string">'/add'</span><span class="token punctuation">)</span>  <span class="token keyword">async</span> <span class="token function">addUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      success<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      code<span class="token operator">:</span> <span class="token number">10000</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问 <a href="https://link.juejin.cn/?target=http%3A%2F%2Flocalhost%3A3000%2Fuser%2Flist">http://localhost:3000/user/list</a> 来试一下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f97f6adccf947c09bec6eb9e81a28b6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>成功了！是不是还有点小激动？你还可以试着加上同样基于装饰器的中间件、拦截器等机制，思路仍然是一致的：<strong>注册</strong>、<strong>提取</strong>、<strong>组装</strong>以及<strong>匹配调用</strong>。</p><p>实际上，在 Nest 这一类框架中，通常会通过完整的容器机制来进行元数据的注册与提取，如 <code>routerFactory(new UserController())</code> 这一过程，其实就是在你从容器中取出这个类时就已经自动完成了的。那么，我们要如何实现一个如此贴心的容器？</p><h2 id="实现一个简易-IoC-容器"><a href="#实现一个简易-IoC-容器" class="headerlink" title="实现一个简易 IoC 容器"></a>实现一个简易 IoC 容器</h2><p>实现一个简单的 IoC 容器可以很好地帮助我们总结装饰器、依赖注入、元数据的相关知识，以及理解“控制反转”的本质。</p><p>关于这个容器，我们最终想实现的使用方式是这样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Provide</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Driver</span> <span class="token punctuation">&#123;</span>  <span class="token function">adapt</span><span class="token punctuation">(</span>consumer<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\n === 驱动已生效于 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>consumer<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">！===\n</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Provide</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  driver<span class="token operator">!</span><span class="token operator">:</span> Driver  <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>driver<span class="token punctuation">.</span><span class="token function">adapt</span><span class="token punctuation">(</span><span class="token string">'Car'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> car <span class="token operator">=</span> Container<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>Car<span class="token punctuation">)</span>car<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 驱动已生效于 Car ！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先来梳理一下思路，要实现这么个效果，首先我们需要一个容器，即控制反转中提到的<strong>独立的控制方</strong>，我们的 Car 依赖于驱动 Driver，这个容器会帮我们完成 Driver 注入到 Car 内的操作。那这个容器如何知道有哪些类需要被提前实例化呢？我们使用一个 Provide 装饰器，被其标记的 Class 会自动被容器收集。然后在需要使用这些类实例的地方，使用 Inject 装饰器声明这里需要哪个实例，容器就会自动地将这个属性注入进来。</p><p>这里有一个比较复杂的地方，在存储一个类和注入一个类时，我们需要有一个标识符，才能实现一一对应的注入方式。在上面的例子里我们的 Provide 和 Inject 装饰器都是使用无参数调用的，这样的话标识符从何而来？你可能会想到使用内置的元数据信息！的确是这样，但是为了降低学习成本，我们先来了解如何不使用元数据来实现这个 IoC 容器，也就是我们能够这么使用：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Provide</span></span><span class="token punctuation">(</span><span class="token string">'DriverService'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Driver</span> <span class="token punctuation">&#123;</span>  <span class="token function">adapt</span><span class="token punctuation">(</span>consumer<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\n === 驱动已生效于 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>consumer<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">！===\n</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Provide</span></span><span class="token punctuation">(</span><span class="token string">'Car'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token string">'DriverService'</span><span class="token punctuation">)</span>  driver<span class="token operator">!</span><span class="token operator">:</span> Driver  <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>driver<span class="token punctuation">.</span><span class="token function">adapt</span><span class="token punctuation">(</span><span class="token string">'Car'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> car <span class="token operator">=</span> Container<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>Car<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">'Car'</span><span class="token punctuation">)</span><span class="token operator">!</span>car<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的话就就简单多了，我们只需要基于字符串来存储、查找、注入一个类就好了。</p><p>首先我们创建一个容器，很明显，它需要一个 Map 来以字符串-类的方式存储这些信息，以及 get 与 set 方法：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ClassStruct<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token builtin">any</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">T</span><span class="token keyword">class</span> <span class="token class-name">Container</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> services<span class="token operator">:</span> Map<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> ClassStruct<span class="token operator">></span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token function">set</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> value<span class="token operator">:</span> ClassStruct<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token builtin">any</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">private</span> <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用私有构造函数来避免这个类被错误地实例化，毕竟它其实只是用来将这些逻辑收拢到一起。</p><p>然后就像我们前面说的，Provide 和 Inject 装饰器需要进行存储与注入工作：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Provide</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> ClassDecorator <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>Target<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    Container<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> Target <span class="token keyword">as</span> <span class="token builtin">unknown</span> <span class="token keyword">as</span> ClassStruct<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">Inject</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> PropertyDecorator <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> propertyKey<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Provide 倒简单，但 Inject 就有些麻烦了，我们在前面提到属性装饰器是无法对类的属性进行操作的，因此我们这里只能使用委托的方式。也就是说，我们先告诉容器有哪些属性需要进行注入，以及需要注入的类的标识符，等我们从容器中去取这个类的时候，容器会帮我们处理这些。</p><p>因此容器中需要再增加一个 Map，它的键与键值均为字符串类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Container</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> propertyRegistry<span class="token operator">:</span> Map<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样在 Inject 中，我们需要做的就是注册信息：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Inject</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> PropertyDecorator <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> propertyKey<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    Container<span class="token punctuation">.</span>propertyRegistry<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>      <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>target<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token function">String</span><span class="token punctuation">(</span>propertyKey<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>      key    <span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，这里我们注册的是 <code>Car:driver</code> - <code>DriverService</code> 的形式，以此来同时保存这个属性所在的类名称。</p><p>接下来，我们需要做的就是 get 与 set 方法了。set 方法简单，直接注册 services 就好：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Container</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token function">set</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> value<span class="token operator">:</span> ClassStruct<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#123;</span>    Container<span class="token punctuation">.</span>services<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>get 方法就要复杂一些了，它需要在我们取出一个类（<code>Container.get(&#39;Car&#39;)</code>）时，帮我们实例化这个类以及注入这个类内部声明的依赖（<code>DriverService</code>）。整理一下具体步骤：</p><ul><li>使用传入的标识符在容器内查找这个类是否已经注册，如果有则进行下一步，没有就返回 undefined。</li><li>对于已注册的类，首先将其实例化，然后检查 <code>propertyRegistry</code> ，查看这个类内部是否声明了对外部的依赖？</li><li>将这些外部依赖的类从容器中取出（同样通过 get 方法），然后实例化。</li><li>将这些实例传递给对应的属性。</li></ul><p>我们的大致实现如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Container</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token builtin">any</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>key<span class="token operator">:</span> ServiceKey<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 检查是否注册</span>    <span class="token keyword">const</span> Cons <span class="token operator">=</span> Container<span class="token punctuation">.</span>services<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Cons<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">undefined</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 实例化这个类</span>    <span class="token keyword">const</span> ins <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 遍历注册信息</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> info <span class="token keyword">of</span> Container<span class="token punctuation">.</span>propertyRegistry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 注入标识符与要注入类的标识符</span>      <span class="token keyword">const</span> <span class="token punctuation">[</span>injectKey<span class="token punctuation">,</span> serviceKey<span class="token punctuation">]</span> <span class="token operator">=</span> info      <span class="token comment">// 拆分为 Class 名与属性名</span>      <span class="token keyword">const</span> <span class="token punctuation">[</span>classKey<span class="token punctuation">,</span> propKey<span class="token punctuation">]</span> <span class="token operator">=</span> injectKey<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">)</span>      <span class="token comment">// 如果不是这个类，就跳过</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>classKey <span class="token operator">!==</span> Cons<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token keyword">continue</span>      <span class="token comment">// 取出需要注入的类，这里拿到的是已经实例化的</span>      <span class="token keyword">const</span> target <span class="token operator">=</span> Container<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>serviceKey<span class="token punctuation">)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 赋值给对应的属性</span>        ins<span class="token punctuation">[</span>propKey<span class="token punctuation">]</span> <span class="token operator">=</span> target      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ins  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>来试着调用，会发现已经成功了：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93f2e0b4e48c490b9f30e9aaafcf361e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>每次传入字符串的实现肯定不够优雅，我们在使用 Nest、Angular 等框架时，也并不会经常使用字符串作为标识符来实现依赖注入。</p><p>可是，如果不使用字符串，我们要用什么来作为标识符呢？聪明的你肯定想到了，可以使用内置的元数据来作为标识符，比如在这种情况下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Provide</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  driver<span class="token operator">!</span><span class="token operator">:</span> Driver  <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>driver<span class="token punctuation">.</span><span class="token function">adapt</span><span class="token punctuation">(</span><span class="token string">'Car'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 driver 属性，我们就可以使用它的类型标注 Driver 来作为标识符。那接下来我们来改写上面的容器实现。</p><h3 id="基于内置元数据实现"><a href="#基于内置元数据实现" class="headerlink" title="基于内置元数据实现"></a>基于内置元数据实现</h3><p>其实最难的一部分我们已经解决了，即如何存储并对应地进行注入，现在要做的不过是升级优化一下，支持在不传入标识符时使用内置元数据作为标识符。首先对 Provide 和 Inject 做改造：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Provide</span><span class="token punctuation">(</span>key<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> ClassDecorator <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>Target<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    Container<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key <span class="token operator">??</span> Target<span class="token punctuation">.</span>name<span class="token punctuation">,</span> Target <span class="token keyword">as</span> <span class="token builtin">unknown</span> <span class="token keyword">as</span> ClassStruct<span class="token punctuation">)</span>    Container<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>Target<span class="token punctuation">,</span> Target <span class="token keyword">as</span> <span class="token builtin">unknown</span> <span class="token keyword">as</span> ClassStruct<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">Inject</span><span class="token punctuation">(</span>key<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> PropertyDecorator <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> propertyKey<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    Container<span class="token punctuation">.</span>propertyRegistry<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>      <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>target<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token function">String</span><span class="token punctuation">(</span>propertyKey<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>      key <span class="token operator">??</span> Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token string">'design:type'</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> propertyKey<span class="token punctuation">)</span>    <span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>本节的代码并没有在类型上进行十分精确的处理，这主要是为了避免增加额外的代码复杂度，毕竟我们的主要目的是<strong>理解依赖注入</strong>而不是类型。</p></blockquote><p>在 Inject 中，我们支持了在不传入标识符时，使用 <code>Reflect.getMetadata(&#39;design:type&#39;, target, propertyKey)</code> 作为默认的标识符，这里的元数据是一个完整的类，即 Class Driver 。</p><p>对应的，为了支持使用 Class 作为标识符进行查找，在 Provide 装饰器中我们需要确保也使用 Class 作为标识符来存储一份：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Provide</span><span class="token punctuation">(</span>key<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> ClassDecorator <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>Target<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    Container<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key <span class="token operator">??</span> Target<span class="token punctuation">.</span>name<span class="token punctuation">,</span> Target <span class="token keyword">as</span> <span class="token builtin">unknown</span> <span class="token keyword">as</span> ClassStruct<span class="token punctuation">)</span>    <span class="token comment">// 不论是否传入 key，都使用 Class 作为 key 注册一份</span>    Container<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>Target<span class="token punctuation">,</span> Target <span class="token keyword">as</span> <span class="token builtin">unknown</span> <span class="token keyword">as</span> ClassStruct<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就没了！我们并不需要修改 Container 的逻辑，只需要调整类型即可：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ServiceKey<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token builtin">any</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> ClassStruct<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token builtin">Function</span><span class="token keyword">class</span> <span class="token class-name">Container</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> services<span class="token operator">:</span> Map<span class="token operator">&lt;</span>ServiceKey<span class="token punctuation">,</span> ClassStruct<span class="token operator">></span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> propertyRegistry<span class="token operator">:</span> Map<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token function">set</span><span class="token punctuation">(</span>key<span class="token operator">:</span> ServiceKey<span class="token punctuation">,</span> value<span class="token operator">:</span> ClassStruct<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token builtin">any</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>key<span class="token operator">:</span> ServiceKey<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">private</span> <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们可以同时使用 <code>@Inject()</code> 与 <code>@Inject(&#39;DriverService&#39;)</code> 这两种方式来实现注入了，来最后测试一下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Provide</span></span><span class="token punctuation">(</span><span class="token string">'DriverService'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Driver</span> <span class="token punctuation">&#123;</span>  <span class="token function">adapt</span><span class="token punctuation">(</span>consumer<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\n === 驱动已生效于 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>consumer<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">！===\n</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Provide</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Fuel</span> <span class="token punctuation">&#123;</span>  <span class="token function">fill</span><span class="token punctuation">(</span>consumer<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\n === 燃料已填充完毕 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>consumer<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">！===</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Provide</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  driver<span class="token operator">!</span><span class="token operator">:</span> Driver  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  fule<span class="token operator">!</span><span class="token operator">:</span> Fuel  <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>fule<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token string">'Car'</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>driver<span class="token punctuation">.</span><span class="token function">adapt</span><span class="token punctuation">(</span><span class="token string">'Car'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Provide</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Bus</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token string">'DriverService'</span><span class="token punctuation">)</span>  driver<span class="token operator">!</span><span class="token operator">:</span> Driver  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token string">'Fuel'</span><span class="token punctuation">)</span>  fule<span class="token operator">!</span><span class="token operator">:</span> Fuel  <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>fule<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token string">'Bus'</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>driver<span class="token punctuation">.</span><span class="token function">adapt</span><span class="token punctuation">(</span><span class="token string">'Bus'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> car <span class="token operator">=</span> Container<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>Car<span class="token punctuation">)</span><span class="token operator">!</span><span class="token keyword">const</span> bus <span class="token operator">=</span> Container<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>Bus<span class="token punctuation">)</span><span class="token operator">!</span>car<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>bus<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ac6238730204b18b08c2f87cae66ce5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="image.png"></p><p>学习完这一节后，请你试着把上一部分的装饰器路由体系也基于这个简单的容器重新实现与改善，如新增对 Service 层与中间件层的注入：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 如何设计入参？</span><span class="token keyword">function</span> <span class="token function">logMiddleware</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 中间件逻辑在何时执行？</span><span class="token punctuation">&#125;</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Controller</span></span><span class="token punctuation">(</span><span class="token string">'/user'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">private</span> userService<span class="token operator">:</span> UserService<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Middleware</span></span><span class="token punctuation">(</span>logMiddleware<span class="token punctuation">)</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token string">'/list'</span><span class="token punctuation">)</span>  <span class="token keyword">async</span> <span class="token function">userList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userService<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Post</span></span><span class="token punctuation">(</span><span class="token string">'/add'</span><span class="token punctuation">)</span>  <span class="token keyword">async</span> <span class="token function">addUser</span><span class="token punctuation">(</span>user<span class="token operator">:</span> User<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userService<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这两节，我们花了相当长的篇幅对装饰器相关的概念与实际应用进行了一次彻底介绍。从装饰器语法到不同类型装饰器的使用，再到反射、反射元数据，最后到控制反转与依赖注入，以及简单的 IoC 路由与 IoC 容器实现。这些概念可以帮助你在使用基于装饰器的工具库时，更加熟悉其底层的原理。同时，如果你想自己开发一些基于装饰器的工具库，这一节的内容也是一个不错的开始。</p><p>在接下来两节，我们将投入另一个方面的实战：TSConfig 配置解析。如果你也曾对着一堆配置较劲半天，却没看出个所以然的经历，这一次可以放心了。我们将在下面两节全面解析大部分配置，包括每一条配置的作用、表现以及与它关联的配置们。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="类型严格的装饰器"><a href="#类型严格的装饰器" class="headerlink" title="类型严格的装饰器"></a>类型严格的装饰器</h3><p>在这一节的代码中，我们并没有特别关注类型的严格性。实际上装饰器的类型定义也是如此：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">type</span> <span class="token class-name">ClassDecorator</span> <span class="token operator">=</span> <span class="token operator">&lt;</span>TFunction <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Function</span></span><span class="token operator">></span><span class="token punctuation">(</span>  target<span class="token operator">:</span> TFunction<span class="token punctuation">)</span> <span class="token operator">=></span> TFunction <span class="token operator">|</span> <span class="token keyword">void</span><span class="token keyword">declare</span> <span class="token keyword">type</span> <span class="token class-name">PropertyDecorator</span> <span class="token operator">=</span> <span class="token punctuation">(</span>  target<span class="token operator">:</span> Object<span class="token punctuation">,</span>  propertyKey<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">symbol</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些类型定义使用的是非常宽泛的类型， 并没有进行对应的约束。而如果将这些类型进行约束，实际上我们就可以实现一个类型严格的装饰器。如我们希望装饰器 <code>@OnlyFoo</code> 只能在 Foo 及其子类上应用，此时就可以通过约束 target 的类型实现：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ClassStruct<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token builtin">any</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">T</span><span class="token keyword">type</span> <span class="token class-name">RestrictedClassDecorator<span class="token operator">&lt;</span>TClass <span class="token keyword">extends</span> object<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>  target<span class="token operator">:</span> ClassStruct<span class="token operator">&lt;</span>TClass<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=></span> ClassStruct<span class="token operator">&lt;</span>TClass<span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">void</span><span class="token keyword">function</span> <span class="token function">OnlyFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> RestrictedClassDecorator<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> ClassStruct<span class="token operator">&lt;</span>Foo<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">OnlyBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> RestrictedClassDecorator<span class="token operator">&lt;</span>Bar<span class="token operator">></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> ClassStruct<span class="token operator">&lt;</span>Bar<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>来实际使用一下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">OnlyFoo</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 装饰器函数返回类型“void | ClassStruct&lt;Bar>”不可分配到类型“void | typeof Foo”</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">OnlyBar</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  foo<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">OnlyFoo</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">DerivedFoo</span> <span class="token keyword">extends</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  foo<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token comment">// 装饰器函数返回类型“void | ClassStruct&lt;Foo>”不可分配到类型“void | typeof Bar”。</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">OnlyFoo</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">OnlyBar</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token punctuation">&#123;</span>  bar<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似的，我们还可以实现约束方法装饰器只能在同步或异步函数上调用：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">AsyncFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span><span class="token keyword">type</span> <span class="token class-name">OnlyAsyncMethodDecorator</span> <span class="token operator">=</span> <span class="token punctuation">(</span>  target<span class="token operator">:</span> Object<span class="token punctuation">,</span>  propertyKey<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">symbol</span><span class="token punctuation">,</span>  descriptor<span class="token operator">:</span> TypedPropertyDescriptor<span class="token operator">&lt;</span>AsyncFunc<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token keyword">function</span> <span class="token function">OnlyAsyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> OnlyAsyncMethodDecorator <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 类型“TypedPropertyDescriptor&lt;() => void>”的参数不能赋给类型“TypedPropertyDescriptor&lt;AsyncFunc>”的参数。</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">OnlyAsyncFunc</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">OnlyAsyncFunc</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">async</span> <span class="token function">asyncHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以及属性装饰器只用应用在特定类型的属性上：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">LiteralPropertyDecorator</span> <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> Object<span class="token punctuation">,</span> propertyKey<span class="token operator">:</span> <span class="token string">'linbudu'</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token keyword">function</span> <span class="token function">OnlyLiteralProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> LiteralPropertyDecorator <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> propertyKey<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">PickByValueType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> Value<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span>Key <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span>Key<span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">Value</span> <span class="token operator">?</span> Key <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token keyword">type</span> <span class="token class-name">StringTypePropertyDecorator</span> <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">object</span><span class="token operator">></span><span class="token punctuation">(</span>  target<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span>  propertyKey<span class="token operator">:</span> PickByValueType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token keyword">function</span> <span class="token function">OnlyStringTypeProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> StringTypePropertyDecorator <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> propertyKey<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">OnlyStringTypeProperty</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  str<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token comment">// 类型“"bool"”的参数不能赋给类型“PickByValueType&lt;Foo, string>”的参数。</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">OnlyStringTypeProperty</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  bool<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">true</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">OnlyLiteralProperty</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  linbudu<span class="token operator">!</span><span class="token operator">:</span> <span class="token string">'linbudu'</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里比较巧妙的是，由于我们只能获取到被装饰的属性名，无法直接获取到其类型，因此通过此前我们学习过的 PickByValueType 工具类型，将这个类上所有符合类型的属性名都提取了出来（作为字面量类型），然后使用这一字面量类型作为类型约束。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>27.TSConfig 全解（上）：构建相关配置</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/27.TSConfig%20%E5%85%A8%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/27.TSConfig%20%E5%85%A8%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>在前面的内容中，我们已经学习了 TypeScript 在工程中的许多实践，包括类型声明、TypeScript 与 React、ESLint 的结合使用以及装饰器等。这些实践更像是上层建筑，默认是在一个已经基本配置完环境的 TypeScript 项目中进行的。这一节，我们深入下层基础，来了解 TypeScript 工程中最基础的一部分：TSConfig 配置。</p><p>为什么选择现在才讲配置呢？因为在前面的工程实践中，我们并不需要自己去修改 TSConfig，脚手架已经帮我们处理好了。有了实践经验，再来讲解讲解这些配置效果会更好。</p><p>为了避免罗列配置这种填鸭式教学，我将 TSConfig 分为三个大类：<strong>构建相关</strong>、<strong>类型检查相关</strong>以及<strong>工程相关</strong>。这其实也对应着我们的开发流程：使用工程能力进行项目开发，检查源码是否符合配置约束，然后才是输出产物。每一个大类又可以划分为几个小类，比如构建相关又可以分为<strong>构建源码相关</strong>与<strong>构建产物相关</strong>等等，我们会按照这些分类的方式进行聚合地讲解。</p><p>最后，正如我对这本小册的定位也包括工具书一样，当你在实际项目开发遗忘了某一项具体配置的作用，或者发现某一配置表现不符合预期，都可以回到这里来寻找答案。</p><p>这一节我们主要介绍构建相关的配置。</p><h2 id="构建相关"><a href="#构建相关" class="headerlink" title="构建相关"></a>构建相关</h2><h3 id="构建源码相关"><a href="#构建源码相关" class="headerlink" title="构建源码相关"></a>构建源码相关</h3><h4 id="特殊语法相关"><a href="#特殊语法相关" class="headerlink" title="特殊语法相关"></a>特殊语法相关</h4><h5 id="experimentalDecorators-与-emitDecoratorMetadata"><a href="#experimentalDecorators-与-emitDecoratorMetadata" class="headerlink" title="experimentalDecorators 与 emitDecoratorMetadata"></a>experimentalDecorators 与 emitDecoratorMetadata</h5><p>这两个选项都和装饰器有关，其中 experimentalDecorators 选项用于启用装饰器的 <code>@</code> 语法，而 emitDecoratorMetadata 配置则影响装饰器实际运行时的元数据相关逻辑，我们在装饰器一节中已经了解了此选项对实际编译代码的作用：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> __metadata <span class="token operator">=</span>  <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__metadata<span class="token punctuation">)</span> <span class="token operator">||</span>  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">k<span class="token punctuation">,</span> v</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Reflect <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> Reflect<span class="token punctuation">.</span>metadata <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">metadata</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token function">__decorate</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>    <span class="token function">Prop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">__metadata</span><span class="token punctuation">(</span><span class="token string">'design:type'</span><span class="token punctuation">,</span> String<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 来自于 emitDecoratorMetadata 配置，其它 __metadata 方法同</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span>  <span class="token string">'prop'</span><span class="token punctuation">,</span>  <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">__decorate</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>    <span class="token function">Method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">__param</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">Param</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">__metadata</span><span class="token punctuation">(</span><span class="token string">'design:type'</span><span class="token punctuation">,</span> Function<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">__metadata</span><span class="token punctuation">(</span><span class="token string">'design:paramtypes'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>String<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">__metadata</span><span class="token punctuation">(</span><span class="token string">'design:returntype'</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span>  <span class="token string">'handler'</span><span class="token punctuation">,</span>  <span class="token keyword">null</span><span class="token punctuation">)</span>Foo <span class="token operator">=</span> <span class="token function">__decorate</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span><span class="token function">Cls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">__param</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">Param</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">__metadata</span><span class="token punctuation">(</span><span class="token string">'design:paramtypes'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>String<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  Foo<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="jsx、jsxFactory、jsxFragmentFactory-与-jsxImportSource"><a href="#jsx、jsxFactory、jsxFragmentFactory-与-jsxImportSource" class="headerlink" title="jsx、jsxFactory、jsxFragmentFactory 与 jsxImportSource"></a>jsx、jsxFactory、jsxFragmentFactory 与 jsxImportSource</h5><p>这部分配置主要涉及 jsx(tsx) 相关的语法特性。其中，jsx 配置将直接影响 JSX 组件的构建表现，常见的主要有 <code>react</code> （将 JSX 组件转换为对 <code>React.createElement</code> 调用，生成 <code>.js</code> 文件）、<code>preserve</code>（原样保留 JSX 组件，生成 <code>.jsx</code> 文件，你可以接着让其他的编译器进行处理）、<code>react-native</code> （类似于 preserve，但会生成 <code>.js</code> 文件）。</p><p>如果你希望使用特殊的 jsx 转换，也可以将其配置为 <code>react-jsx</code> / <code>react-jsxdev</code>，这样 JSX 组件会被转换为对 <code>__jsx</code> 方法的调用与生成 <code>.js</code> 文件，此方法来自于 <code>react/jsx-runtime</code>。</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token comment">// react</span><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">helloWorld</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'Hello world'</span><span class="token punctuation">)</span><span class="token comment">// preserve / react-native</span><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">helloWorld</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span><span class="token plain-text">Hello world</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token comment">// react-jsx</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> jsx <span class="token keyword">as</span> _jsx <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react/jsx-runtime'</span><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">helloWorld</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">_jsx</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">'Hello world'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// react-jsxdev</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> jsxDEV <span class="token keyword">as</span> _jsxDEV <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react/jsx-dev-runtime'</span><span class="token keyword">const</span> _jsxFileName <span class="token operator">=</span>  <span class="token string">'/home/runner/work/TypeScript-Website/TypeScript-Website/index.tsx'</span><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">helloWorld</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>  <span class="token function">_jsxDEV</span><span class="token punctuation">(</span>    <span class="token string">'h1'</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">'Hello world'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token literal-property property">fileName</span><span class="token operator">:</span> _jsxFileName<span class="token punctuation">,</span> <span class="token literal-property property">lineNumber</span><span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token literal-property property">columnNumber</span><span class="token operator">:</span> <span class="token number">32</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token keyword">this</span>  <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了 jsx 以外，其它 jsx 相关配置使用较少，我们简单了解即可。</p><ul><li><p>jsxFactory，影响负责最终处理转换完毕 JSX 组件的方法，默认即为 <code>React.createElement</code>。如果你想使用 <code>preact.h</code> 作为处理方法，可以将其配置为 <code>h</code>。</p></li><li><p>jsxFragmentFactory，类似 jsxFactory，只不过它影响的是 Fragment 组件（<code>&lt;&gt;&lt;/&gt;</code>）的提供方。jsxFactory 与 jsxFragmentFactory 均是 TS 4.1 版本以前用于实现自定义 JSX 转换的配置项，举例来说，当设置了 <code>&quot;jsx&quot;: &quot;react&quot;</code>，此时将 jsxFragmentFactory 设置为 <code>Fragment</code> ，同时将 jsxFactory 设置为 <code>h</code>：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> h<span class="token punctuation">,</span> Fragment <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'preact'</span><span class="token keyword">const</span> <span class="token function-variable function">HelloWorld</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">Hello</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token comment">// 转换为以下代码</span><span class="token keyword">const</span> preact_1 <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'preact'</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token function-variable function">HelloWorld</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>  <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> preact_1<span class="token punctuation">.</span>h<span class="token punctuation">)</span><span class="token punctuation">(</span>    preact_1<span class="token punctuation">.</span>Fragment<span class="token punctuation">,</span>    <span class="token keyword">null</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> preact_1<span class="token punctuation">.</span>h<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'Hello'</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了简化自定义 JSX 转换的配置，4.1 版本以后 TS 支持使用 jsxImportSource 属性快速地调整。</p></li><li><p>jsxImportSource，当你的 jsx 设置为 <code>react-jsx</code> / <code>react-jsxdev</code> 时，指定你的 <code>jsx-runtime</code> / <code>jsx-dev-runtime</code> 从何处导入。如设置为 <code>preact</code> 时，会从 <code>preact/jsx-runtime</code> 导入 <code>_jsx</code> 函数，用于进行 JSX 组件的转换。类似的，在另一个类 React 框架 Solid 中，也将此配置修改为了自己的实现： <code>&quot;jsxImportSource&quot;: &quot;solid-js&quot;</code>。</p></li></ul><p>这也是 React 17 中的变化之一，在 17 版本前后的构建后代码如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// v17 前</span><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'Hello world'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// v17 后</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> jsx <span class="token keyword">as</span> _jsx <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react/jsx-runtime'</span><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">_jsx</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">'Hello world'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这也是在 17 版本以后，不需要再确保代码中导入了 React 就能使用 JSX 的原因。</p><h5 id="target-与-lib、noLib"><a href="#target-与-lib、noLib" class="headerlink" title="target 与 lib、noLib"></a>target 与 lib、noLib</h5><p>target 配置决定了你的构建代码使用的语法，常用值包括 es5、es6、es2018、es2021、esnext（基于目前的 TypeScript 版本所支持的最新版本） 等等。某些来自于更高版本 ECMAScript 的语法，会在编译到更低版本时进行语法的降级，常见的如异步函数、箭头函数、bigint 数据类型等。</p><p>类似的，在 Babel 中也有 targets 的概念。但这里的 targets 通常指的是预期运行的浏览器，如 chrome 89，然后基于 browserlist 获取浏览器信息，基于 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fcaniuse.com%2F">caniuse</a> 或者 compat-table 获取各个浏览器版本支持的特性，最后再进行语法的降级。</p><p>如果没有特殊需要，推荐将 target 设置为 <code>&quot;es2018&quot;</code>，一个对常用语法支持较为全面的版本。</p><p>更改 target 配置也会同时影响你的 lib 配置默认值，而它决定了你是否能使用某些来自于更新版本的 ECMAScript 语法，以 replaceAll 为例，如果你直接在项目中使用：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token string">'linbudu'</span><span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'dd'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，如果你的 lib 配置中不包含 <code>&quot;es2021&quot;</code> 或者 <code>&quot;es2021.String&quot;</code>，上面的代码就会给出一个错误提示：<strong><em>属性“replaceAll”在类型“”linbudu””上不存在。是否需要更改目标库? 请尝试将 “lib” 编译器选项更改为“es2021”或更高版本</em></strong>。</p><p>正如我们在类型声明一节中了解的，TypeScript 会自动加载内置的 <code>lib.d.ts</code> 等声明文件，而加载哪些文件则和 lib 配置有关。当我们配置了 <code>&quot;es2021&quot;</code> 或者 <code>&quot;es2021.String&quot;</code>，replaceAll 方法对应的声明文件 <code>lib.es2021.string.d.ts</code> 就会被加载，然后我们的 String 类型上才有了 lib 方法。</p><p>除了高版本语法以外，lib 其实也和你的实际运行环境有关。比如，当你的代码仅在 Node 环境下运行时，你的 lib 中不应当包含 <code>&quot;DOM&quot;</code> 这个值。对应的，代码中无法使用 window 、document 等全局变量。</p><p>而 target 对 lib 的影响在于，当你的 target 为更高的版本时，它会自动地将这个版本新语法对应的 lib 声明加载进来，以上面的代码为例， target 为 <code>&quot;es2021&quot;</code> 时，你不需要添加 <code>&quot;es2021&quot;</code> 到 lib 中也能使用 ECMAScript2021 的新方法 replaceAll。这是因为既然你的编译产物都到这个版本了，那你当然可以直接使用这个方法啦。</p><p>如果你希望使用自己提供的 lib 声明定义，可以启用 noLib 配置，这样 TypeScript 将不会去加载内置的类型定义，但你需要为所有内置对象提供类型定义（String，Function，Object 等）才能进行编译。如果你的运行环境中存在大量的定制方法，甚至对原本的内置方法做了覆盖，就可以使用此配置来加载自己的类型声明。</p><p>最后，target 与 lib 配置会随着 TS 的版本更新而新增可用的值，如在 4.6 版本新增了 <code>es2022</code>这一选项，支持了 <code>Array.at()</code>、<code>Error Cause</code> 等新的语言特性。</p><h3 id="构建解析相关"><a href="#构建解析相关" class="headerlink" title="构建解析相关"></a>构建解析相关</h3><p>这部分配置主要控制源码解析，包括从何处开始收集要构建的文件，如何解析别名路径等等。</p><h4 id="files、include-与-exclude"><a href="#files、include-与-exclude" class="headerlink" title="files、include 与 exclude"></a>files、include 与 exclude</h4><p>这三个选项决定了将被包括到本次编译的代码文件。使用 files 我们可以描述本次包含的所有文件，但不能使用 <code>src</code> 或者 <code>src/*</code> 这种方式，每个值都需要是完整的文件路径，适合在小型项目时使用：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"files"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src/index.ts"</span><span class="token punctuation">,</span> <span class="token string">"src/handler.ts"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果你的文件数量较多，或者分散在各个文件夹，此时可以使用 include 和 exclude 进行配置，在这里可以传入文件夹或者 <code>src/*</code> 这样的 glob pattern，也可以传入完整的文件路径。</p><p>include 配置方式参考：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"include"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src/**/*"</span><span class="token punctuation">,</span> <span class="token string">"generated/*.ts"</span><span class="token punctuation">,</span> <span class="token string">"internal/*"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，<code>src/**/*</code> 表示匹配 src 下所有的合法文件，而无视目录层级。而 <code>internal/*</code> 则只会匹配 internal 下的文件，不会匹配 <code>internal/utils/</code> 下的文件。这里的合法文件指的是，在不包括文件扩展名（<code>*.ts</code>）的情况下只会匹配 <code>.ts</code> / <code>.tsx</code> / <code>.d.ts</code> / <code>.js</code> / <code>.jsx</code> 文件（js 和 jsx 文件需要启用 allowJs 配置时才会被包括）。</p><p>由于我们会在 include 中大量使用 glob pattern 来一次性匹配许多文件，如果存在某些非预期的文件也符合这一匹配模式，比如 <code>src/handler.test.ts</code> <code>src/file-excluded/</code> 这样，此时专门为需要匹配的文件书写精确的匹配模式就太麻烦了。因此，我们可以使用 exclude 配置，来从被 include 匹配到的文件中再移除一部分，如：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"include"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src/**/*"</span><span class="token punctuation">,</span> <span class="token string">"generated/*.ts"</span><span class="token punctuation">,</span> <span class="token string">"internal/*"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"exclude"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src/file-excluded"</span><span class="token punctuation">,</span> <span class="token string">"/**/*.test.ts"</span><span class="token punctuation">,</span> <span class="token string">"/**/*.e2e.ts"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，<strong>exclude 只能剔除已经被 include 包含的文件</strong>。</p><h4 id="baseUrl"><a href="#baseUrl" class="headerlink" title="baseUrl"></a>baseUrl</h4><p>这一配置可以定义文件进行解析的根目录，它通常会是一个相对路径，然后配合 tsconfig.json 所在的路径来确定根目录的位置。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">project├── out.ts├── src├──── core.ts└── tsconfig.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个结构下，如果配置为 <code>&quot;baseUrl&quot;: &quot;./&quot;</code>，根目录就会被确定为 project。</p><p>你也可以通过这一配置，在导入语句中使用相对 baseUrl 的解析路径。如在上面根目录已经确定为 project，在 <code>out.ts</code> 中，你就可以直接使用基于根目录的绝对路径导入文件：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token string">'src/core'</span> <span class="token comment">// TS 会自动解析到对应的文件，即 "./src/core.ts"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="rootDir"><a href="#rootDir" class="headerlink" title="rootDir"></a>rootDir</h4><p>rootDir 配置决定了项目文件的根目录，默认情况下它是项目内<strong>包括</strong>的所有 .ts 文件的最长公共路径，这里有几处需要注意：</p><ul><li><strong>包括</strong>指的是 include 或 files 中包括的 <code>.ts</code> 文件，这些文件一般来说不会和 tsconfig.json 位于同一目录层级；</li><li>不包括 <code>.d.ts</code> 文件，因为声明文件可能会和 tsconfig.json 位于同一层级。</li></ul><p>最长公共路径又是什么？简单地说，它就是某一个<strong>包含了所有被包括的 <code>.ts</code> 文件的文件夹</strong>，TypeScript 会找到这么一个文件夹，默认将其作为 rootDir。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">PROJECT├── src│   ├── index.ts│   ├── app.ts│   ├── utils│   │   ├── helpers.ts├── declare.d.ts├── tsconfig.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，rootDir 会被推断为 src。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">PROJECT├── env│   ├── env.dev.ts│   ├── env.prod.ts├── app│   ├── index.ts├── declare.d.ts├── tsconfig.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，rootDir 会被推断为 <code>.</code>，即 <code>tsconfig.json</code> 所在的目录。</p><p>构建产物的目录结构会受到这一配置的影响，假设 outDir 被配置为 <code>dist</code>，在上面的第一种情况下，最终的产物会被全部放置在 dist 目录下，保持它们在 <code>src</code>（也就是 rootDir） 内的目录结构：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">PROJECT├── dist│   ├── index.js│   ├── index.d.ts│   ├── app.js│   ├── app.d.ts│   ├── utils│   │   ├── helpers.js│   │   ├── helpers.d.ts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你将 rootDir 更改为推导得到的 rootDir 的父级目录，比如在这里把它更改到了项目根目录 <code>.</code>。此时 <code>src</code> 会被视为 rootDir 的一部分，因此最终构建目录结构中会多出 <code>src</code> 这一级：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">PROJECT├── dist├── ├──src│      ├── index.js│      ├── index.d.ts│      ├── app.js│      ├── app.d.ts│      ├── utils│      │   ├── helpers.js│      │   ├── helpers.d.ts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，如果你显式指定 rootDir ，需要确保其包含了所有 <strong>“被包括”</strong> 的文件，因为 TypeScript 需要确保这所有的文件都被生成在 outDir 内。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">PROJECT├── src│   ├── index.ts│   ├── app.ts│   ├── utils│   │   ├── helpers.ts├── env.ts├── tsconfig.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，如果你指定 rootDir 为 <code>src</code> ，会导致 <code>env.ts</code> 被生成到 <code>&lt;project&gt;/env.js</code> 而非 <code>&lt;project&gt;/dist/env.js</code> 。</p><h4 id="rootDirs"><a href="#rootDirs" class="headerlink" title="rootDirs"></a>rootDirs</h4><p>rootDirs 就是复数版本的 rootDir，它接收一组值，并且会将这些值均视为平级的根目录：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"rootDirs"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src/zh"</span><span class="token punctuation">,</span> <span class="token string">"src/en"</span><span class="token punctuation">,</span> <span class="token string">"src/jp"</span><span class="token punctuation">]</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>PROJECT├── src│   ├── zh│   │   ├── locale.ts│   ├── en│   │   ├── locale.ts│   ├── jp│   │   ├── locale.ts│   ├── index.ts├── tsconfig.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 rootDirs，TypeScript 还是会隐式地推导 rootDir，此时它的值为 rootDirs 中所有文件夹最近的公共父文件夹，在这里即是 <code>src</code>。你肯定会想，那 rootDirs 还有什么用？实际上它主要用于实现<strong>多个虚拟目录的合并解析</strong>。还是以上面的例子为例，假设我们的目录结构是现在这样的：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">PROJECT├── src│   ├── locales│   │   ├── zh.locale.ts│   │   ├── en.locale.ts│   │   ├── jp.locale.ts│   ├── index.ts│── generated│   ├── messages│   │   ├── main.mapper.ts│   │   ├── info.mapper.ts├── tsconfig.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个目录结构中，<code>locales</code> 下存放我们定义的每个语言的对应翻译，<code>generated/messages</code> 则是通过扫描项目获得所有需要进行代码替换位置后生成的映射关系，我们在 <code>.locale.ts</code> 文件中会导入其中的 mapper 文件来生成对应的导出。</p><p>虽然现在 locale 文件和 mapper 文件被定义在不同的目录下，但在构建产物中它们实际上是位于同一层级的：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">│── dist│   ├── zh.locale.js│   ├── en.locale.js│   ├── jp.locale.js│   ├── main.mapper.js│   ├── info.mapper.js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这也就意味着，我们应当是在 locale 文件中直接通过 <code>./main.mapper</code> 的路径来引用 mapper 文件的，而不是 <code>../../generated/messages/main.mapper.ts</code> 这样。</p><p>此时，我们就可以利用 rootDirs 配置来让 TS 将这两个相隔甚远的文件夹视为处于同一目录下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"rootDirs"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src/locales"</span><span class="token punctuation">,</span> <span class="token string">"generated/messages"</span><span class="token punctuation">]</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一配置并不会影响实际的产物生成，它只会告诉 TS 将这两个模块视为同一层级下（类型定义层面）。</p><h4 id="types-与-typeRoots"><a href="#types-与-typeRoots" class="headerlink" title="types 与 typeRoots"></a>types 与 typeRoots</h4><p>默认情况下，TypeScript 会加载 <code>node_modules/@types/</code> 下的所有声明文件，包括嵌套的 <code>../../node_modules/@types</code> 路径，这么做可以让你更方便地使用第三方库的类型。但如果你希望只加载实际使用的类型定义包，就可以通过 types 配置：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"types"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"node"</span><span class="token punctuation">,</span> <span class="token string">"jest"</span><span class="token punctuation">,</span> <span class="token string">"react"</span><span class="token punctuation">]</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下，只有 <code>@types/node</code>、<code>@types/jest</code> 以及 <code>@types/react</code> 会被加载。</p><p>即使其他 <code>@types/</code> 包没有被包含，它们也仍然能拥有完整的类型，但其中的全局声明（如 <code>process</code>，<code>expect</code>，<code>describe</code> 等全局变量）将不会被包含，同时也无法再享受到基于类型的提示。</p><p>如果你甚至希望改变加载 <code>@types/</code> 下文件的行为，可以使用 typeRoots 选项，其默认为 <code>@types</code>，即指定 <code>node_modules/@types</code> 下的所有文件（仍然包括嵌套的）。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"typeRoots"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token string">"./node_modules/@types"</span><span class="token punctuation">,</span>      <span class="token string">"./node_modules/@team-types"</span><span class="token punctuation">,</span>      <span class="token string">"./typings"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"types"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"react"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"skipLibCheck"</span><span class="token operator">:</span> <span class="token boolean">true</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上配置会尝试加载 <code>node_modules/@types/react</code> 以及 <code>./node_modules/@team-types/react</code> 、<code>./typings/react</code> 中的声明文件，注意我们需要使用<strong>相对于 baseUrl 的相对路径</strong>。</p><p>加载多个声明文件可能会导致内部的声明冲突，所以你可能会需要 skipLibCheck 配置来禁用掉对加载的类型声明的检查。</p><h4 id="moduleResolution"><a href="#moduleResolution" class="headerlink" title="moduleResolution"></a>moduleResolution</h4><p>这一配置指定了模块的解析策略，可以配置为 node 或者 classic ，其中 node 为默认值，而 classic 主要作向后兼容用，基本不推荐使用。</p><p>首先来看 node 解析模式，从名字也能看出来它其实就是与 node 一致的解析模式。假设我们有个 <code>src/index.js</code>，其中存在基于相对路径 <code>const foo = require(&quot;./foo&quot;)</code> 的导入，则会依次按照以下顺序解析：</p><ul><li><p><code>/&lt;root&gt;/&lt;project&gt;/src/foo.js</code> 文件是否存在？</p></li><li><p>```<br>/<root>/<project>/src/foo</p><pre class="line-numbers language-none"><code class="language-none">  是否是一个文件夹？  - 此文件夹内部是否包含 &#96;package.json&#96;，且其中使用 &#96;main&#96; 属性描述了这个文件夹的入口文件？  - 假设 &#96;main&#96; 指向 &#96;dist&#x2F;index.js&#96;，那这里会尝试寻找 &#96;&#x2F;&lt;root&gt;&#x2F;&lt;project&gt;&#x2F;src&#x2F;foo&#x2F;dist&#x2F;index.js&#96; 文件  - 否则的话，说明这个文件不是一个模块或者没有定义模块入口，我们走默认的 &#96;&#x2F;foo&#x2F;index.js&#96; 。而对于绝对路径，即 &#96;const foo &#x3D; require(&quot;foo&quot;)&#96;，其只会在 &#96;node_modules&#96; 中寻找，从 &#96;&#x2F;&lt;root&gt;&#x2F;&lt;project&gt;&#x2F;src&#x2F;node_modules&#96; 开始，到 &#96;&#x2F;&lt;root&gt;&#x2F;&lt;project&gt;&#x2F;node_modules&#96; ，再逐级向上直到根目录。TypeScript 在这基础上增加了对 &#96;.ts&#96; &#96;.tsx&#96; 和 &#96;.d.ts&#96; （优先级按照这一顺序）扩展名的文件解析，以及对 &#96;package.json&#96; 中 &#96;types&#96; 字段的加载。而对于 classic 模式，其解析逻辑可能不太符合直觉，其相对路径导入与绝对路径导入均不会解析 &#96;node_modules&#96; 中的文件。对于相对路径导入 &#96;import foo from &quot;.&#x2F;foo&quot;&#96;，它只会尝试 &#96;&#x2F;&lt;root&gt;&#x2F;&lt;project&gt;&#x2F;src&#x2F;foo.ts&#96; 和 &#96;&#x2F;&lt;root&gt;&#x2F;&lt;project&gt;&#x2F;src&#x2F;foo.d.ts&#96;。而对于绝对路径导入 &#96;import foo from &quot;foo&quot;&#96;，它会按照以下顺序来解析：- &#96;&#x2F;&lt;root&gt;&#x2F;&lt;project&gt;&#x2F;src&#x2F;foo.ts(.d.ts)&#96;- &#96;&#x2F;&lt;root&gt;&#x2F;&lt;project&gt;&#x2F;foo.ts(.d.ts)&#96;- &#96;&#x2F;&lt;root&gt;&#x2F;foo.ts(.d.ts)&#96;- &#96;&#x2F;foo.ts(.d.ts)&#96;绝大部分情况下你不会需要 classic 作为配置值，这里仅做了解即可。#### moduleSuffixes此配置在 4.7 版本被引入，类似于 moduleResolution ，它同样影响对模块的解析策略，但仅影响模块的后缀名部分。如以下配置：&#96;&#96;&#96;json&#123;  &quot;compilerOptions&quot;: &#123;    &quot;moduleSuffixes&quot;: [&quot;.ios&quot;, &quot;.native&quot;, &quot;&quot;]  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>此配置在解析文件时，会首先尝试查找 <code>foo.ios.ts</code>，然后是 <code>foo.native.ts</code>，最后才是 <code>foo.ts</code>（注意，需要最后的空字符串<code>&quot;&quot;</code>配置）。很明显，这一配置主要是为了 React Native 配置中的多平台构建配置。但你可以用它在 Angular 项目中，确保所有文件都使用了一个额外的后缀名，如 <code>user.service.ts</code>、<code>user.module.ts</code> 等。</p><h4 id="noResolve"><a href="#noResolve" class="headerlink" title="noResolve"></a>noResolve</h4><p>默认情况下， TypeScript 会将你代码中导入的文件也解析为程序的一部分，包括 import 导入和三斜线指令的导入，你可以通过禁用这一配置来阻止这个解析过程。</p><p>需要注意的是，虽然导入过程被禁用了，但你仍然需要确保导入的模块是一个合法的模块。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 开启此配置后，这个指令指向的声明文件将不会被加载！</span><span class="token comment">/// &lt;reference path="./other.d.ts" /></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="paths"><a href="#paths" class="headerlink" title="paths"></a>paths</h4><p>paths 类似于 Webpack 中的 alias，允许你通过 <code>@/utils</code> 或类似的方式来简化导入路径，它的配置方式是这样的：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"baseUrl"</span><span class="token operator">:</span> <span class="token string">"./"</span><span class="token punctuation">,</span>    <span class="token property">"paths"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"@/utils/*"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src/utils/*"</span><span class="token punctuation">,</span> <span class="token string">"src/other/utils/*"</span><span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，paths 的解析是基于 baseUrl 作为相对路径的，因此需要确保指定了 baseUrl 。在填写别名路径时，我们可以传入一个数组，TypeScript 会依次解析这些路径，直到找到一个确实存在的路径。</p><h4 id="resolveJsonModule"><a href="#resolveJsonModule" class="headerlink" title="resolveJsonModule"></a>resolveJsonModule</h4><p>启用了这一配置后，你就可以直接导入 Json 文件，并对导入内容获得完整的基于实际 Json 内容的类型推导。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"repo"</span><span class="token operator">:</span> <span class="token string">"TypeScript"</span><span class="token punctuation">,</span>    <span class="token property">"dry"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token property">"debug"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span>import settings from <span class="token string">"./settings.json"</span>;settings.debug === <span class="token boolean">true</span>;<span class="token comment">// 对应的类型报错</span>settings.dry === <span class="token number">2</span>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构建产物相关"><a href="#构建产物相关" class="headerlink" title="构建产物相关"></a>构建产物相关</h3><h4 id="构建输出相关"><a href="#构建输出相关" class="headerlink" title="构建输出相关"></a>构建输出相关</h4><h5 id="outDir-与-outFile"><a href="#outDir-与-outFile" class="headerlink" title="outDir 与 outFile"></a>outDir 与 outFile</h5><p>这两个选项决定了构建产物的输出文件。其中 outDir 配置的值将包括所有的构建产物，通常情况下会按照原本的目录结构存放：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">src├── core├──── handler.ts└── index.tsdist├── core├──── handler.js├──── handler.d.ts├── index.js├── index.d.tssrc├── core├──── handler.ts└── index.ts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而 outFile 类似于 Rollup 或 ESBuild 中的 bundle 选项，它会将所有的产物（其中非模块的文件）打包为单个文件，但仅能在 module 选项为 None / System / AMD 时使用。</p><h5 id="preserveConstEnums"><a href="#preserveConstEnums" class="headerlink" title="preserveConstEnums"></a>preserveConstEnums</h5><p>在字面量类型与枚举一节中了解过，常量枚举会在编译时被抹除，对其成员的引用会直接使用原本的值来替换。这一配置项可以改变此行为，让常量枚举也像普通枚举那样被编译为一个运行时存在的对象。</p><h5 id="noEmit-与-noEmitOnError"><a href="#noEmit-与-noEmitOnError" class="headerlink" title="noEmit 与 noEmitOnError"></a>noEmit 与 noEmitOnError</h5><p>这两个选项主要控制最终是否将构建产物实际写入文件系统中，其中 noEmit 开启时将不会写入，但仍然会执行构建过程，因此也就包括了类型检查、语法检查与实际构建过程。而 noEmitOnError 则仅会在构建过程中有错误产生才会阻止写入。</p><p>一个常见的实践是，使用 ESBuild / SWC 等工具进行实际构建，使用 <code>tsc --noEmit</code> 进行类型检查过程。</p><h5 id="module"><a href="#module" class="headerlink" title="module"></a>module</h5><p>这一配置控制最终 JavaScript 产物使用的模块标准，常见的包括 CommonJs、ES6、ESNext 以及 NodeNext 等（实际的值也可以是全小写的形式）。另外也支持 AMD、UMD、System 等模块标准。</p><p>TypeScript 会随着版本更新新增可用的 module 选项，如在 4.5 版本新增了 <code>es2022</code> 配置，支持了 Top-Level Await 语法。在 4.7 版本还新增了 <code>node16</code> 和 <code>nodenext</code> 两个 module 配置，使用这两个配置意味着你构建的 npm 包或者代码仅在 node 环境下运行，因此 TypeScript 会对应地启用对 Node ESM 的支持。</p><h5 id="importHelpers-与-noEmitHelpers"><a href="#importHelpers-与-noEmitHelpers" class="headerlink" title="importHelpers 与 noEmitHelpers"></a>importHelpers 与 noEmitHelpers</h5><p>由于 TypeScript 在编译时除了抹除类型，还需要基于 target 进行语法降级，这一功能往往需要一些辅助函数，将新语法转换为旧语法的实现， 如 async 函数。</p><p>在同样能实现语法降级的 Babel 中，这一功能是通过 core-js （原<code>@babel/polyfill</code>） 实现的。在 TypeScript 中这些辅助函数被统一封装在了 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ftslib">tslib</a> 中，通过启用 importHelpers 配置，这些辅助函数就将从 tslib 中导出而不是在源码中定义，能够有效地帮助减少构建产物体系。</p><p>举例来说，ES 6 中引入的 rest 操作符，在降低情况下会编译为这样的产物：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">arr</span><span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">...</span>arr<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> __read <span class="token operator">=</span>  <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__read<span class="token punctuation">)</span> <span class="token operator">||</span>  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">o<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span><span class="token keyword">var</span> __spreadArray <span class="token operator">=</span>  <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__spreadArray<span class="token punctuation">)</span> <span class="token operator">||</span>  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> pack</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token function">__spreadArray</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">__read</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在启用 importHelpers 后，辅助函数 <code>__read</code> 和 <code>__spreadArray</code> 都将从 tslib 中导出：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> __read<span class="token punctuation">,</span> __spreadArray <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'tslib'</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token function">__spreadArray</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">__read</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果你希望使用自己的实现，而非完全从 tslib 中导出，就可以使用 noEmitHelpers 配置，在开启时源码中仍然会使用这些辅助函数，不会存在从 tslib 中导入的过程。因此，此时需要你在全局命名空间下来提供同名的实现。</p><h5 id="downlevelIteration"><a href="#downlevelIteration" class="headerlink" title="downlevelIteration"></a>downlevelIteration</h5><p>ES6 新增了 <code>for...of</code> 循环，它可以用于循环遍历所有部署了 <code>[Symbol.iterator]</code> 接口的数据结构，如数组、Set、Map，甚至还包括字符串。</p><p>在默认情况下，如果 target 为 ES5 或更低，<code>for...of</code> 循环会被降级为普通的基于索引的 for 循环：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 源代码</span><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'Hello!'</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> s <span class="token keyword">of</span> str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 降级</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token string">'use strict'</span><span class="token punctuation">)</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'Hello!'</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> _i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> str_1 <span class="token operator">=</span> str<span class="token punctuation">;</span> _i <span class="token operator">&lt;</span> str_1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> _i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> s <span class="token operator">=</span> str_1<span class="token punctuation">[</span>_i<span class="token punctuation">]</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而在某些情况下，降级到普通的 for 循环可能造成运行结果不一致，比如一个 emoji 字符在 <code>for...of</code> 循环中只会被遍历一次，而其实际 length 为 2，因此在 for 循环中会被拆开来分别遍历 2 次。</p><p>这种情况下我们的预期应当是仍然保留为 <code>for...of</code> 循环，此时就可以启用 downlevelIteration 配置，同时在运行环境中确保 <code>[Symbol.iterator]</code> 接口的存在（如通过 polyfill），这样就可以保留 <code>for...of</code> 循环的实现。</p><p>需要注意的是，启用这一配置只是意味着 TS 会在构建产物中引入辅助函数，判断在 <code>[Symbol.iterator]</code> 接口存在时保留 <code>for...of</code> 循环，否则降级为普通的基于索引的 for 循环，因此你仍然需要自己引入 polyfill。</p><h5 id="importsNotUsedAsValues-与-preserveValueImports"><a href="#importsNotUsedAsValues-与-preserveValueImports" class="headerlink" title="importsNotUsedAsValues 与 preserveValueImports"></a>importsNotUsedAsValues 与 preserveValueImports</h5><p>默认情况下，TypeScript 就在编译时去抹除仅类型导入（import type），但如果你希望保留这些类型导入语句，可以通过更改 importsNotUsedAsValues 配置的值来改变其行为。默认情况下，此配置的值为 remove，即对仅类型导入进行抹除。你也可以将其更改为 preserve，这样所有的导入语句都会被导入（但是类型变量仍然会被抹除）。或者是 error，在这种情况下首先所有导入语句仍然会被保留，但会在值导入仅被用于类型时产生一个错误。</p><p>举例来说，以下代码中的仅类型导入会在 preserve 或 error 时保留：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// foo.ts</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">FooType</span> <span class="token operator">=</span> <span class="token builtin">any</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// index.ts</span><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> FooType <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./foo'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./foo'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样 foo 文件中的 <code>init()</code>也就是副作用，仍然能够得到执行。</p><p>类似的，还有一个控制导入语句构建产物的配置，preserveValueImports。它主要针对的是值导入（即非类型导入或混合导入），这是因为在某些时候我们的值导入可能是通过一些奇怪的方式使用的：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Animal <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./animal'</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">'console.log(new Animal().isDangerous())'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>preserveValueImports 配置会将所有的值导入都保留下来，</p><p>如果你使用 Babel 等无法处理类型的编译器来构建 TS 代码（即启用了 isolatedModules 配置），由于它们并不知道这里到底是值导入还是类型导入，所以此时你必须将类型导入显式标记出来：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Animal<span class="token punctuation">,</span> <span class="token keyword">type</span> <span class="token class-name">AnimalKind</span> <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> "<span class="token punctuation">.</span><span class="token operator">/</span>animal<span class="token punctuation">;</span><span class="token comment">// 或使用两条导入</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Animal <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> "<span class="token punctuation">.</span><span class="token operator">/</span>animal<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> AnimalKind <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> "<span class="token punctuation">.</span><span class="token operator">/</span>animal<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当你同时启用了 <code>isolatedModules</code> 与 <code>preserveValueImports</code> 配置时，编辑器会严格约束你必须这么做。</p><h4 id="声明文件相关"><a href="#声明文件相关" class="headerlink" title="声明文件相关"></a>声明文件相关</h4><h5 id="declaration、declarationDir"><a href="#declaration、declarationDir" class="headerlink" title="declaration、declarationDir"></a>declaration、declarationDir</h5><p>这两个选项主要控制声明文件的输出，其中 declaration 接受一个布尔值，即是否产生声明文件。而 declarationDir 控制写入声明文件的路径，默认情况下声明文件会和构建代码文件在一个位置，比如 <code>src/index.ts</code> 会构建出 <code>dist/index.js</code> 与 <code>dist/index.d.ts</code>，但使用 declarationDir 你可以将这些类型声明文件输出到一个独立的文件夹下，如 <code>dist/types/index.d.ts</code> <code>dist/types/utils.d.ts</code> 这样。</p><h5 id="declarationMap"><a href="#declarationMap" class="headerlink" title="declarationMap"></a>declarationMap</h5><p>declarationMap 选项会为声明文件也生成 source map，这样你就可以从 <code>.d.ts</code> 直接映射回原本的 <code>.ts</code> 文件了。</p><p>在使用第三方库时，如果你点击一个来自第三方库的变量，会发现跳转的是其声明文件。如果这些库提供了 declarationMap 与原本的 .ts 文件，那就可以直接跳转到变量对应的原始 ts 文件。当然一般发布 npm 包时并不会携带这些文件，但在 Monorepo 等场景下却有着奇效。</p><h5 id="emitDeclarationOnly"><a href="#emitDeclarationOnly" class="headerlink" title="emitDeclarationOnly"></a>emitDeclarationOnly</h5><p>此配置会让最终构建结果只包含构建出的声明文件（<code>.d.ts</code>），而不会包含 <code>.js</code> 文件。类似于 noEmit 选项，你可以使用其他构建器比如 swc 来构建代码文件，而只使用 tsc 来生成类型文件。</p><h4 id="Source-Map-相关"><a href="#Source-Map-相关" class="headerlink" title="Source Map 相关"></a>Source Map 相关</h4><p>以下配置均和 Source Map 有关，我们就放在一起介绍了。</p><ul><li>sourceMap 与 inlineSourceMap 有些类似于 Webpack 中的 devtool 配置，控制是生成 <code>.map.js</code> 这样独立的 source map 文件，还是直接将其附加在生成的 <code>.js</code> 文件中。这两个选项当然是互斥的。</li><li>inlineSources 这一选项类似于 source map，只不过它是映射到原本的 .ts 文件，也就是你可以从压缩过的代码直接定位到原本的 .ts 文件。</li><li>sourceRoot 与 mapRoot，这两个选项通常供 debugger 消费，分别用于定义我们的源文件与 source map 文件的根目录。</li></ul><h3 id="构建产物代码格式化配置"><a href="#构建产物代码格式化配置" class="headerlink" title="构建产物代码格式化配置"></a>构建产物代码格式化配置</h3><p>以下选项主要控制产物代码中的代码格式化，或者说代码风格相关，我们就放在一起介绍了。</p><ul><li><p>newLine，指定文件的结尾使用 CRLF 还是 LF 换行风格。其中 CRLF 其实就是 Carriage Return Line Feed ，是 Windows（DOS）系统下的换行符（相当于 <code>\r\n</code>），而 LF 则是 Line Feed，为 Unix 下的换行符（相当于 <code>\n</code>）。</p></li><li><p>removeComments，移除所有 TS 文件的注释，默认启用。</p></li><li><p>stripInternal 这一选项会阻止为被标记为 internal 的代码语句生成对应的类型，即被 JSDoc 标记为 <code>@internal</code>。推荐的做法是为仅在内部使用而没有导出的变量或方法进行标记，来减少生成代码的体积。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">/** * @internal */</span><span class="token keyword">const</span> <span class="token constant">SECRET_KEY</span> <span class="token operator">=</span> <span class="token string">'LINBUDU'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以上这段代码不会生成对应的类型声明。</p></li></ul><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>这一节我们介绍了构建相关的配置，其中主要的概念包括如何配置你的输入与输出，以及如何启用特殊的语法等。这些配置通常通常不会频繁发生变化（除了 lib 可能会需要动态调整），而是在有特殊的需要时再对应地进行配置。</p><p>在下一节，我们会介绍检查相关与工程相关的配置项，其中检查部分包括了类型检查、逻辑检查等，而工程配置则包括了一系列兼容性与工程能力的配置。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.进入类型的世界：理解原始类型与对象类型</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/3.%E8%BF%9B%E5%85%A5%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%96%E7%95%8C%EF%BC%9A%E7%90%86%E8%A7%A3%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/3.%E8%BF%9B%E5%85%A5%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%96%E7%95%8C%EF%BC%9A%E7%90%86%E8%A7%A3%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>通常来说，学习一件新事物的较好方式是和你已掌握的做对比，通过二者之间通用的概念帮你快速熟悉新的事物。比如，在掌握了 Vue 以后再去学习 React，对于组件通信、状态管理、插槽等这些二者共有的概念，你会感到非常熟悉。同样的，这一章我们会从 JavaScript 的既有概念开始学习，详细讲解 TypeScript 所有原始类型、数组以及对象的类型标注，让你能快速对 TypeScript 的功能、语法有一个基础认知。</p><p>这一章会包含几乎所有与原始类型、对象类型、数组等强相关的知识点，这么设计主要是因为它们之间的内容环环相扣，而且也不难，放在一起能帮助你一次性建立<strong>相对完整的知识体系</strong>。</p><p>如果你已经对这一章的知识点有基本了解或者非常熟悉了，那我建议你利用它来查缺补漏，为后面的学习打好基础，比如元组就是一个很容易被大家忽视的知识点。</p><p>话不多说，跟着我一起往下看吧！</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F01-primitive-and-object">Primitive and Object</a></p></blockquote><h2 id="原始类型的类型标注"><a href="#原始类型的类型标注" class="headerlink" title="原始类型的类型标注"></a>原始类型的类型标注</h2><p>首先，我们来看 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FData_structures%23%E5%8E%9F%E5%A7%8B%E5%80%BC_primitive_values">JavaScript 的内置原始类型</a>。除了最常见的 number / string / boolean / null / undefined， ECMAScript 2015（ES6）、2020 (ES11) 又分别引入了 2 个新的原始类型：symbol 与 bigint 。在 TypeScript 中它们都有对应的类型注解：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span><span class="token keyword">const</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">24</span><span class="token keyword">const</span> male<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token keyword">const</span> undef<span class="token operator">:</span> <span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token keyword">const</span> nul<span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token keyword">const</span> obj<span class="token operator">:</span> object <span class="token operator">=</span> <span class="token punctuation">&#123;</span> name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> male <span class="token punctuation">&#125;</span><span class="token keyword">const</span> bigintVar1<span class="token operator">:</span> bigint <span class="token operator">=</span> <span class="token number">9007199254740991n</span><span class="token keyword">const</span> bigintVar2<span class="token operator">:</span> bigint <span class="token operator">=</span> <span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token number">9007199254740991</span><span class="token punctuation">)</span><span class="token keyword">const</span> symbolVar<span class="token operator">:</span> <span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'unique'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，除了 null 与 undefined 以外，余下的类型基本上可以完全对应到 JavaScript 中的数据类型概念，因此这里我们只对 null 与 undefined 展开介绍。</p><h3 id="null-与-undefined"><a href="#null-与-undefined" class="headerlink" title="null 与 undefined"></a>null 与 undefined</h3><p>在 JavaScript 中，null 与 undefined 分别表示“<strong>这里有值，但是个空值</strong>”和“<strong>这里没有值</strong>”。而在 TypeScript 中，null 与 undefined 类型都是<strong>有具体意义的类型</strong>。也就是说，它们作为类型时，表示的是一个有意义的具体类型值。这两者在没有开启 <code>strictNullChecks</code> 检查的情况下，会<strong>被视作其他类型的子类型</strong>，比如 string 类型会被认为包含了 null 与 undefined 类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> tmp1<span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token keyword">const</span> tmp2<span class="token operator">:</span> <span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token keyword">const</span> tmp3<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 仅在关闭 strictNullChecks 时成立，下同</span><span class="token keyword">const</span> tmp4<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了上面介绍的原始类型以及 null、undefined 类型以外，在 TypeScript 中还存在着一个特殊的类型：void，它和 JavaScript 中的 void 同样不是一回事，我们接着往下看。</p><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>你是否看到过以下的 JavaScript 代码呢？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"javascript:void(0)"</span><span class="token operator">></span>清除缓存<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的 <code>void(0)</code> 等价于 <code>void 0</code>，即 <code>void expression</code> 的语法。void 操作符会执行后面跟着的表达式并返回一个 undefined，如你可以使用它来执行一个立即执行函数（IIFE）：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">iife</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Invoked!'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>能这么做是因为，void 操作符强制<strong>将后面的函数声明转化为了表达式</strong>，因此整体其实相当于：<code>void((function iife()&#123;&#125;)())</code>。</p><p>事实上，TypeScript 的原始类型标注中也有 void，但与 JavaScript 中不同的是，这里的 void 用于描述一个内部没有 return 语句，或者没有显式 return 一个值的函数的返回值，如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">undefined</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，func1 与 func2 的返回值类型都会被隐式推导为 void，只有显式返回了 undefined 值的 func3 其返回值类型才被推导为了 undefined。但在实际的代码执行中，func1 与 func2 的返回值均是 undefined。</p><blockquote><p>虽然 func3 的返回值类型会被推导为 undefined，但是你仍然可以使用 void 类型进行标注，因为在类型层面 func1、func2、func3 都表示“没有返回一个有意义的值”。</p></blockquote><p>这里可能有点绕，你可以认为 void 表示一个空类型，而 null 与 undefined 都是一个具有意义的实际类型（注意与它们在 JavaScript 中的意义区分）。而 undefined 能够被赋值给 void 类型的变量，就像在 JavaScript 中一个没有返回值的函数会默认返回一个 undefined 。null 类型也可以，但需要在关闭 <code>strictNullChecks</code> 配置的情况下才能成立。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> voidVar1<span class="token operator">:</span> <span class="token keyword">void</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token keyword">const</span> voidVar2<span class="token operator">:</span> <span class="token keyword">void</span> <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 需要关闭 strictNullChecks</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>到这里，我们了解了 JavaScript 中原始数据类型到 TypeScript 原始类型概念地映射，你应当能感觉到 TypeScript 对 JavaScript 开发者的友好，大部分概念都能比较自然地过渡，下面的数组与对象的类型标注同样如此。</p><h2 id="数组的类型标注"><a href="#数组的类型标注" class="headerlink" title="数组的类型标注"></a>数组的类型标注</h2><p>数组同样是我们最常用的类型之一，在 TypeScript 中有两种方式来声明一个数组类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> arr1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">const</span> arr2<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这两种方式是完全等价的，但其实更多是以前者为主，如果你将鼠标悬浮在 <code>arr2</code> 上，会发现它显示的类型签名是 <code>string[]</code>。数组是我们在日常开发大量使用的数据结构，但在某些情况下，使用 <strong>元组（Tuple）</strong> 来代替数组要更加妥当，比如一个数组中只存放固定长度的变量，但我们进行了超出长度地访问：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> arr3<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'lin'</span><span class="token punctuation">,</span> <span class="token string">'bu'</span><span class="token punctuation">,</span> <span class="token string">'du'</span><span class="token punctuation">]</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr3<span class="token punctuation">[</span><span class="token number">599</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这种情况肯定是不符合预期的，因为我们能确定这个数组中只有三个成员，并希望在越界访问时给出类型报错。这时我们可以使用元组类型进行类型标注：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> arr4<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'lin'</span><span class="token punctuation">,</span> <span class="token string">'bu'</span><span class="token punctuation">,</span> <span class="token string">'du'</span><span class="token punctuation">]</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr4<span class="token punctuation">[</span><span class="token number">599</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时将会产生一个类型错误：<strong><em>长度为“3”的元组类型“[string, string, string]”在索引“599“处没有元素</em></strong>。除了同类型的元素以外，元组内部也可以声明多个与其位置强绑定的，不同类型的元素：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> arr5<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">boolean</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token number">599</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这种情况下，对数组合法边界内的索引访问（即 0、1、2）将精确地获得对应位置上的类型。同时元组也支持了在某一个位置上的可选成员：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> arr6<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token builtin">boolean</span><span class="token operator">?</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'linbudu'</span><span class="token punctuation">]</span><span class="token comment">// 下面这么写也可以</span><span class="token comment">// const arr6: [string, number?, boolean?] = ['linbudu', , ,];</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对于标记为可选的成员，在 <code>--strictNullCheckes</code> 配置下会被视为一个 <code>string | undefined</code> 的类型。此时元组的长度属性也会发生变化，比如上面的元组 arr6 ，其长度的类型为 <code>1 | 2 | 3</code>：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">TupleLength</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> arr6<span class="token punctuation">.</span>length <span class="token comment">// 1 | 2 | 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也就是说，这个元组的长度可能为 1、2、3。</p><blockquote><p>关于类型别名（type）、类型查询（typeof）以及联合类型，我们会在后面讲到，这里你只需要简单了解即可。</p></blockquote><p>你可能会觉得，元组的可读性实际上并不好。比如对于 <code>[string, number, boolean]</code>来说，你并不能直接知道这三个元素都代表什么，还不如使用对象的形式。而在 TypeScript 4.0 中，有了具名元组（<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FMicrosoft%2FTypeScript%2Fissues%2F28259">Labeled Tuple Elements</a>）的支持，使得我们可以为元组中的元素打上类似属性的标记：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> arr7<span class="token operator">:</span> <span class="token punctuation">[</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> male<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token number">599</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有没有很酷？考虑到某些拼装对象太麻烦，我们完全可以使用具名元组来做简单替换。具名元组可选元素的修饰符将成为以下形式：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> arr7<span class="token operator">:</span> <span class="token punctuation">[</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> male<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token number">599</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实际上除了显式地越界访问，还可能存在隐式地越界访问，如通过解构赋值的形式：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> arr1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">const</span> <span class="token punctuation">[</span>ele1<span class="token punctuation">,</span> ele2<span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token punctuation">]</span> <span class="token operator">=</span> arr1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对于数组，此时仍然无法检查出是否存在隐式访问，因为类型层面并不知道它到底有多少个元素。但对于元组，隐式的越界访问也能够被揪出来给一个警告：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> arr5<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">boolean</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token number">599</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">]</span><span class="token comment">// 长度为 "3" 的元组类型 "[string, number, boolean]" 在索引 "3" 处没有元素。</span><span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> male<span class="token punctuation">,</span> other<span class="token punctuation">]</span> <span class="token operator">=</span> arr5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>JavaScript 的开发者对元组 Tuple 的概念可能比较陌生，毕竟在 JavaScript 中我们很少声明定长的数组。但使用元组确实能帮助我们进一步提升<strong>数组结构的严谨性</strong>，包括基于位置的类型标注、避免出现越界访问等等。除了通过数组类型提升数组结构的严谨性，TypeScript 中的对象类型也能帮助我们提升对象结构的严谨性。接下来我们就一起来看看。</p><h2 id="对象的类型标注"><a href="#对象的类型标注" class="headerlink" title="对象的类型标注"></a>对象的类型标注</h2><p>作为 JavaScript 中使用最频繁的数据结构，对象的类型标注是我们本节要重点关注的部分。接下来我们会学习如何在 TypeScript 中声明对象、修饰对象属性，以及了解可能存在的使用误区。这些内容能够帮助你建立起对 TypeScript 中立体类型（我们可以理解为前面的原始类型是“<strong>平面类型</strong>”）的了解，正式入门 TypeScript 。</p><p>类似于数组类型，在 TypeScript 中我们也需要特殊的类型标注来描述对象类型，即 interface ，你可以理解为它代表了这个对象对外提供的接口结构。</p><p>首先我们使用 interface 声明一个结构，然后使用这个结构来作为一个对象的类型标注即可：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">IDescription</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  age<span class="token operator">:</span> <span class="token builtin">number</span>  male<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> obj1<span class="token operator">:</span> IDescription <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token string">'linbudu'</span><span class="token punctuation">,</span>  age<span class="token operator">:</span> <span class="token number">599</span><span class="token punctuation">,</span>  male<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的“描述”指：</p><ul><li>每一个属性的值必须<strong>一一对应</strong>到接口的属性类型</li><li>不能有多的属性，也不能有少的属性，包括直接在对象内部声明，或是 <code>obj1.other = &#39;xxx&#39;</code> 这样属性访问赋值的形式</li></ul><p>除了声明属性以及属性的类型以外，我们还可以对属性进行修饰，常见的修饰包括<strong>可选（Optional）</strong> 与 <strong>只读（Readonly）</strong> 这两种。</p><h3 id="修饰接口属性"><a href="#修饰接口属性" class="headerlink" title="修饰接口属性"></a>修饰接口属性</h3><p>类似于上面的元组可选，在接口结构中同样通过 <code>?</code> 来标记一个属性为可选：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">IDescription</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  age<span class="token operator">:</span> <span class="token builtin">number</span>  male<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span>  func<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">Function</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> obj2<span class="token operator">:</span> IDescription <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token string">'linbudu'</span><span class="token punctuation">,</span>  age<span class="token operator">:</span> <span class="token number">599</span><span class="token punctuation">,</span>  male<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token comment">// 无需实现 func 也是合法的</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下，即使你在 obj2 中定义了 male 属性，但当你访问 <code>obj2.male</code> 时，它的类型仍然会是 <code>boolean | undefined</code>，因为毕竟这是我们自己定义的类型嘛。</p><p>假设新增一个可选的函数类型属性，然后进行调用：<code>obj2.func()</code> ，此时将会产生一个类型报错：<strong><em>不能调用可能是未定义的方法</em></strong>。但可选属性标记不会影响你对这个属性进行赋值，如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">obj2<span class="token punctuation">.</span>male <span class="token operator">=</span> <span class="token boolean">false</span>obj2<span class="token punctuation">.</span><span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>即使你对可选属性进行了赋值，TypeScript 仍然会使用<strong>接口的描述为准</strong>进行类型检查，你可以使用类型断言、非空断言或可选链解决（别急，我们在后面会讲到）。</p><p>除了标记一个属性为可选以外，你还可以标记这个属性为只读：<code>readonly</code>。很多同学对这一关键字比较陌生，因为以往 JavaScript 中并没有这一类概念，它的作用是<strong>防止对象的属性被再次赋值</strong>。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">IDescription</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">readonly</span> name<span class="token operator">:</span> <span class="token builtin">string</span>  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> obj3<span class="token operator">:</span> IDescription <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token string">'linbudu'</span><span class="token punctuation">,</span>  age<span class="token operator">:</span> <span class="token number">599</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token comment">// 无法分配到 "name" ，因为它是只读属性</span>obj3<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'林不渡'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实在数组与元组层面也有着只读的修饰，但与对象类型有着两处不同。</p><ul><li>你只能将整个数组/元组标记为只读，而不能像对象那样标记某个属性为只读。</li><li>一旦被标记为只读，那这个只读数组/元组的类型上，将不再具有 push、pop 等方法（即会修改原数组的方法），因此报错信息也将是<strong>类型 xxx 上不存在属性“push”这种</strong>。这一实现的本质是<strong>只读数组与只读元组的类型实际上变成了 ReadonlyArray，而不再是 Array。</strong></li></ul><h3 id="type-与-interface"><a href="#type-与-interface" class="headerlink" title="type 与 interface"></a>type 与 interface</h3><p>我也知道，很多同学更喜欢用 type（Type Alias，类型别名）来代替接口结构描述对象，而我更推荐的方式是，interface 用来描述<strong>对象、类的结构</strong>，而类型别名用来<strong>将一个函数签名、一组联合类型、一个工具类型等等抽离成一个完整独立的类型</strong>。但大部分场景下接口结构都可以被类型别名所取代，因此，只要你觉得统一使用类型别名让你觉得更整齐，也没什么问题。</p><h3 id="object、Object-以及"><a href="#object、Object-以及" class="headerlink" title="object、Object 以及 { }"></a>object、Object 以及 { }</h3><p><code>object</code>、<code>Object</code> 以及<code>&#123;&#125;</code>（一个空对象）这三者的使用可能也会让部分同学感到困惑，所以我也专门解释下。</p><p>首先是 Object 的使用。被 JavaScript 原型链折磨过的同学应该记得，原型链的顶端是 Object 以及 Function，这也就意味着所有的原始类型与对象类型最终都指向 Object，在 TypeScript 中就表现为 Object 包含了所有的类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 对于 undefined、null、void 0 ，需要关闭 strictNullChecks</span><span class="token keyword">const</span> tmp1<span class="token operator">:</span> Object <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token keyword">const</span> tmp2<span class="token operator">:</span> Object <span class="token operator">=</span> <span class="token keyword">null</span><span class="token keyword">const</span> tmp3<span class="token operator">:</span> Object <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token keyword">const</span> tmp4<span class="token operator">:</span> Object <span class="token operator">=</span> <span class="token string">'linbudu'</span><span class="token keyword">const</span> tmp5<span class="token operator">:</span> Object <span class="token operator">=</span> <span class="token number">599</span><span class="token keyword">const</span> tmp6<span class="token operator">:</span> Object <span class="token operator">=</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'linbudu'</span> <span class="token punctuation">&#125;</span><span class="token keyword">const</span> tmp7<span class="token operator">:</span> <span class="token function-variable function">Object</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> tmp8<span class="token operator">:</span> Object <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和 Object 类似的还有 Boolean、Number、String、Symbol，这几个<strong>装箱类型（Boxed Types）</strong> 同样包含了一些超出预期的类型。以 String 为例，它同样包括 undefined、null、void，以及代表的 <strong>拆箱类型（Unboxed Types）</strong> string，但并不包括其他装箱类型对应的拆箱类型，如 boolean 与 基本对象类型，我们看以下的代码：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> tmp9<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token keyword">const</span> tmp10<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token keyword">null</span><span class="token keyword">const</span> tmp11<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token keyword">const</span> tmp12<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string">'linbudu'</span><span class="token comment">// 以下不成立，因为不是字符串类型的拆箱类型</span><span class="token keyword">const</span> tmp13<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token number">599</span> <span class="token comment">// X</span><span class="token keyword">const</span> tmp14<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'linbudu'</span> <span class="token punctuation">&#125;</span> <span class="token comment">// X</span><span class="token keyword">const</span> tmp15<span class="token operator">:</span> <span class="token function-variable function">String</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// X</span><span class="token keyword">const</span> tmp16<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// X</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在任何情况下，你都不应该使用这些装箱类型。</strong></p><p>object 的引入就是为了解决对 Object 类型的错误使用，它代表<strong>所有非原始类型的类型，即数组、对象与函数类型这些</strong>：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> tmp17<span class="token operator">:</span> object <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token keyword">const</span> tmp18<span class="token operator">:</span> object <span class="token operator">=</span> <span class="token keyword">null</span><span class="token keyword">const</span> tmp19<span class="token operator">:</span> object <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token keyword">const</span> tmp20<span class="token operator">:</span> object <span class="token operator">=</span> <span class="token string">'linbudu'</span> <span class="token comment">// X 不成立，值为原始类型</span><span class="token keyword">const</span> tmp21<span class="token operator">:</span> object <span class="token operator">=</span> <span class="token number">599</span> <span class="token comment">// X 不成立，值为原始类型</span><span class="token keyword">const</span> tmp22<span class="token operator">:</span> object <span class="token operator">=</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'linbudu'</span> <span class="token punctuation">&#125;</span><span class="token keyword">const</span> tmp23<span class="token operator">:</span> <span class="token function-variable function">object</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> tmp24<span class="token operator">:</span> object <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后是<code>&#123;&#125;</code>，一个奇奇怪怪的空对象，如果你了解过字面量类型，可以认为<code>&#123;&#125;</code>就是一个对象字面量类型（对应到字符串字面量类型这样）。否则，你可以认为使用<code>&#123;&#125;</code>作为类型签名就是一个合法的，但<strong>内部无属性定义的空对象</strong>，这类似于 Object（想想 <code>new Object()</code>），它意味着任何非 null / undefined 的值：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> tmp25<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token keyword">undefined</span> <span class="token comment">// 仅在关闭 strictNullChecks 时成立，下同</span><span class="token keyword">const</span> tmp26<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token keyword">const</span> tmp27<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token number">0</span> <span class="token comment">// void 0 等价于 undefined</span><span class="token keyword">const</span> tmp28<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span><span class="token keyword">const</span> tmp29<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token number">599</span><span class="token keyword">const</span> tmp30<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'linbudu'</span> <span class="token punctuation">&#125;</span><span class="token keyword">const</span> tmp31<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> tmp32<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然能够将其作为变量的类型，但你实际上<strong>无法对这个变量进行任何赋值操作</strong>：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> tmp30<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'linbudu'</span> <span class="token punctuation">&#125;</span>tmp30<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span> <span class="token comment">// X 类型“&#123;&#125;”上不存在属性“age”。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是因为它就是纯洁的像一张白纸一样的空对象，上面没有任何的属性（除了 toString 这种与生俱来的）。在类型层级一节我们还会再次见到它，不过那个时候它已经被称为“万物的起源”了。</p><p>最后，为了更好地区分 <code>Object</code>、<code>object</code> 以及<code>&#123;&#125;</code>这三个具有迷惑性的类型，我们再做下总结：</p><ul><li>在任何时候都<strong>不要，不要，不要使用</strong> Object 以及类似的装箱类型。</li><li>当你不确定某个变量的具体类型，但能确定它不是原始类型，可以使用 object。但我更推荐进一步区分，也就是使用 <code>Record&lt;string, unknown&gt;</code> 或 <code>Record&lt;string, any&gt;</code> 表示对象，<code>unknown[]</code> 或 <code>any[]</code> 表示数组，<code>(...args: any[]) =&gt; any</code>表示函数这样。</li><li>我们同样要避免使用<code>&#123;&#125;</code>。<code>&#123;&#125;</code>意味着任何非 <code>null / undefined</code> 的值，从这个层面上看，使用它和使用 <code>any</code> 一样恶劣。</li></ul><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>这一节，我们一起学习了 TypeScript 中原始类型、对象类型、数组（元组）的类型标注，以及对数组的只读、对象类型属性的访问性修饰。这里的知识其实可以分为两类：</p><ul><li>与 JavaScript 概念基本一致的部分，如原始类型与数组类型需要重点掌握，但因为思维方式基本没有变化，所以你可以认为你就是在写<strong>更严格一些的 JavaScript</strong>。</li><li>一些全新的概念，比如元组与 readonly 修饰等，这一部分你可能不会很快适应，需要稍微转换一下思维方式。我建议你可以从现在开始，有意识地在日常开发中去多多使用它们。</li></ul><p>另外，对于 readonly 这一修饰符，JavaScript 开发者可能需要一定的时间来理解和习惯，但它在工程层面确实是非常推荐的一种实践，可以使用只读标记来避免数组和对象被错误修改。当然，TypeScript 目前只能够帮助你在编译时做检查，类型信息在编译后都会被擦除，所以 readonly 并不会在实际运行时报错。</p><p>学习完这一小节后，不妨找出你曾经的 JavaScript 项目，试试用本章学到的知识为这些 JavaScript 代码添加一些类型，再把某些场景下的数组换成元组，为部分对象类型的属性添加 readonly，来感受 TypeScript 代码的严格之美。</p><p>在下一节我们要介绍的字面量类型以及枚举，在某些方面其实可以理解为是原始类型与对象类型的进一步延伸，也同样是日常会被重度使用的语法。在完成下一节的学习后，你就可以开始进一步地改造你的 JavaScript 项目，让那些类型变得更精确一些！</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="unique-symbol"><a href="#unique-symbol" class="headerlink" title="unique symbol"></a>unique symbol</h3><p>Symbol 在 JavaScript 中代表着一个唯一的值类型，它类似于字符串类型，可以作为对象的属性名，并用于避免错误修改 对象 / Class 内部属性的情况。而在 TypeScript 中，symbol 类型并不具有这一特性，一百个具有 symbol 类型的对象，它们的 symbol 类型指的都是 TypeScript 中的同一个类型。为了实现“独一无二”这个特性，TypeScript 中支持了 unique symbol 这一类型声明，它是 symbol 类型的子类型，每一个 unique symbol 类型都是独一无二的。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> uniqueSymbolFoo<span class="token operator">:</span> unique <span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">)</span><span class="token comment">// 类型不兼容</span><span class="token keyword">const</span> uniqueSymbolBar<span class="token operator">:</span> unique <span class="token builtin">symbol</span> <span class="token operator">=</span> uniqueSymbolFoo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 JavaScript 中，我们可以用 <code>Symbol.for</code> 方法来复用已创建的 Symbol，如 <code>Symbol.for(&quot;linbudu&quot;)</code> 会首先查找全局是否已经有使用 <code>linbudu</code> 作为 key 的 Symbol 注册，如果有，则返回这个 Symbol，否则才会创建新的 Symbol 。</p><p>在 TypeScript 中，如果要引用已创建的 unique symbol 类型，则需要使用类型查询操作符 typeof ：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">const</span> uniqueSymbolFoo<span class="token operator">:</span> unique <span class="token builtin">symbol</span><span class="token keyword">const</span> uniqueSymbolBaz<span class="token operator">:</span> <span class="token keyword">typeof</span> uniqueSymbolFoo <span class="token operator">=</span> uniqueSymbolFoo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>这里的 declare、typeof 等使用，都会在后面有详细地讲解。同时 unique symbol 在日常开发的使用非常少见，这里做了解就好~</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>28.TSConfig 全解（下）：检查相关、工程相关配置</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/28.TSConfig%20%E5%85%A8%E8%A7%A3%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E6%A3%80%E6%9F%A5%E7%9B%B8%E5%85%B3%E3%80%81%E5%B7%A5%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/28.TSConfig%20%E5%85%A8%E8%A7%A3%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E6%A3%80%E6%9F%A5%E7%9B%B8%E5%85%B3%E3%80%81%E5%B7%A5%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>上一节我们介绍了构建相关的 TSConfig 配置，包括源码相关、解析相关、产物相关等几个部分，这一节我们会接着来介绍类型检查与工程相关的 TSConfig。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F22-project-references%2F">Project References</a></p></blockquote><h2 id="检查相关"><a href="#检查相关" class="headerlink" title="检查相关"></a>检查相关</h2><p>这部分的配置主要控制对源码中语法与类型检查的严格程度，这也是导致 TypeScript 项目下限与上限差异巨大的主要原因，检查全开与全关下的 TypeScript 简直就是两门不同的语言。但并不是说检查越严格越好，更好的方式是依据实际需要来调整检查的严格程度，比如小小 demo 就不需要太严格检查啦。</p><p>对于推荐使用的配置，我也会在介绍时指出。</p><h3 id="允许类"><a href="#允许类" class="headerlink" title="允许类"></a>允许类</h3><p>这一部分的配置关注的语法通常是有害的，且默认情况下为禁用或者给出警告，因此需要显式通过配置来允许这些有害语法，它们的名称均为 allowXXX 这种形式。</p><h4 id="allowUmdGlobalAccess"><a href="#allowUmdGlobalAccess" class="headerlink" title="allowUmdGlobalAccess"></a>allowUmdGlobalAccess</h4><p>这一配置会允许你直接使用 UMD 格式的模块而不需要先导入，比如你通过 CDN 引入或是任何方式来确保全局一定会有这个变量。而 UMD 格式其实就是通用模块规范，兼容了 AMD 与 CommonJs（通过判断当前环境下哪种规范可用就使用哪种规范），示例如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 源码</span><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// UMD 编译结果</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">global<span class="token punctuation">,</span> factory</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 尝试使用 CommonJs</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> module <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> module<span class="token punctuation">.</span>exports <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> v <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span>require<span class="token punctuation">,</span> exports<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> module<span class="token punctuation">.</span>exports <span class="token operator">=</span> v  <span class="token punctuation">&#125;</span>  <span class="token comment">// 尝试使用 AMD</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> define <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">&amp;&amp;</span> define<span class="token punctuation">.</span>amd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'require'</span><span class="token punctuation">,</span> <span class="token string">'exports'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> factory<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 兜底，使用全局变量挂载</span>  <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">;</span><span class="token punctuation">(</span>global <span class="token operator">=</span> global <span class="token operator">||</span> self<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>global<span class="token punctuation">.</span>handle <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span> exports</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token string">'use strict'</span>  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>exports<span class="token punctuation">,</span> <span class="token string">'__esModule'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  exports<span class="token punctuation">.</span>handler <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token number">0</span>  <span class="token keyword">const</span> <span class="token function-variable function">handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  exports<span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，它依次判断了 CommonJS 与 AMD 的情况，并最后使用了全局变量来进行兜底。因此你既可以导入它来使用，也可以直接在全局访问它。</p><h4 id="allowUnreachableCode"><a href="#allowUnreachableCode" class="headerlink" title="allowUnreachableCode"></a>allowUnreachableCode</h4><p>Unreachable Code 通常指的是无法执行到的代码，也称 Dead Code，常见的 Unreachable Code 包括 return 语句、throw 语句以及 <code>process.exit</code> 后的代码：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token number">599</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Dead Code'</span><span class="token punctuation">)</span> <span class="token comment">// Dead Code</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Oops!'</span><span class="token punctuation">)</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Dead Code'</span><span class="token punctuation">)</span> <span class="token comment">// Dead Code</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>allowUnreachableCode 配置的默认值为 undefined，表现为在编译过程中并不会抛出阻止过程的错误，而只是一个警告。它也可以配置为 true（完全允许）与 false （抛出一个错误）。</p><h4 id="allowUnusedLabels"><a href="#allowUnusedLabels" class="headerlink" title="allowUnusedLabels"></a>allowUnusedLabels</h4><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Flabel">Label</a> 并不是我们经常会接触的概念，它的语法大致是这样：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">someLabel</span><span class="token operator">:</span> statement<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>statement 语句会被标记为 someLabel ，然后在别的地方你就可以用 someLabel 来引用这段语句。如标记一个函数（非严格模式下）：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function-variable function">L</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果在一个代码块中使用 label ，效果和对象字面量非常相似：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>  <span class="token function-variable function">L</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>为了区分 label 与对象字面量，这条规则禁止了声明但没有被实际使用的 label 标记：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">verifyAge</span><span class="token punctuation">(</span>age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>age <span class="token operator">></span> <span class="token number">18</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Unused label.</span>    verified<span class="token operator">:</span> <span class="token boolean">true</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码实际上想返回一个对象字面量，但却忘记了 return ，导致这里错误地声明了一个 Label。</p><p>类似于 allowUnreachableCode，这条配置也可使用 undefined（默认）、true、false 三个值，且效果也一致。</p><h3 id="禁止类"><a href="#禁止类" class="headerlink" title="禁止类"></a>禁止类</h3><p>这部分配置的关注点其实除了类型，也包括实际的代码逻辑，它们主要关注未被妥善处理的逻辑代码与无类型信息（手动标注与自动推导均无）的部分。另外，部分代码逻辑检查实际上 ESLint 也可以提供。</p><p>这部分配置的值通常只有 true 或者 false，因此我们在下面只会对存在额外特殊情况的配置值做讲解。</p><h4 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h4><h5 id="noImplicitAny"><a href="#noImplicitAny" class="headerlink" title="noImplicitAny"></a>noImplicitAny</h5><p>在你没有为变量或参数指定类型，同时 TypeScript 也无法自动推导其类型时，这里变量的类型就会被推导为 any。而推导为 any 类型就意味着丧失了类型检查：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中函数 fn 的参数 s 没有声明类型，因而被推导为 any，这就导致你可以使用任意类型的值来调用，这无疑是非常危险的。如果你希望禁止这一类行为，可以启用 noImplicitAny 配置，然后这种由于无类型标注导致的隐式 any 类型推导就会抛出一个错误。当然，你仍然可以显式地标记一个类型为 any，但这时就意味着，<strong>你确实希望它是一个 any 类型</strong>。</p><h5 id="useUnknownInCatchVariables"><a href="#useUnknownInCatchVariables" class="headerlink" title="useUnknownInCatchVariables"></a>useUnknownInCatchVariables</h5><p>启用此配置后，try/catch 语句中 catch 的 error 类型会被更改为 unknown （否则是 any 类型）。这样可以在类型层面确保在 catch 语句中对 error 进行更妥当的处理：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ...</span>  <span class="token comment">// 一个自定义的错误类</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NetworkError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token keyword">instanceof</span> <span class="token class-name">NetworkError</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token keyword">instanceof</span> <span class="token class-name">AuthError</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token keyword">instanceof</span> <span class="token class-name">CustomError</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="逻辑检查"><a href="#逻辑检查" class="headerlink" title="逻辑检查"></a>逻辑检查</h4><h5 id="noFallthroughCasesInSwitch"><a href="#noFallthroughCasesInSwitch" class="headerlink" title="noFallthroughCasesInSwitch"></a>noFallthroughCasesInSwitch</h5><p>这一配置确保在你的 switch case 语句中不会存在连续执行多个 case 语句的情况。注意，连续执行指的是某一个 case 中自己执行了专属逻辑后，由于没有 break / return 语句导致继续向下执行。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> a<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'zero'</span><span class="token punctuation">)</span>  <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'one'</span><span class="token punctuation">)</span>  <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'two'</span><span class="token punctuation">)</span>    <span class="token keyword">break</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，case 0、case 1、case 2 的语句都会执行！这是因为在 JavaScript 中，当 switch case 语句执行完毕匹配的那个 case 子句后，如果没有 break 或者 return，就会接着往下执行下一个 case，而不论其条件是否匹配。</p><h5 id="noImplicitOverride"><a href="#noImplicitOverride" class="headerlink" title="noImplicitOverride"></a>noImplicitOverride</h5><p>在函数与 Class 一节我们有讲到，在派生类继承于基类时，通常我们<strong>不希望去覆盖基类已有的方法</strong>（SOLID 原则），这样可以确保在任何需要基类的地方，我们都可以放心地传入一个派生类。</p><p>在真的需要覆盖基类方法时，推荐的方式是使用 override 关键字，标明此方法覆盖了基类中的方法。而 <code>noImplicitOverride</code> 这一配置的作用，就是避免你在不使用 override 关键字的情况下就覆盖了基类方法。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span>  <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Derived1</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span>  override <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Derived2</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 错误！没有使用 override 关键字</span>  <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="noImplicitReturns"><a href="#noImplicitReturns" class="headerlink" title="noImplicitReturns"></a>noImplicitReturns</h5><p>这一配置会确保所有返回值类型中不包含 undefined 的函数，在其内部所有的执行路径上都需要有 return 语句：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 函数缺少结束 return 语句，返回类型不包括 "undefined"。</span><span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span>color<span class="token operator">:</span> <span class="token string">'blue'</span> <span class="token operator">|</span> <span class="token string">'black'</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>color <span class="token operator">===</span> <span class="token string">'blue'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token string">'beats'</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token string">'bose'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们在 else 分支忘记了 return，这里立刻就给到了一个报错。这一配置可以确保在存在复杂嵌套路径的函数中，所有路径最后都显式执行了 return 。举例来说，假设我们的函数希望先检查一遍参数，如果不符要求就提前返回，此时如果忘记添加 return，会导致后面的逻辑仍然错误执行。</p><h5 id="noImplicitThis"><a href="#noImplicitThis" class="headerlink" title="noImplicitThis"></a>noImplicitThis</h5><p>JavaScript 代码中，我们其实经常见到 this，this 的指向也一直是一个很烦人的问题。虽然在 ES6 占据主导地位的今天，我们通常只会在 Class 内部使用 this，TypeScript 还是为 this 留了一席之地。比如函数与 Class 的方法中，实际上第一个参数是 this：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个 this 参数实际上就是函数执行时指向的 this，你可以在实际情况中灵活地指定 this 为具体类型。如果你并不声明 this 类型而是直接访问，就会得到一个错误：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// "this" 隐式具有类型 "any"，因为它没有类型注释。</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这就是 <code>noImplicitThis</code> 配置所关注的内容，它确保你在使用 this 语法时一定能够确定 this 的具体类型，当然，你仍然可以使用 any 。</p><h5 id="noPropertyAccessFromIndexSignature-与-noUncheckedIndexedAccess"><a href="#noPropertyAccessFromIndexSignature-与-noUncheckedIndexedAccess" class="headerlink" title="noPropertyAccessFromIndexSignature 与 noUncheckedIndexedAccess"></a>noPropertyAccessFromIndexSignature 与 noUncheckedIndexedAccess</h5><p>在索引类型一节我们知道，可以通过索引签名类型来声明一个仅确定键值类型而不确定具体属性的接口：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">AllStringTypes</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">PropType1</span> <span class="token operator">=</span> AllStringTypes<span class="token punctuation">[</span><span class="token string">'unknownProp'</span><span class="token punctuation">]</span> <span class="token comment">// string</span><span class="token keyword">type</span> <span class="token class-name">PropType2</span> <span class="token operator">=</span> AllStringTypes<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span> <span class="token comment">// string</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>索引类型签名的确可以帮助你快速生成一个随意使用的接口结构，但在某些时候也会带来危险，比如你忘记了检查这个属性是不是真的存在。</p><p>这两条配置的功能就是让对基于索引签名类型声明的结构属性访问更安全一些，其中 <code>noPropertyAccessFromIndexSignature</code> 配置禁止了对未知属性（如 <code>&#39;unknownProp&#39;</code>）的访问，即使它们已在索引类型签名中被隐式声明。而对于具体声明的已知属性访问，如 <code>name</code> 则不会有问题。</p><p>而 <code>noUncheckedIndexedAccess</code> 配置则宽松一些，它会将一个 undefined 类型附加到对未知属性访问的类型结果上，比如 <code>PropType1</code> 的类型会是 <code>string | undefined</code>，这样能够提醒你在对这个属性进行读写时进行一次空检查。</p><h5 id="noUnusedLocals-与-noUnusedParameters"><a href="#noUnusedLocals-与-noUnusedParameters" class="headerlink" title="noUnusedLocals 与 noUnusedParameters"></a>noUnusedLocals 与 noUnusedParameters</h5><p>是否允许存在<strong>声明但未使用的变量和函数参数</strong>，就像 ESLint 一样，这里就不做介绍了。</p><h3 id="严格检查"><a href="#严格检查" class="headerlink" title="严格检查"></a>严格检查</h3><h4 id="exactOptionalPropertyTypes"><a href="#exactOptionalPropertyTypes" class="headerlink" title="exactOptionalPropertyTypes"></a>exactOptionalPropertyTypes</h4><p>这一配置会使得 TypeScript 对可选属性（即使用 <code>?</code> 修饰的属性）启用更严格检查，如以下这个例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">ITheme</span> <span class="token punctuation">&#123;</span>  prefer<span class="token operator">?</span><span class="token operator">:</span> <span class="token string">'dark'</span> <span class="token operator">|</span> <span class="token string">'light'</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>默认情况下，prefer 属性的类型实际为 <code>&quot;dark&quot; | &quot;light&quot; | undefined</code>，也就是说你可以这么做：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">ITheme</span> <span class="token punctuation">&#123;</span>  prefer<span class="token operator">?</span><span class="token operator">:</span> <span class="token string">'dark'</span> <span class="token operator">|</span> <span class="token string">'light'</span><span class="token punctuation">&#125;</span><span class="token keyword">declare</span> <span class="token keyword">const</span> theme<span class="token operator">:</span> IThemetheme<span class="token punctuation">.</span>prefer <span class="token operator">=</span> <span class="token string">'dark'</span>theme<span class="token punctuation">.</span>prefer <span class="token operator">=</span> <span class="token string">'light'</span>theme<span class="token punctuation">.</span>prefer <span class="token operator">=</span> <span class="token keyword">undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将这个属性设置为 undefined 其实很容易造成困惑，你是希望这个属性被移除掉呢，还是希望表示这个属性目前没有值（这时难道不应该用 null 吗）？</p><p>为了避免这一情况，你可以启用 <code>exactOptionalPropertyTypes</code> 配置，此时 undefined 不会再被允许作为可选属性的值，除非你显式添加一个 undefined 类型。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 类型 “undefined” 不能分配给“exactOptionalPropertyTypes: true”的类型 “"dark" | "light"”。请考虑将 “undefined” 添加到目标类型。</span>theme<span class="token punctuation">.</span>prefer <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token keyword">interface</span> <span class="token class-name">ITheme</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 需要这么做才可以</span>  prefer<span class="token operator">?</span><span class="token operator">:</span> <span class="token string">'dark'</span> <span class="token operator">|</span> <span class="token string">'light'</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="alwaysStrict"><a href="#alwaysStrict" class="headerlink" title="alwaysStrict"></a>alwaysStrict</h4><p>还记得 ES5 中的严格模式吗？这一配置就是它在 TS 中的体现，alwaysStrict 配置会使得 TS 对所有文件使用严格模式进行检查（表现在会禁用掉一部分语法），同时生成的 js 文件开头也会有 <code>&#39;use strict&#39;</code> 标记。</p><h4 id="strict"><a href="#strict" class="headerlink" title="strict"></a>strict</h4><p>strict 其实是一组规则的开关，开启 strict 会默认将这些规则全部启用，包括：</p><ul><li><code>alwaysStrict</code>、<code>useUnknownInCatchVariables</code></li><li><code>noFallthroughCasesInSwitch</code>、<code>noImplicitAny</code>、<code>noImplicitThis</code></li><li><code>strictNullChecks</code>、<code>strictBindCallApply</code>、<code>strictFunctionTypes</code>、<code>strictPropertyInitialization</code></li></ul><p>这些规则我们均会在接下来介绍。</p><h4 id="strictBindCallApply"><a href="#strictBindCallApply" class="headerlink" title="strictBindCallApply"></a>strictBindCallApply</h4><p>JavaScript 中可以通过 bind、call、apply 来改变一个函数的 this 指向，绝大部分情况下即使改变了 this 指向，函数的入参也应当是不变的。这条配置会确保在使用 bind、call、apply 方法时，其第二个入参（即<strong>将用于调用原函数的入参</strong>）需要与原函数入参类型保持一致：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> n1 <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token string">'10'</span><span class="token punctuation">)</span><span class="token comment">// 类型“boolean”的参数不能赋给类型“string”的参数。</span><span class="token keyword">const</span> n2 <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="strictFunctionTypes"><a href="#strictFunctionTypes" class="headerlink" title="strictFunctionTypes"></a>strictFunctionTypes</h4><p>对函数类型启用更严格的检查，即我们在函数类型比较一节中讲到的，对参数类型启用逆变检查。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello, '</span> <span class="token operator">+</span> x<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">StringOrNumberFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ns<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token comment">// 不能将类型“string | number”分配给类型“string”。</span><span class="token keyword">let</span> func<span class="token operator">:</span> StringOrNumberFunc <span class="token operator">=</span> fn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，对于接口中的函数类型，只有通过 property 形式声明才会接受严格检查，即以下代码不会被检查出错误：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Methodish</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token function">func</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello, '</span> <span class="token operator">+</span> x<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> m<span class="token operator">:</span> Methodish <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 没有对函数参数类型进行逆变检查</span>  func<span class="token operator">:</span> fn<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token comment">// 实际运行将会报错</span>m<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="strictNullChecks"><a href="#strictNullChecks" class="headerlink" title="strictNullChecks"></a>strictNullChecks</h4><p><strong>这是在任何规模项目内都应该开启的一条规则</strong>。在这条规则关闭的情况下，null 和 undefined 会被隐式地视为任何类型的子类型，还记得我们前面的例子吗？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 以下两个仅在关闭 strictNullChecks 时成立</span><span class="token keyword">const</span> tmp3<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token keyword">const</span> tmp4<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在某些可能产生 <code>string | undefined</code> 类型的方法中，如果关闭了 strictNullChecks 检查，就意味着很可能下面会遇到一个 <strong><em>cannot read property ‘xxx’ of undefined</em></strong> 的错误：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> matcher<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'budu'</span><span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token string">'599'</span><span class="token punctuation">]</span><span class="token comment">// 为 string 类型</span><span class="token keyword">const</span> target <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span> <span class="token operator">=></span> u<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>matcher<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'budu'</span><span class="token punctuation">,</span> <span class="token string">'wuhu'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，target 的类型应该是 <code>string | undefined</code>，下面的 <code>target.replace</code> 访问并不一定能成功。但关闭了 strictNullChecks 检查之后，我们就不能及时发现这一点了。</p><h4 id="strictPropertyInitialization"><a href="#strictPropertyInitialization" class="headerlink" title="strictPropertyInitialization"></a>strictPropertyInitialization</h4><p>这一配置要求 Class 中的所有属性都需要存在一个初始值，无论是在声明时就提供还是在构造函数中初始化。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  prop1<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">599</span>  prop2<span class="token operator">:</span> <span class="token builtin">number</span>  <span class="token comment">// 属性“prop3”没有初始化表达式，且未在构造函数中明确赋值。</span>  prop3<span class="token operator">:</span> <span class="token builtin">number</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> prop4<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>prop2 <span class="token operator">=</span> prop4  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这条配置有时候也不完全合理，如我们将初始化逻辑放在一个单独函数中：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  prop1<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">599</span>  prop2<span class="token operator">:</span> <span class="token builtin">number</span>  <span class="token comment">// 属性“prop3”没有初始化表达式，且未在构造函数中明确赋值。</span>  prop3<span class="token operator">:</span> <span class="token builtin">number</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> prop4<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>prop2 <span class="token operator">=</span> prop4    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>prop3 <span class="token operator">=</span> <span class="token number">599</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时报错仍然存在，但我们其实已经确保了有初始值的存在。这种情况下可以依据实际需要使用非空断言或可选修饰：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  prop3<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">number</span>  _prop3<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="skipLibCheck-与-skipDefaultLibCheck"><a href="#skipLibCheck-与-skipDefaultLibCheck" class="headerlink" title="skipLibCheck 与 skipDefaultLibCheck"></a>skipLibCheck 与 skipDefaultLibCheck</h3><p>默认情况下，TypeScript 会对加载的类型声明文件也进行检查，包括内置的 <code>lib.d.ts</code> 系列与 <code>@types/</code> 下的声明文件。在某些时候，这些声明文件可能存在冲突，比如两个不同来源的声明文件使用不同的类型声明了一个全局变量。此时，你就可以使用 skipLibCheck 跳过对这些类型声明文件的检查，这也能进一步加快编译速度。</p><p><code>skipDefaultLibCheck</code> 类似于 <code>skipLibCheck</code> ，但它只会跳过那些使用了 <code>/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</code> 指令的声明文件（如内置的 <code>lib.d.ts</code>），这一三斜线指令的作用即是<strong>将此文件标记为默认库声明</strong>，因此开启这一配置后，编译器在处理其文件时不会再尝试引入默认库声明。</p><h2 id="工程相关"><a href="#工程相关" class="headerlink" title="工程相关"></a>工程相关</h2><h3 id="Project-References"><a href="#Project-References" class="headerlink" title="Project References"></a>Project References</h3><p>Project References 这一配置使得你可以将整个工程拆分成多个部分，比如你的 UI 部分、Hooks 部分以及主应用等等。这一功能和 Monorepo 非常相似，但它并不需要各个子项目拥有自己独立的 package.json、独立安装依赖、独立构建等。通过 Project References ，我们可以定义这些部分的引用关系，为它们使用独立的 tsconfig 配置。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"references"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span> <span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"../ui-components"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"../hooks"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"../utils"</span> <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关于具体项目，请参考我们仓库中的示例。</p></blockquote><p>这一特性实际上也让 tsc 不再只是一个编译器了，它现在还可以是一个类似于 lerna 那样的 Script Runner，即在多个子项目之间去确定一条顺序正确的构建链路。也因此，在使用 Project References 的项目中，需要使用 <code>tsc --build</code> 而非 <code>tsc</code> 来进行构建，此时 tsc 会首先确定整个引用关系图，然后检查上面作为子结点的项目是否是最新构建的，最后才基于引用顺序去构建这些非最新的项目。</p><p>我们可以来实际体验一下，假设要构建的项目结构是这样的：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">PROJECT├── app│   ├── index.ts│   ├── tsconfig.json├── core│   ├── index.ts│   ├── tsconfig.json├── ui│   ├── index.ts│   ├── tsconfig.json├── utils│   ├── index.ts│   ├── tsconfig.json├── tsconfig.base.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这四个项目的引用关系是这样的：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">app -> core, ui, utilscore -> utils<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这四个项目可以使用完全独立的 TSConfig 配置，如 utils 的 target 为 ES5，而 app 的 target 则可以是 ESNext ，那么检查配置、功能配置等自然也可以不同。</p><p>首先，在 <code>app/tsconfig.json</code> 中定义引用关系：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"extends"</span><span class="token operator">:</span> <span class="token string">"../tsconfig.base.json"</span><span class="token punctuation">,</span>  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"ESNext"</span><span class="token punctuation">,</span>    <span class="token property">"module"</span><span class="token operator">:</span> <span class="token string">"ESNext"</span><span class="token punctuation">,</span>    <span class="token property">"baseUrl"</span><span class="token operator">:</span> <span class="token string">"."</span><span class="token punctuation">,</span>    <span class="token property">"outDir"</span><span class="token operator">:</span> <span class="token string">"../dist/app"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"include"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"./**/*.ts"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"references"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"../utils"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"../core"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"../ui"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 outDir 被配置为父级目录，因为我们仍然希望这四个项目的构建产物被放置在同一个文件夹下，你也可以根据自己的实际需要定制。</p><p>core 、utils、ui 这三个项目中也是类似：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"extends"</span><span class="token operator">:</span> <span class="token string">"../tsconfig.base.json"</span><span class="token punctuation">,</span>  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"composite"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token property">"baseUrl"</span><span class="token operator">:</span> <span class="token string">"."</span><span class="token punctuation">,</span>    <span class="token property">"outDir"</span><span class="token operator">:</span> <span class="token string">"../dist/core"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"include"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"./**/*.ts"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"references"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"../utils"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span>  <span class="token property">"extends"</span><span class="token operator">:</span> <span class="token string">"../tsconfig.base.json"</span><span class="token punctuation">,</span>  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"composite"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"ES5"</span><span class="token punctuation">,</span>    <span class="token property">"module"</span><span class="token operator">:</span> <span class="token string">"commonjs"</span><span class="token punctuation">,</span>    <span class="token property">"baseUrl"</span><span class="token operator">:</span> <span class="token string">"."</span><span class="token punctuation">,</span>    <span class="token property">"outDir"</span><span class="token operator">:</span> <span class="token string">"../dist/utils"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"include"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"./**/*.ts"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span>  <span class="token property">"extends"</span><span class="token operator">:</span> <span class="token string">"../tsconfig.base.json"</span><span class="token punctuation">,</span>  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"composite"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token property">"baseUrl"</span><span class="token operator">:</span> <span class="token string">"."</span><span class="token punctuation">,</span>    <span class="token property">"outDir"</span><span class="token operator">:</span> <span class="token string">"../dist/ui"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"include"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"./**/*.ts"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>app/index.ts</code> 中去引用其余三个项目：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> util <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'../utils'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> core <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'../core'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ui <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'../ui'</span><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">app</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token function">ui</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token function">core</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token function">util</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'app!'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他三个项目的导出函数也只是一个简单函数，这里就不展示代码了。</p><p>现在来执行构建命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tsc <span class="token parameter variable">--build</span> app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><code>tsc --build</code> 命令下无需也不能使用 <code>--project</code> 配置，直接指定文件夹即可。</p></blockquote><p>构建后的产物是这样的：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad4c509346b84c9e85bc66aaa80af458~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>可以看到 app 中声明的子项目引用也被一同构建，同时这些子项目的构建产物中会有 <code>tsconfig.tsbuildinfo</code> 文件来缓存本次的构建信息。</p><p>你也可以在 build 模式下启用监听：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tsc <span class="token parameter variable">--build</span> <span class="token parameter variable">--watch</span> app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时如果你修改一个子项目，tsc 会自动进行增量构建，跳过没有发生变化的项目，只构建那些发生了更改的部分。</p><p>另外，如果你在某个项目内通过 Ctrl /Command + 点击的方式跳转到一个导入的实现，你会发现能够直接跳转到这个实现的源码而非类型定义，这同样能帮助你的开发效率 up up！</p><h4 id="composite"><a href="#composite" class="headerlink" title="composite"></a>composite</h4><p>composite 属于 compilerOptions 内部的配置，在 Project References 的被引用子项目 <code>tsconfig.json</code> 中必须为启用状态，它通过一系列额外的配置项，确保你的子项目能被 Project References 引用，而在子项目中必须启用 declaration ，必须通过 files 或 includes 声明子项目内需要包含的文件等。</p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><h4 id="isolatedModules"><a href="#isolatedModules" class="headerlink" title="isolatedModules"></a>isolatedModules</h4><p>我们常常提到的，构建过程会使用 TypeScript 配合其他构建器，如 ESBuild、SWC、Babel 等。通常在这个过程中，类型相关的检查会完全交由 TypeScript 处理，因为这些构建器只能执行语法降级与打包。</p><p>由于这些构建器通常是独立地处理每个文件，这也就意味着如果存在如类型导入、namespace 等特殊语法时，它们无法像 tsc 那样去全面分析这些关系后再进行处理。此时我们可以启用 isolatedModules 配置，它会确保每个文件都能被视为一个独立模块，因此也就能够被这些构建器处理。</p><p>启用 isolatedModules 后，所有代码文件（不包括声明文件）都需要至少存在一个导入或导出语句（比如最简单的情况下可以使用 <code>export &#123;&#125;</code>），无法导出类型（ESBuild 并不知道这个值是类型还是值）以及无法使用 namespace 与常量枚举（常量枚举在构建后会被内联到产物中）。</p><p>除了这些构建器以外，isolatedModules 配置也适用于使用 TS Compiler API 中的 transpileModule 方法，这个方法类似于 Babel，不会生成声明文件，只会进行单纯的语法降级。</p><h4 id="JavaScript-相关"><a href="#JavaScript-相关" class="headerlink" title="JavaScript 相关"></a>JavaScript 相关</h4><h5 id="allowJs"><a href="#allowJs" class="headerlink" title="allowJs"></a>allowJs</h5><p>只有在开启此配置后，你才能在 <code>.ts</code> 文件中去导入 <code>.js</code> / <code>.jsx</code> 文件。</p><h5 id="checkJs"><a href="#checkJs" class="headerlink" title="checkJs"></a>checkJs</h5><p>checkJs 通常用于配合 allowJs 使用，为 <code>.js</code> 文件提供尽可能全面的类型检查。我们在类型指令一节学习过 <code>@ts-check</code> 指令，这一配置就相当于为所有 JavaScript 文件标注了 <code>@ts-check</code>。</p><p>如果你希望禁用对部分 JavaScript 文件的检查，或者仅对部分 JavaScript 文件进行检查，可以对应地使用 <code>@ts-nocheck</code> 和 <code>@ts-check</code>。</p><h4 id="模块相关"><a href="#模块相关" class="headerlink" title="模块相关"></a>模块相关</h4><h5 id="esModuleInterop-与-allowSyntheticDefaultImports"><a href="#esModuleInterop-与-allowSyntheticDefaultImports" class="headerlink" title="esModuleInterop 与 allowSyntheticDefaultImports"></a>esModuleInterop 与 allowSyntheticDefaultImports</h5><p>这两个配置主要还是为了解决 ES Module 和 CommonJS 之间的兼容性问题。</p><p>通常情况下，ESM 调用 ESM，CJS 调用 CJS，都不会有问题。但如果是 ESM 调用 CJS ，就可能遇到奇怪的问题。比如 React 中的源码中是这样导出的：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// react/cjs/react.development.js</span>exports<span class="token punctuation">.</span>Children <span class="token operator">=</span> Childrenexports<span class="token punctuation">.</span>useState <span class="token operator">=</span> useStateexports<span class="token punctuation">.</span>memo <span class="token operator">=</span> memoexports<span class="token punctuation">.</span>useEffect <span class="token operator">=</span> useEffect<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设我们分别使用具名导入、默认导入和命名空间导入来导入 React：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useRef <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span> <span class="token comment">// 具名导入（named import）</span><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span> <span class="token comment">// 默认导入（default import）</span><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> ReactCopy <span class="token keyword">from</span> <span class="token string">'react'</span> <span class="token comment">// 命名空间导入（namespace import）</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>useRef<span class="token punctuation">)</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>React<span class="token punctuation">.</span>useState<span class="token punctuation">)</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ReactCopy<span class="token punctuation">.</span>useEffect<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的代码在默认情况下（即没有启用 esModuleInterop）会被编译为：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token string">'use strict'</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>exports<span class="token punctuation">,</span> <span class="token string">'__esModule'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">const</span> react_1 <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'react'</span><span class="token punctuation">)</span><span class="token keyword">const</span> react_2 <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'react'</span><span class="token punctuation">)</span><span class="token keyword">const</span> ReactCopy <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'react'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>react_1<span class="token punctuation">.</span>useRef<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>react_2<span class="token punctuation">.</span>default<span class="token punctuation">.</span>useState<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ReactCopy<span class="token punctuation">.</span>useEffect<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，默认导入的调用被转换为了 <code>react_2.default</code>，而具名导入和命名空间则不变，三种导入语句都被转换为了 CJS。</p><p>这是因为 TypeScript 默认将 CommonJs 也视为 ES Module 一样，对于具名导入，可以直接将 <code>module.exports.useRef = useRef</code> 和 <code>export const useRef = useRef</code>等价。但是由于 CommonJs 中并没有这个“默认导出”这个概念， 只能将 ES Module 中的默认导出 <code>export default</code> 强行等价于 <code>module.exports.default</code>，如上面的编译结果中的 <code>react_2.default</code>。这里的 default 就是一个属性名，和 <code>module.exports.foo</code> 是一个概念。</p><p>但 CommonJs 下存在着类似“命名空间导出”的概念，即 <code>const react = require(&quot;react&quot;)</code>可以等价于 <code>import * as React from &quot;react&quot;</code>。</p><p>很明显，对于默认导出的情况，由于 React 中并没有使用 <code>module.exports.default</code> 提供（模拟）一个默认导出，因此 <code>react_2.default</code> 只可能是 undefined。</p><p>为了解决这种情况，TypeScript 中支持通过 esModuleInterop 配置来在 ESM 导入 CJS 这种情况时引入额外的辅助函数，进一步对兼容性进行支持，如上面的代码在开启配置后的构建产物会是这样的：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> __createBinding <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__createBinding<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span>create <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">o<span class="token punctuation">,</span> m<span class="token punctuation">,</span> k<span class="token punctuation">,</span> k2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//... &#125;));</span><span class="token keyword">var</span> __setModuleDefault <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__setModuleDefault<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span>create <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">o<span class="token punctuation">,</span> v</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//... &#125;);</span><span class="token keyword">var</span> __importStar <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__importStar<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">mod</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//... &#125;;</span><span class="token keyword">var</span> __importDefault <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__importDefault<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">mod</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>mod <span class="token operator">&amp;&amp;</span> mod<span class="token punctuation">.</span>__esModule<span class="token punctuation">)</span> <span class="token operator">?</span> mod <span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token string-property property">"default"</span><span class="token operator">:</span> mod <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>exports<span class="token punctuation">,</span> <span class="token string">"__esModule"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> react_1 <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"react"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> react_2 <span class="token operator">=</span> <span class="token function">__importDefault</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"react"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> ReactCopy <span class="token operator">=</span> <span class="token function">__importStar</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"react"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>react_1<span class="token punctuation">.</span>useRef<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>react_2<span class="token punctuation">.</span>default<span class="token punctuation">.</span>useState<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ReactCopy<span class="token punctuation">.</span>useEffect<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些辅助函数会确保 ESM 的默认导入（<code>__importDefault</code>） 与命名空间导入 （<code>__importStar</code>）能正确地对应到 CJS 中的导出，如<code>__importDefault</code> 会检查目标模块的使用规范，对 ESM 模块直接返回，否则将其挂载在一个对象的 default 属性上：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> react_2 <span class="token operator">=</span> <span class="token function">__importDefault</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'react'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">1</span><span class="token comment">// 转换结果等价于以下</span><span class="token keyword">const</span> react_2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token keyword">default</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">useState</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而 <code>__importStar</code> （即命名空间导入的辅助函数）的实现则要复杂一些：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> __importStar <span class="token operator">=</span>  <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__importStar<span class="token punctuation">)</span> <span class="token operator">||</span>  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">mod</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mod <span class="token operator">&amp;&amp;</span> mod<span class="token punctuation">.</span>__esModule<span class="token punctuation">)</span> <span class="token keyword">return</span> mod    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mod <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token keyword">in</span> mod<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">!==</span> <span class="token string">'default'</span> <span class="token operator">&amp;&amp;</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>mod<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token function">__createBinding</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> mod<span class="token punctuation">,</span> k<span class="token punctuation">)</span>    <span class="token function">__setModuleDefault</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> mod<span class="token punctuation">)</span>    <span class="token keyword">return</span> result  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它会在目标模块不是 ESM 规范时，将模块中除了 default 属性以外的导出都挂载到返回对象上（<code>__createBinding</code>），然后将这个对象的 default 属性设置为原本的模块信息（<code>__setModuleDefault</code>）。这样你既可以 <code>ReactCopy.useEffect</code> 访问某个值，也可以 <code>ReactCopy.default</code> 访问原本的模块。</p><p>这些辅助方法也属于 <code>importHelpers</code> 中的 helper，因此你也可以通过启用 <code>importHelpers</code> 配置来从 tslib 导入这些辅助方法。</p><p>实际上，由于 React 本身是通过 CommonJs 导出的，在你使用默认导入时， TS 也会提醒你此模块只能在启用了 <code>esModuleInterop</code> 的情况下使用默认导入。</p><p>启用 <code>esModuleInterop</code> 配置的同时，也会启用 <code>allowSyntheticDefaultImports</code> 配置，这一配置会为没有默认导出的 CJS 模块“模拟”出默认的导出，以提供更好的类型提示。如以下代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// handlers.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">errorHandler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token comment">// index.js</span><span class="token keyword">import</span> handlers <span class="token keyword">from</span> <span class="token string">'./handlers'</span>window<span class="token punctuation">.</span>onerror <span class="token operator">=</span> handlers<span class="token punctuation">.</span>errorHandler<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然这段代码转换后的实际逻辑没有问题，但由于这里并不存在 <code>module.exports.default</code> 导出，会导致在类型上出现一个错误。</p><p>启用 <code>allowSyntheticDefaultImports</code> 配置会在这种情况下将 handlers 中的代码模拟为以下的形式：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> allHandlers <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">errorHandler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> allHandlersmodule<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>default <span class="token operator">=</span> allHandlers<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在导入方就能够获得正确的类型提示了，实际上这也是 Babel 实际的构建效果，但需要注意的是在 TypeScript 中 <code>allowSyntheticDefaultImports</code> 配置并不会影响最终的代码生成（不像 <code>esModuleInterop</code> 那样），只会对类型检查有帮助。</p><h3 id="编译器相关"><a href="#编译器相关" class="headerlink" title="编译器相关"></a>编译器相关</h3><h4 id="incremental"><a href="#incremental" class="headerlink" title="incremental"></a>incremental</h4><p>incremental 配置将启用增量构建，在每次编译时首先 diff 出发生变更的文件，仅对这些文件进行构建，然后将新的编译信息通过 <code>.tsbuildinfo</code> 存储起来。你可以使用 tsBuildInfoFile 配置项来控制这些编译信息文件的输出位置。</p><h4 id="watch-相关"><a href="#watch-相关" class="headerlink" title="watch 相关"></a>watch 相关</h4><p>我们可以通过 <code>tsc --watch</code> 来启动一个监听模式的 tsc，它会在代码文件发生变化（同样会对 node_modules 文件夹的变化进行监听，但只到文件夹级别）时重新进行编译。通常我们会搭配 incremental 选项。</p><p>你可以通过与 compilerOptions 同级的 watchOptions 来配置监听行为：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"es2020"</span><span class="token punctuation">,</span>    <span class="token property">"moduleResolution"</span><span class="token operator">:</span> <span class="token string">"node"</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"watchOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如何监听文件</span>    <span class="token property">"watchFile"</span><span class="token operator">:</span> <span class="token string">"useFsEvents"</span><span class="token punctuation">,</span>    <span class="token comment">// 如何监听目录</span>    <span class="token property">"watchDirectory"</span><span class="token operator">:</span> <span class="token string">"useFsEvents"</span><span class="token punctuation">,</span>    <span class="token property">"fallbackPolling"</span><span class="token operator">:</span> <span class="token string">"dynamicPriority"</span><span class="token punctuation">,</span>    <span class="token property">"synchronousWatchDirectory"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token property">"excludeDirectories"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"**/node_modules"</span><span class="token punctuation">,</span> <span class="token string">"_build"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"excludeFiles"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"build/fileWhichChangesOften.ts"</span><span class="token punctuation">]</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 <code>watchFile</code> 与 <code>watchDirectory</code> 选项，TS 提供了 <code>useFsEvents</code>（使用操作系统的原生事件来进行监听）、<code>fixedPollingInterval</code>（不进行具体监听，而只是在每秒以固定的时间间隔后去检查发生变更的文件）、<code>priorityPollingInterval</code>（类似 fixedPollingInterval ，但对某些特殊类型文件的检查频率会降低）、<code>dynamicPriorityPolling</code>（对变更不频繁的文件，检查频率降低）、<code>useFsEventsOnParentDirectory</code>（对文件/目录的父文件夹使用原生事件监听） 等数个监听方式选择。</p><p>其他常用的选项则主要是用于减小监听范围的 <code>excludeDirectories</code> 与 <code>excludeFiles</code> 。</p><h4 id="编译器检查"><a href="#编译器检查" class="headerlink" title="编译器检查"></a>编译器检查</h4><p>这里的配置主要用于检查编译器的工作情况，或者在你需要进行编译器性能优化时使用，它们会生成编译器工作的分析报告，包括本次编译包含了哪些文件，以及各个编译阶段（I/O、Type Checking 等）的耗时。</p><ul><li><p>diagnostics 与 extendedDiagnostics，输出诊断信息，其中 diagnostics 会生成可读性更好的版本。</p></li><li><p>generateCpuProfile，生成 CPU 的耗时报告，用于了解构建缓慢的可能原因。</p></li><li><p>listFiles 与 listEmittedFiles，其中 listFiles 会罗列所有被纳入本次编译过程的文件，可以用于检查是否携带了非预期的文件。而 listEmittedFiles 则会罗列输出的文件，你可以利用这些文件信息进行额外处理，比如拷贝文件。</p></li><li><p>traceResolution，输出一份跟踪模块解析策略与路径的信息，比如这样：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">======== Resolving module 'typescript' from 'src/app.ts'. ========Module resolution kind is not specified, using 'NodeJs'.Loading module 'typescript' from 'node_modules' folder.File 'src/node_modules/typescript.ts' does not exist.File 'src/node_modules/typescript.tsx' does not exist.File 'src/node_modules/typescript.d.ts' does not exist.File 'src/node_modules/typescript/package.json' does not exist.File 'node_modules/typescript.ts' does not exist.File 'node_modules/typescript.tsx' does not exist.File 'node_modules/typescript.d.ts' does not exist.Found 'package.json' at 'node_modules/typescript/package.json'.'package.json' has 'types' field './lib/typescript.d.ts' that references 'node_modules/typescript/lib/typescript.d.ts'.File 'node_modules/typescript/lib/typescript.d.ts' exist - use it as a module resolution result.======== Module name 'typescript' was successfully resolved to 'node_modules/typescript/lib/typescript.d.ts'. ========<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="其它工程相关"><a href="#其它工程相关" class="headerlink" title="其它工程相关"></a>其它工程相关</h3><h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h4><p>这一配置可以类比到 ESLint 配置中的 extends，作用就是复用已有的文件，在这里即是一个已存在的 TSConfig 配置文件。其作用包括在 Monorepo 下统一各个子项目的基础配置：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token comment">// &lt;root>/packages/pkg/tsconfig.json</span><span class="token punctuation">&#123;</span>  <span class="token property">"extends"</span><span class="token operator">:</span> <span class="token string">"../../tsconfig.base.json"</span><span class="token punctuation">&#125;</span><span class="token comment">// &lt;root>/tsconfig.base.json</span><span class="token punctuation">&#123;</span>  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者在团队的所有项目间使用基本统一的配置：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"extends"</span><span class="token operator">:</span> <span class="token string">"team-config/tsconfig.json"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中 team-config 是一个 npm 包。</p><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节，我们了解了检查相关和工程相关的 TSConfig ，其中有些配置涉及前端领域的其他知识，如在 esModuleInterop 中，我们了解了 ESM 与 CJS 之间调用的问题，以及 TypeScript 是如何解决的。在工程部分，我们了解了 Project References 这一工程领域的重磅特性，以及如何通过 isolatedModules 来使其它编译器也能妥善处理 TS 代码。</p><p>另外，这两节的内容其实并不包含所有 TSConfig 配置，除了省略了一些纯做兼容性的配置（如 outFile 的前身 <code>out</code> 配置）以外，还有部分没有介绍的配置我们会在后续的漫谈篇中使用专门的一节来进行介绍，如从定义编辑器插件的 <code>plugins</code> 配置到编辑器插件的开发。</p><p>在下一节，我们会进入完全的实战环节，使用 TypeScript + NestJs + Prisma 开发一个博客 API，从项目搭建、基本语法、数据库 与 ORM、请求链路到部署，让你拥有一个完整的，属于自己的 API 服务。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>29.基于 Prisma + NestJs 的 Node API ：前置知识储备</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/29.%E5%9F%BA%E4%BA%8E%20Prisma%20+%20NestJs%20%E7%9A%84%20Node%20API%20%EF%BC%9A%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/29.%E5%9F%BA%E4%BA%8E%20Prisma%20+%20NestJs%20%E7%9A%84%20Node%20API%20%EF%BC%9A%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p>在这一节，我们会使用 TypeScript 来开发一个 Node API，并将它部署在服务器上。技术选型方面，我们使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdocs.nestjs.com%2F">NestJs</a> 作为框架，<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.prisma.io%2F">Prisma</a> 作为 ORM，<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdashboard.heroku.com%2Fapps">Heroku</a> 作为部署平台与数据库提供商。</p><p>需要说明的是，我们要开发的 API 并不会十分完善。一方面，过多的 CRUD 代码并没有教学意义。另一方面，如果要完整开发一个生产可用的 API ，可能还需要再写一本小册才行。</p><p>那你可能会问，上面说的工具我都不了解怎么办呀？比较友好的一点是，你不需要对这几个工具非常了解，因为我们会分别介绍相应的前置知识。更加友好的是，你也不需要有自己的服务器与数据库，Heroku 已经帮我们准备好了。</p><p>但你仍然需要有基本的 NodeJs 使用经验，至少使用 Express / Koa 进行过基本的 API 开发，以及了解数据库、ORM 的基本知识。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2Ftiny-book-blog-api">Blog API</a></p></blockquote><h2 id="Heroku-环境配置"><a href="#Heroku-环境配置" class="headerlink" title="Heroku 环境配置"></a>Heroku 环境配置</h2><p>在正式开始前，我们不妨提前配置好 Heroku 的环境，因为这一步耗时比较久，我们可以让它在一边安装，先开始下面的学习。</p><p>在终端运行以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 适用于 Mac，需要安装 HomeBrew</span>brew tap heroku/brew <span class="token operator">&amp;&amp;</span> brew <span class="token function">install</span> heroku<span class="token comment"># 或者使用这个命令</span><span class="token function">curl</span> https://cli-assets.heroku.com/install.sh <span class="token operator">|</span> <span class="token function">sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关于其他安装方式，参考 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevcenter.heroku.com%2Farticles%2Fheroku-cli">Heroku CLI</a> 。</p></blockquote><h2 id="NestJS-基础"><a href="#NestJS-基础" class="headerlink" title="NestJS 基础"></a>NestJS 基础</h2><p>接下来，我们来了解 NestJs 的基础概念。</p><p>NestJs 是一个 NodeJs 框架，它和 Express、Koa、Egg 的主要区别其实就两点，<strong>应用风格</strong>与<strong>框架能力</strong>。</p><p>我们先来说应用风格。NestJs 中大量地使用了装饰器以及依赖注入（IoC &amp; DI）相关的理念，这一点官方团队自谦是受到了 Angular 的启发。而这也就意味着，在开发规模较大的项目时，Nest 也能够很好地保持项目间各个模块的引用关系清晰解耦，而 Express、Koa 其实随着项目规模的不断扩大，会需要开发者更有意识去进行依赖关系的维护。</p><p>而框架能力其实也是许多团队与企业在技术选型时的重要参考因素。在这一点上，就像 Angular 内置了路由、请求、表单、校验、SSR 等能力，是一个真正意义上的“全家桶”。Nest 也是如此，官方团队基本上已经把 95% 以上的能力都提供完毕，包括 ORM 的集成（<code>@nestjs/mongoose</code>, <code>@nestjs/typeorm</code>）、消息队列（<code>@nestjs/bull</code>）、Open API（<code>@nestjs/swagger</code>）、鉴权（<code>@nestjs/passport</code>）、GraphQL （<code>@nestjs/graphql</code>, <code>@nestjs/apollo</code> ）等等。在大部分情况下，这些能力以及附带的详细文档就能很好地满足你的需求。</p><p>当然，没有事物是十全十美的。我个人认为 Nest 不友好的地方在于，新手可能需要一些时间才能理解其模块作用域与依赖各种关系，imports、provides、providers、exports 等概念确实不是很好理解。</p><p>既然说基础了，那我们还是要介绍一下基本使用代码，这段代码我们在装饰器一节中已经很熟悉了：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Controller<span class="token punctuation">,</span> Get <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Controller</span></span><span class="token punctuation">(</span><span class="token string">'cats'</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsController</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token string">'This action returns all cats'</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本质上 Nest 也就是一个 Node API 框架，因此完全没必要在初次接触时就做深入了解，等我们用到的时候再学，才不会被劝退。</p><p>我们先新建好项目：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i @nest/cli <span class="token parameter variable">-g</span>nest new <span class="token operator">&lt;</span>application<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>初始的目录结构是这样的：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">project├── src├──── app.controller.ts├──── app.module.ts├──── app.service.ts├──── main.ts├── package.json├── nest-cli.json└── tsconfig.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们来简单介绍一下重要文件的功能，更好地了解 NestJs 的开发风格。</p><ul><li><p><code>app.controller.ts</code>，即 API 路由的定义文件，我们在这里去定义 <code>GET /user/list</code> <code>POST /user/add</code> 这样的请求处理逻辑。需要注意的是，在 Nest 应用中我们一般不会在 Controller 中去处理业务逻辑，Controller 通常只会处理请求入参的校验、请求响应的包装，具体的业务逻辑来自于 <code>app.service.ts</code>。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Controller<span class="token punctuation">,</span> Get <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> AppService <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./app.service'</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Controller</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppController</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">readonly</span> appService<span class="token operator">:</span> AppService<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token function">getHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>appService<span class="token punctuation">.</span><span class="token function">getHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>app.service.ts</code>，我们在 Service 层去处理数据库交互、BFF、日志等等的逻辑，然后供 Controller 层来调用。这并不意味着 Controller 中有一个 UpdateUser 处理方法，那么 Service 层中也要有专门的 UpdateUser 方法。更好的方式是将 Service 拆得更细一些，如 UpdateUser 需要依次调用 QueryUser （检查当前用户是否存在）、CheckUserMutationAvaliable （当前用户是否被允许进行信息更新）、UpdateUser （更新用户）、NoticeUserFollowerUpdate （提醒用户的粉丝发生了资料更新）等等数个细粒度的 Service 。这样一来，在未来新增 Controller 时，你只需要重新按照逻辑组装 Service 即可，而不需要再完全重写一个功能大半相似的。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Injectable <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppService</span> <span class="token punctuation">&#123;</span>  <span class="token function">getHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token string">'Hello World!'</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>app.module.ts</code>，这一文件是应用的核心文件，我们需要这一模块才能在 <code>main.ts</code> 中去启动应用。在实际开发中，可能会有多个 <code>.module.ts</code> 文件来实现对业务逻辑的模块拆分，如 <code>user.module.ts</code>、<code>upload.module.ts</code> 等。同时，在这个文件内我们会定义属于这一模块的 Controller 与 Service ，别的模块可以通过导入这个模块来使用内部的 Service ，而不是直接导入 Service 造成模块间的混乱引用。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Module <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> AppController <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./app.controller'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> AppService <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./app.service'</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  imports<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  controllers<span class="token operator">:</span> <span class="token punctuation">[</span>AppController<span class="token punctuation">]</span><span class="token punctuation">,</span>  providers<span class="token operator">:</span> <span class="token punctuation">[</span>AppService<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>main.ts</code>，最终启动的入口文件，在这里我们定义全局级别的应用配置。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> NestFactory <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/core'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> AppModule <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./app.module'</span><span class="token keyword">import</span> chalk <span class="token keyword">from</span> <span class="token string">'chalk'</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">bootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">await</span> NestFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>AppModule<span class="token punctuation">)</span>  <span class="token keyword">await</span> app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">bootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>项目中文件的基本功能就介绍到这里，在扩展阅读部分，我们还会介绍 NestJs 应用中两种不同的目录结构组织方式，如果你感兴趣可以去读一下。接下来，我们来了解本节应用中的另一个重要部分：Prisma ORM。</p><h2 id="Prisma-基础"><a href="#Prisma-基础" class="headerlink" title="Prisma 基础"></a>Prisma 基础</h2><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.prisma.io%2F">Prisma</a> 是一个“比较特殊”的 ORM，为什么这么说呢？我们知道，ORM 库（Object-Relational Mapping），其实就是编程语言到 SQL 的映射，也就是说，我们无需学习 SQL 的使用，直接用最熟悉的代码调用方法，即可与数据库进行交互。</p><p>而 NodeJs 中的 ORM 目前基本都是通过 js / ts 文件进行定义的，比如 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsequelize%2Fsequelize">Sequelize</a>、<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftypeorm%2Ftypeorm">TypeORM</a> 等，均是通过面向对象的方式进行数据库实体的定义：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Entity<span class="token punctuation">,</span> PrimaryGeneratedColumn<span class="token punctuation">,</span> Column <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'typeorm'</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Entity</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">PrimaryGeneratedColumn</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  id<span class="token operator">:</span> <span class="token builtin">number</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Column</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  firstName<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Column</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  lastName<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Column</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是 Prisma 最特殊的一点，它使用自己的 SDL（Schema Define Language，也可以说是 DSL ，Domain-Specified Language）来声明一个实体：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">// This is your Prisma schema file,// learn more about it in the docs: https://pris.ly/d/prisma-schemagenerator client &#123;  provider = "prisma-client-js"  // output   = "./client"&#125;datasource db &#123;  provider = "postgresql"  url      = env("DATABASE_URL")&#125;model Article &#123;  id          Int     @id @default(autoincrement())  title       String?  description String  @default("这篇文章还没有介绍...")  content     String&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如在上面的例子中，我们在 <code>schema.prisma</code> 中使用 Prisma 自己定义的语法来进行描述，可以在 VS Code 中安装扩展来获得语法高亮：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b56cff57141f44c49b0143a7dee88043~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="imaged37616c085b20456.png"></p><p>而不论是用编程语言还是 SDL 来描述数据库实体，都需要有转换到 SQL 的这一步。在传统 ORM 中这一步实时进行，在你调用 <code>user.find()</code> 时动态地进行转换。而在 Prisma 中，这一步则要特殊一些。</p><p>我们在实践中熟悉，首先在项目内初始化 prisma：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npx prisma init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它会为你创建 <code>prisma/schema.prisma</code>、<code>.env</code> 文件，我们还需要安装对应的依赖：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i prisma <span class="token parameter variable">-g</span><span class="token function">npm</span> i @prisma/client --save-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这里，prisma 是 Prisma CLI，而 <code>@prisma/client</code> 则是其运行时所需的依赖。</p><p>在 <code>.env</code> 文件中定义了我们的数据库地址，Prisma 支持基本上所有的主流数据库。后面我们会使用免费的 Heroku 数据库，现在保持不动即可。</p><p>我们先将最终的 Schema 部分填入，然后来解释其中的语法：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">generator client &#123;  provider = "prisma-client-js"&#125;datasource db &#123;  provider = "postgresql"  url      = env("DATABASE_URL")&#125;model Tag &#123;  id          String    @id @default(cuid())  name        String  description String?  Article     Article[]&#125;model Category &#123;  id          String    @id @default(cuid())  name        String  description String?  Article     Article[]&#125;model Article &#123;  id          Int     @id @default(autoincrement())  title       String?  description String  @default("这篇文章还没有介绍...")  content     String  visible     Boolean @default(true)  tag      Tag[]  category Category[]  createdAt DateTime @default(now())  updatedAt DateTime @default(now())&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，<code>generator client</code> 这个部分定义了我们的项目类型与一些 Prisma 配置，既然 Prisma 专门搞了新的 SDL 作为实体声明，那它肯定不会只支持 JavaScript。这里我们将 <code>provider</code> 配置为 <code>prisma-client-js</code>，在后面转换一步时，它就会生成 JS 代码，你才能调用它。<code>datasource db</code> 则定义了数据库的类型与地址，这里我们使用 <code>env()</code> 函数从环境变量中注入定义。</p><p>下面的 model 部分就是数据库的实体定义了，我们定义了 Article、Tag、Category 三个实体，在 Prisma Schema 中内置了一些特殊语法与函数，如 <code>@id</code> 将这一列标记为主键，<code>@default(autoincrement())</code> 意为使用自增主键作为默认值，<code>@default(now())</code> 意为使用创建/修改时的日期作为默认值。</p><p>在 Prisma Schema 中我们可以用非常自然的方式声明关联：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">model Tag &#123;  Article     Article[]&#125;model Category &#123;  Article     Article[]&#125;model Article &#123;  tag      Tag[]  category Category[]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上我们就是声明了 Article-Tag、Article-Category 这两对<strong>多对多</strong>的级联关系。接着，我们来体验下转换，执行以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">prisma generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fde89e7ee8541abbc8695851de1d471~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="imagea1dd0f09cd0c6303.png"></p><p>这里的 Prisma Client 会被生成到 <code>node_modules/@prisma/client</code> 下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce733ab100514fb8ac4bce6f17c3601d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image013d3fbf7ddad47c.png"></p><p>而在实际使用时，我们就需要导入它并实例化：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> PrismaClient <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@prisma/client'</span><span class="token keyword">const</span> prisma <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrismaClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来，你将体验到 Prisma 最大的特色之一：类型安全。我们尝试访问以下 prisma 的属性：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5158276dadf04997bc8553d2405702af~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image749525dface6a1d2.png"></p><p>每一个实体上的每一种方法都有全面覆盖的类型提示，而这背后当然是 prisma generate 命令中由 Prisma Schema 所生成的 TS 类型定义。</p><p>你可能会问，TypeORM 的 TS 支持也很好，为什么我单单说 Prisma 是类型安全的？这是因为在这些基于编程的语言中，类型实际上是我们自己书写的，ORM 由这些定义映射到数据库的过程中并不能保证是安全的。如在 TypeORM 中，一个字段是否可能为空是通过额外的选项 <code>@Column(&#123; nullable: true &#125;)</code> 的方式来声明的。</p><p>而在 Prisma 中，我们通过 Prisma Schema 来描述数据库实体，相比 JavaScript / TypeScript，它无疑更加自然也更贴近 SQL。同时数据库的表结构与 TS 类型定义的生成均基于 Prisma Schema ，这也就保证了表结构与我们实际类型定义的同步。而如果你担心 Prisma 生成的类型不够严谨，可以翻翻看生成的 Prisma Client 代码。如这个例子中我们只有三个实体，共计 16 个字段，Prisma 生成了将近 5000 行的类型定义。</p><p>如果你对 Prisma 产生了兴趣，我此前写过系列文章来详细地介绍 Prisma 的使用，参考 <a href="https://juejin.cn/post/6973277530996342798">Prisma：下一代 ORM，不仅仅是 ORM 上篇</a>、<a href="https://juejin.cn/post/6973950142445518884">下篇</a>。</p><p>关于 Prisma 的工作流程，你可以参考这张图片：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b92e9f7bc66c4dea82b8b911bba8a96e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>接下来，我们要来了解如何在 Nest 中去集成 Prisma，这一步我们不需要任何的集成包，只有非常自然地导入与调用。</p><h3 id="在-NestJs-中集成-Prisma"><a href="#在-NestJs-中集成-Prisma" class="headerlink" title="在 NestJs 中集成 Prisma"></a>在 NestJs 中集成 Prisma</h3><p>在 NestJs 中集成 Prisma 其实也非常简单，秉持着模块化的理念，我们将 Prisma 相关的逻辑单独放到一个模块中。</p><p>新建 <code>prisma.service.ts</code>：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>  Injectable<span class="token punctuation">,</span>  OnApplicationShutdown<span class="token punctuation">,</span>  OnApplicationBootstrap<span class="token punctuation">,</span><span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> PrismaClient <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@prisma/client'</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">PrismaService</span>  <span class="token keyword">extends</span> <span class="token class-name">PrismaClient</span>  <span class="token keyword">implements</span> <span class="token class-name">OnApplicationBootstrap</span><span class="token punctuation">,</span> OnApplicationShutdown<span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">async</span> <span class="token function">onApplicationBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">async</span> <span class="token function">onApplicationShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>onApplicationBootstrap</code> 和 <code>onApplicationShutdown</code> 是 NestJs 提供的应用级生命周期，我们继承 PrismaClient，通过 implements 来实现这两个方法，然后分别在启动与停止阶段与数据库连接、断开连接。</p><p>在前面我们已经提到，Prisma Client 需要被实例化后才能使用。我们这里的 PrismaService 也是，但是如果某一处代码需要使用它，IoC 容器在交给它这个类时就会进行实例化过程。</p><p>然后新建 <code>prisma.module.ts</code>：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Global<span class="token punctuation">,</span> Module <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> PrismaService <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./prisma.service'</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Global</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  providers<span class="token operator">:</span> <span class="token punctuation">[</span>PrismaService<span class="token punctuation">]</span><span class="token punctuation">,</span>  exports<span class="token operator">:</span> <span class="token punctuation">[</span>PrismaService<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">PrismaModule</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过这种方式，Prisma 相关的所有能力都被归纳在这个模块中，后续你还可以继续添加如 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.prisma.io%2Fdocs%2Fconcepts%2Fcomponents%2Fprisma-client%2Fmiddleware">Prisma Middleware</a> 的功能。</p><p>接着别忘了将 Prisma Module 也添加到 AppModule 中：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> PrismaModule <span class="token keyword">from</span> <span class="token string">'./data/prisma.module'</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  imports<span class="token operator">:</span> <span class="token punctuation">[</span>PrismaModule<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，其他地方的 Service 就可以使用 Prisma Service 了！</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> PrismaService <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'../data/prisma.service'</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ArticleService</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> prisma<span class="token operator">:</span> PrismaService<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">async</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Article<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prisma<span class="token punctuation">.</span>article<span class="token punctuation">.</span><span class="token function">findMany</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> res  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还记得我们在前面说到，Prisma 的核心优势之一就是它的类型安全，它会基于 Prisma Schema 生成对应的 TypeScript 类型定义，而我们实际上可以直接复用这些类型。</p><p>新建 <code>src/types/index.ts</code> ，这里会存放项目中的类型定义，在这个项目中我们只需要使用从 Prisma Client 中导出的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> Prisma <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@prisma/client'</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">ArticleCreateInput</span> <span class="token operator">=</span> Prisma<span class="token punctuation">.</span>ArticleCreateInput<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">ArticleUpdateInput</span> <span class="token operator">=</span> Prisma<span class="token punctuation">.</span>ArticleUpdateInput <span class="token operator">&amp;</span>  Prisma<span class="token punctuation">.</span>ArticleWhereUniqueInput<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> Article<span class="token punctuation">,</span> Tag<span class="token punctuation">,</span> Category <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@prisma/client'</span><span class="token comment">// ...类似的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接在代码中使用这些类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> PrismaService <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'../data/prisma.service'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Article<span class="token punctuation">,</span> ArticleCreateInput<span class="token punctuation">,</span> ArticleUpdateInput <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'../types'</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ArticleService</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> prisma<span class="token operator">:</span> PrismaService<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">async</span> <span class="token function">create</span><span class="token punctuation">(</span>createInput<span class="token operator">:</span> ArticleCreateInput<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Article<span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prisma<span class="token punctuation">.</span>article<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      data<span class="token operator">:</span> createInput<span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> res  <span class="token punctuation">&#125;</span>  <span class="token keyword">async</span> <span class="token function">update</span><span class="token punctuation">(</span>updateInput<span class="token operator">:</span> ArticleUpdateInput<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Article<span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prisma<span class="token punctuation">.</span>article<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      data<span class="token operator">:</span> updateInput<span class="token punctuation">,</span>      where<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        id<span class="token operator">:</span> updateInput<span class="token punctuation">.</span>id<span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> res  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>这一节我们学习了 NestJs 框架与 Prisma ORM 的基础概念与使用方式，以及在 NestJs 中集成 Prisma 的方法。相比于其它同类型框架，它们都有着决定性的优势，如 NestJs 的全家桶套餐、Prisma 的类型安全与性能。</p><p>完成了这些前置地知识储备后，下一节我们就将进入正式的开发与部署阶段了。但我们并不会走完整个开发阶段，我更相信授人以渔的教学方式，因此实际开发时我们只会完成一部分开发，走通整个流程。如果这两个框架让你感到有点意思，你就会自驱地完成整个流程开发的，毕竟兴趣才是我们最好的老师。相比于开发部分，我们对部署部分的介绍要更加详细，因为我们将使用 Heroku 平台提供的部署与数据库服务，这对于大部分同学来说都是首次接触。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="NestJs-应用目录结构的不同组织方式"><a href="#NestJs-应用目录结构的不同组织方式" class="headerlink" title="NestJs 应用目录结构的不同组织方式"></a>NestJs 应用目录结构的不同组织方式</h3><p>前面我们介绍了 Controller、Service 等文件的基本功能，除此以外，NestJs 应用中其实存在着两种不同的文件组织风格：按功能与按逻辑进行拆分。</p><p>按功能进行拆分，即我们本节的应用使用的方式，这一方式下的目录结构是这样的：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">project├── src├──── controllers├──── services├──── providers├──── app.module.ts├──── main.ts├── package.json├── nest-cli.json└── tsconfig.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，所有的 Controller 文件都在 <code>/controllers</code> 文件夹下，所有的 Service 文件都在 <code>/services</code> 文件夹下。这一方式适用于项目规模较小的情况，此时无需进行精细的模块化拆分，我们只会有一个 AppModule 。</p><p>而按逻辑进行拆分的目录结构可能是这样的：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">project├── src├──── user├─────── user.controller.ts├─────── user.service.ts├─────── user.module.ts├──── manager├─────── manager.controller.ts├─────── manager.service.ts├─────── manager.module.ts├──── app.module.ts├──── main.ts├── package.json├── nest-cli.json└── tsconfig.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时我们的 Controller、Service 都会被归类到对应业务逻辑的文件夹下，每个业务逻辑拥有自己的 Module ，然后再在 AppModule 中汇总。</p><p>这一方式适合存在一定规模的项目，以及内部业务模块分类较多的情况，此时使用基于逻辑的目录结构划分可以帮助你更好地进行模块拆分，同时获得更直观的模块依赖关系。</p><h3 id="Data-Mapper-与-Active-Record"><a href="#Data-Mapper-与-Active-Record" class="headerlink" title="Data Mapper 与 Active Record"></a>Data Mapper 与 Active Record</h3><p>即使你此前已经有过 ORM 的实践经验，还有两个概念可能是你未了解过的，即 <strong>Data Mapper</strong> 与 <strong>Active Record</strong> 。TypeORM 的简介中提到，<strong><em>TypeORM supports both Active Record and Data Mapper patterns</em></strong>，即它同时支持了这两种模式。那么这两种模式对代码有什么影响，它们的差别又是什么？</p><p>先来看 Active Record 模式下的 TypeORM 代码：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> BaseEntity<span class="token punctuation">,</span> Entity<span class="token punctuation">,</span> PrimaryGeneratedColumn<span class="token punctuation">,</span> Column <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'typeorm'</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Entity</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">extends</span> <span class="token class-name">BaseEntity</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">PrimaryGeneratedColumn</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  id<span class="token operator">:</span> <span class="token builtin">number</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Column</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Column</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  isActive<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span>user<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'不渡'</span>user<span class="token punctuation">.</span>isActive <span class="token operator">=</span> <span class="token boolean">true</span><span class="token keyword">await</span> user<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> newUsers <span class="token operator">=</span> <span class="token keyword">await</span> User<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> isActive<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TypeORM 中，Active Record 模式下需要让实体类继承 <code>BaseEntity</code>类，然后实体类上就具有了各种操作方法，如 <code>save</code> <code>remove</code> <code>find</code>方法等。Active Record 模式最早由 Martin Fowle 在 <strong><em>企业级应用架构模式</em></strong> 一书中命名，即直接在对象上支持相关的 CRUD 方法。</p><p>而 Data Mapper 下的代码则是这样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Entity<span class="token punctuation">,</span> PrimaryGeneratedColumn<span class="token punctuation">,</span> Column <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'typeorm'</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Entity</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">PrimaryGeneratedColumn</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  id<span class="token operator">:</span> <span class="token builtin">number</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Column</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Column</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  isActive<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> userRepository <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">getRepository</span><span class="token punctuation">(</span>User<span class="token punctuation">)</span><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span>user<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'不渡'</span>user<span class="token punctuation">.</span>isActive <span class="token operator">=</span> <span class="token boolean">true</span><span class="token keyword">await</span> userRepository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token keyword">await</span> userRepository<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token keyword">const</span> newUsers <span class="token operator">=</span> <span class="token keyword">await</span> userRepository<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> isActive<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Data Mapper 模式下，实体类不能够自己进行数据库操作，而是需要先获取到一个对应到表的“仓库”，然后再调用这个“仓库”上的方法。</p><p>这一模式同样由 Martin Fowler 前辈最初命名，Data Mapper 就像是一层拦在操作者与实际数据之间的访问层，就如上面例子中，需要先获取具有访问权限（即相应方法）的对象，再进行数据的操作。</p><p>对这两个模式进行比较，很容易发现 Active Record 模式要更加简单，适用于较简单的应用。可以减少很多代码。而 Data Mapper 模式则更加严谨，适用于开发规模较大的应用，一个例子是在 Nest 的 TypeORM 集成包中，也是注入 Repository 实例然后再进行操作的，即也属于 Data Mapper 模式。</p><p>最后，实际上 Prisma 使用的也是 Data Mapper 模式，我们需要 Prisma Client 来作为访问层。</p><h3 id="ORM-与-QueryBuilder"><a href="#ORM-与-QueryBuilder" class="headerlink" title="ORM 与 QueryBuilder"></a>ORM 与 QueryBuilder</h3><p>ORM 并不是唯一一种让我们可以不用写 SQL 就能操作数据库的方式，同时它也不是最贴近 SQL 的方式。</p><p>Query Builder 就是这另外一种使用方式，它和 ORM 一样，通过编程语言书写，但不同的是它并不包括实体类映射到数据库表的部分，而只是负责 Query 。</p><p>以 TypeORM 的 Query Builder 模式为例：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> getConnection <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'typeorm'</span><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">createQueryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">'user'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>User<span class="token punctuation">,</span> <span class="token string">'user'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span><span class="token string">'user.id = :id'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> id<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">getOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这么一连串的链式调用，其实就等价于 <code>userRepo.find(&#123; id: 1 &#125;)</code> 的作用，看起来更麻烦了，但你是否感觉到了灵活性的成倍增长？在 Query Builder 中，，每一次链式调用都会对最终生成的 SQL 产生一些调整，因此我们可以通过非常细粒度的调整来更加的贴近原生 SQL 。</p><p>除了 TypeORM 以外，Node 中使用较多的 Query Builder 还包括 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fknex%2Fknex">knex</a>、<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fkoskimas%2Fkysely">kysely</a> 等。</p><p>关于 Prisma、Query Builder 与 ORM 的比较，可以参考下面这张图片：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/456cfd8784284b5b91c0d19b90f1103b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="comparison"></p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/30.%E5%9F%BA%E4%BA%8E%20Prisma%20+%20NestJs%20%E7%9A%84%20Node%20API%20%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E5%9F%BA%E4%BA%8E%20Heroku%20%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/30.%E5%9F%BA%E4%BA%8E%20Prisma%20+%20NestJs%20%E7%9A%84%20Node%20API%20%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E5%9F%BA%E4%BA%8E%20Heroku%20%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>同时，上一节最开始安装的环境应该差不多了，那我们就来接着了解一下 Heroku 的打开方式。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2Ftiny-book-blog-api">Blog API</a></p></blockquote><h2 id="Heroku-初体验"><a href="#Heroku-初体验" class="headerlink" title="Heroku 初体验"></a>Heroku 初体验</h2><p>前端社区有非常多的免费云服务，它们的作用各不相同，但基本上能找到所有你需要的。比如 Surge 提供了快捷的静态页面部署，Vercel 提供了与 git 服务集成支持的静态页面部署、页面指标统计以及免费的 Serverless 函数（Vercel Functions），Netlify 类似于 Vercel ，但 Serverless 函数是收费的。此外，一些知名框架也提供了自己的云服务（Gatsby Cloud、Nx Cloud 等）来进一步绑定用户。最重要的是，这些服务基本对个人开发者免费，只有需要进行团队协作或者高级功能时才会收费。</p><p>而 Heroku 就是一个提供免费服务的云平台，它主要以提供 API 服务部署为主，支持 Node、Java、Go、Python 等几乎所有主流语言。选择它的主要原因有两方面：一是我认为在类似的平台中它使用起来相对方便；二是它面向个人开发者提供了一定免费额度的数据库（PostgreSQL）。唯一存在遗憾的地方是，它需要科学上网才能正常访问。</p><p>好了，基本信息介绍完了，接下来我们正式开始体验吧！</p><p>最开始当然是注册环节，访问 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.heroku.com%2F">Heroku 主页</a>，按照要求填写信息：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3472b1da0ad4e83b172de9459ce8f89~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>在登录时，如果提示需要 Multi-Factor Auth，可以选择先跳过。完成登录后，它会将你重定向到应用管理页面：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d110619004e4206970b09f5ccc58352~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>点击右上角的新建，选择创建一个新应用，应用名需要是独一无二的：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bf682717ec8459d80cdd4d6b30dc8ad~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>创建成功后，我们会来到应用界面，以我们已经创建完毕的页面为例：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71d6ff9e4d094f039b8b02ffbfd6e19a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>点击 Deploy，我们需要把应用和 github 仓库关联起来，这样就能在每次提交时自动重新部署了：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a417cbbef4d42d79a8ba9ed7bed5db5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>首先选择 Connect to GitHub，授权完毕后选择你对应的仓库，配置完毕后你会看到这样的界面：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bafba9bd4745406f81ad9816ad252b32~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>点击 Enable Automatic Deploys 后，我们的应用就会随着每次 Git 提交而重新部署。</p><p>另外，我们此前的环境配置其实就是安装了 Heroku 的 CLI ，现在我们需要通过 CLI 在终端也登录上：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09019473d3624134ac5b364846e27855~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>这里我们不能直接运行 heroku login，因为你现在大概率是通过代理访问的，会出现 IP 地址不匹配的错误，我们需要使用 auth token 进行登录。来到 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdashboard.heroku.com%2Faccount%2Fapplications">全局设置</a> 页面，找到授权：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfed83b21e3343fe8b018d00d118102f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>点击创建一个新的 token，复制它，回到终端运行 <code>heroku login -i</code>，账号名输入你的邮箱，密码输入 token，确认登录：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c40b8f03ce8412fb6afbeed2238ef09~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>同时我们仍然可以将 Heroku 的仓库添加为一个单独的远程仓库，这么做的原因是我们可以先 push 到 Heroku 的远程仓库来进行构建与部署的测试，等测试验证完毕了再推送到 GitHub，运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">heroku git:remote <span class="token parameter variable">-a</span> <span class="token operator">&lt;</span>你的应用名<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/218f581028b44df8b3708a5093c64ec1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>接下来我们需要申请一个可用的数据库，数据库、监控、负载均衡、Redis 等功能在 Heroku 上被称为 add-on ，你可以访问 <a href="https://link.juejin.cn/?target=https%3A%2F%2Felements.heroku.com%2Faddons">add-on 市场</a> 查看更多。在这里我们直奔 <a href="https://link.juejin.cn/?target=https%3A%2F%2Felements.heroku.com%2Faddons%2Fheroku-postgresql">heroku-postgresql</a>：</p><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.imagehub.cc%2Fimage%2FGfiN6y"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ccf72af7f4f408580d4c977f48d7fa3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image380be9c6e463109c.png"></a></p><p>点击安装，将安装到我们的应用中：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b87bc3e13a0450d9c9c0785a97e83dc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be4728eb4e8d4501aa0d753c675e715d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>数据库的链接会被以环境变量 <code>process.env.DATABASE_URL</code>注入进来，来到应用配置页面，点击显示环境变量：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b32f3cf2e9154e68a3aa71a3f16f6e7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="imagee38ce6a381dc9b3b.png"></p><p>有了数据库地址，接下来我们就可以在本地应用里去连接到数据库了。</p><h2 id="连接到-Heroku-数据库"><a href="#连接到-Heroku-数据库" class="headerlink" title="连接到 Heroku 数据库"></a>连接到 Heroku 数据库</h2><p>首先，在你本地的 <code>.env</code> 文件中修改 <code>DATABASE_URL</code>：</p><pre class="line-numbers language-ini" data-language="ini"><code class="language-ini"><span class="token key attr-name">DATABASE_URL</span><span class="token punctuation">=</span><span class="token value attr-value">"<span class="token inner-value">postgres://...</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">prisma db push<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一命令会将我们此前定义的 Prisma Schema 推送到数据库，创建对应的数据表。同时这一命令也会再次执行 <code>prisma generate</code> 命令来生成 Prisma Client：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2d399ff45334686980f119b2e9c6f3b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="imagedb88d65589f9bb99.png"></p><blockquote><p>通常来说，数据库也会按照环境分为日常、预发、生产、测试等多个版本，但谁让我们只是在写 demo 呢？</p></blockquote><p>上一节我们已经介绍了如何在 NestJs 中使用 Prisma ，也完成了相关配置，现在我们可以真正连接到数据库试用一下了。</p><p>创建 <code>seed.controller.ts</code> 文件，在其中添加对 service 的实际调用：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Controller<span class="token punctuation">,</span> Get <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ArticleService <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'../services/article.service'</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Controller</span></span><span class="token punctuation">(</span><span class="token string">'/seed'</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">SeedController</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">readonly</span> articleService<span class="token operator">:</span> ArticleService<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token string">'/create'</span><span class="token punctuation">)</span>  <span class="token keyword">async</span> <span class="token function">seed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>articleService<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      title<span class="token operator">:</span> <span class="token string">'Article 1'</span><span class="token punctuation">,</span>      content<span class="token operator">:</span> <span class="token string">'Content 1'</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>articleService<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      title<span class="token operator">:</span> <span class="token string">'Article 2'</span><span class="token punctuation">,</span>      content<span class="token operator">:</span> <span class="token string">'Content 2'</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>articleService<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      title<span class="token operator">:</span> <span class="token string">'Article 3'</span><span class="token punctuation">,</span>      content<span class="token operator">:</span> <span class="token string">'Content 3'</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>articleService<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>别忘了把 SeedController 添加到 AppModule 中：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Module <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token keyword">import</span> PrismaModule <span class="token keyword">from</span> <span class="token string">'./data/prisma.module'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> SeedController <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./controllers/seed.controller'</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  imports<span class="token operator">:</span> <span class="token punctuation">[</span>PrismaModule<span class="token punctuation">]</span><span class="token punctuation">,</span>  controllers<span class="token operator">:</span> <span class="token punctuation">[</span>SeedController<span class="token punctuation">]</span><span class="token punctuation">,</span>  providers<span class="token operator">:</span> <span class="token punctuation">[</span>ArticleService<span class="token punctuation">,</span> CategoryService<span class="token punctuation">,</span> TagService<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在访问 <a href="https://link.juejin.cn/?target=http%3A%2F%2Flocalhost%3A3000%2Fseed%2Fcreate">http://localhost:3000/seed/create</a> ，会发现已经有响应了：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da58905298d5482984b597c991bf3dda~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="imagee102f1b42e36a82b.png"></p><h2 id="初次部署"><a href="#初次部署" class="headerlink" title="初次部署"></a>初次部署</h2><p>万事俱备，我们现在可以把应用部署到 Heroku 上了。但也别太急，我们的应用还需要进行一些额外的配置才能在 Heroku 上正常的工作。</p><p>首先是更改应用的端口号，Heroku 在部署这个应用时，会随机分配一个端口号，我们的应用需要使用这个端口号来启动，而这个端口号会通过环境变量的方式提供。</p><p>修改 <code>src/main.ts</code>：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">bootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ...</span>  <span class="token keyword">const</span> <span class="token constant">PORT</span> <span class="token operator">=</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">PORT</span> <span class="token operator">??</span> <span class="token number">3000</span>  <span class="token keyword">await</span> app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token constant">PORT</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Heroku 在启动这个项目时，默认使用的是 <code>npm start</code> 命令，而在我们的项目中这一命令其实是开发环境下的启动，<code>npm run start:prod</code> 才是基于构建后代码的启动。因此，我们需要告诉 Heroku 使用这一 script 启动，通常云平台们都支持了项目内的配置文件，如 <code>vercel.json</code>、<code>netlify.toml</code> ，而 Heroku 的配置文件则要特殊一些，它的名字叫 <code>Procfile</code>，注意，没有文件扩展名。</p><p>写入内容到 <code>Procile</code> 中：</p><pre class="line-numbers language-ini" data-language="ini"><code class="language-ini">web: npm run start:prod<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还有最后一步，由于 Prisma 需要有一步 generate 命令，代码内才能访问到 Prisma Client，而在默认的构建过程中自然是不会有这一步的。因此，我们需要通过 <code>postinstall</code> 这个会在安装过程后执行的 npm script ，在其中调用 generate：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"postinstall"</span><span class="token operator">:</span> <span class="token string">"npm run prisma:gen"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你也可以在 <code>postbuild</code> 或别的步骤进行，只要确保在启动应用前执行了 prisma generate 即可。</p><p>现在才是真正的万事具备，我们可以启动项目了。这一过程我们通常会用到两个命令。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> push heroku main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你已经连接到了 GitHub，其实直接推送 GitHub 仓库即可。但这一命令的主要作用是会展示 Heroku 接收到推送以后，拉取代码、安装依赖、构建以及启动过程：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6025bda33b8a4709a9b4dba1b129d064~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="imagef0c3c4a1ded5150f.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c756e5dd4e134fca9cfd32935f70cd1a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="imagea22f61b473e93e2c.png"></p><p>你会发现，似乎缺少了应用程序启动的日志？这时候就需要使用另一个命令了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">heroku logs <span class="token parameter variable">--tail</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>logs 命令用于展示这个应用运行过程中的日志，包括 Heroku 的系统日志与我们的应用程序日志。而 <code>--tail</code> 参数意为仅展示最新的一部分日志：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f3ea4d8ac65437a9c80090698003514~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image752c0cd8664a87c4.png"></p><p>这一命令会占据当前的端口，实时展示最新的日志，因此在开发阶段可以通过它来进行调试应用。</p><p>至此，我们的应用就已经部署完毕了，接下来基本上就不需要再在 Heroku 上进行什么配置了。最后需要注意的是，如果你的应用一段时间都没有任何流量，Heroku 会暂时停止掉这个服务，并在下一次有流量访问时再启动，这一过程一般耗时不会太久。而如果你在本地访问数据库出现了连接失败，原因也是因为其关联的应用被暂停，资源被暂时回收了。</p><h2 id="API-开发"><a href="#API-开发" class="headerlink" title="API 开发"></a>API 开发</h2><p>终于到了 API 开发环节，但这一部分的内容反倒最简短。我们并不会把每一个实体（文章、标签、分类）的方法都实现完，因为如果你已经有过类似的开发经验，那这些内容对你来说意义不大，而如果你此前并无相关开发经验，更需要自己动手来试一试。</p><p>这里就以 Article 相关的操作为例，我们会实现全量查找、基于 ID 的查找、创建、更新这四个接口。在这个过程中，你会了解到 NestJs 最基本的使用，即路由处理与请求参数。</p><p>首先你需要确保已经完成了 Prisma Client 的生成与数据库同步，我们最终的 Prisma Schema 如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">// This is your Prisma schema file,// learn more about it in the docs: https://pris.ly/d/prisma-schemagenerator client &#123;  provider = "prisma-client-js"&#125;datasource db &#123;  provider = "postgresql"  url      = env("DATABASE_URL")&#125;// 文章的标签，如 TS / Node / React / SSR 等model Tag &#123;  id          String    @id @default(cuid())  name        String  description String?  Article     Article[]&#125;// 文章的分类，如 技术 / 感想 / 总结 等model Category &#123;  id          String    @id @default(cuid())  name        String  description String?  Article     Article[]&#125;model Article &#123;  id          Int     @id @default(autoincrement())  title       String?  description String  @default("这篇文章还没有介绍...")  content     String  // 文章是否可见  visible Boolean @default(true)  tag      Tag[]  category Category[]  createdAt DateTime @default(now())  updatedAt DateTime @default(now())&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先是 Service 层，我们在这里会从数据库取回数据然后进行返回，但一般我们不会直接丢个数据回去，而是会附带上状态码等信息一起返回。这里我们实现一个简单的版本：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> MaybeNull <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'../types'</span><span class="token keyword">export</span> <span class="token keyword">enum</span> StatusCode <span class="token punctuation">&#123;</span>  <span class="token constant">RESOLVED</span> <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">,</span>  <span class="token constant">REJECTED</span> <span class="token operator">=</span> <span class="token number">10001</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ResponseWrapper<span class="token operator">&lt;</span>TData <span class="token operator">=</span> <span class="token builtin">any</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>    <span class="token keyword">public</span> statusCode<span class="token operator">:</span> StatusCode<span class="token punctuation">,</span>    <span class="token keyword">public</span> data<span class="token operator">:</span> TData<span class="token punctuation">,</span>    <span class="token keyword">public</span> message<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>statusCode <span class="token operator">=</span> statusCode    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data    <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span>      message <span class="token operator">??</span> statusCode <span class="token operator">===</span> StatusCode<span class="token punctuation">.</span><span class="token constant">RESOLVED</span> <span class="token operator">?</span> <span class="token string">'Success'</span> <span class="token operator">:</span> <span class="token string">'Failed'</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从简起见，我们不想每次使用这个类时都标记状态。因为我们总共就两种状态，所以可以提前准备好成功与失败的响应修饰：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ResolvedResponse<span class="token operator">&lt;</span>TData <span class="token operator">=</span> <span class="token builtin">any</span><span class="token operator">></span></span> <span class="token keyword">extends</span> <span class="token class-name">ResponseWrapper</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> data<span class="token operator">:</span> TData<span class="token punctuation">,</span> <span class="token keyword">public</span> message<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>StatusCode<span class="token punctuation">.</span><span class="token constant">RESOLVED</span><span class="token punctuation">,</span> data<span class="token punctuation">,</span> message<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">RejectedResponse<span class="token operator">&lt;</span>TData <span class="token operator">=</span> <span class="token builtin">any</span><span class="token operator">></span></span> <span class="token keyword">extends</span> <span class="token class-name">ResponseWrapper</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> data<span class="token operator">:</span> TData<span class="token punctuation">,</span> <span class="token keyword">public</span> message<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>StatusCode<span class="token punctuation">.</span><span class="token constant">REJECTED</span><span class="token punctuation">,</span> data<span class="token punctuation">,</span> message<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成功时使用 ResolvedResponse，数据为空或出现异常时使用 RejectedResponse，你也可以进行更进一步的拆分，如让参数校验失败、数据为空、鉴权失败等等都有专用的 RejectedResponse。</p><p>从创建开始，我们直接调用注入好的 Prisma Client 即可：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Injectable <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> PrismaService <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'../data/prisma.service'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>  ResolvedResponse<span class="token punctuation">,</span>  RejectedResponse<span class="token punctuation">,</span>  ResponseUnion<span class="token punctuation">,</span><span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'../utils/response-wrapper.provider'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Article<span class="token punctuation">,</span> ArticleCreateInput<span class="token punctuation">,</span> ArticleUpdateInput <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'../types'</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ArticleService</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> prisma<span class="token operator">:</span> PrismaService<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">async</span> <span class="token function">create</span><span class="token punctuation">(</span>createInput<span class="token operator">:</span> ArticleCreateInput<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prisma<span class="token punctuation">.</span>article<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        data<span class="token operator">:</span> createInput<span class="token punctuation">,</span>        include<span class="token operator">:</span> <span class="token punctuation">&#123;</span>          category<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>          tag<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResolvedResponse</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RejectedResponse</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里的 include 配置意为我们希望<strong>在查询时连带返回所有文章的标签与分类信息</strong>。</p></blockquote><p>我们直接使用 Prisma 生成的 ArticleCreateInput 作为类型，但这里你会发现出现了一个类型报错：<strong><em>如果没有引用 “node_modules/.prisma/client”，则无法命名 “create” 的推断类型。这很可能不可移植。需要类型注释。</em></strong></p><p>这是因为我们消费的 ArticleCreateInput 类型来自于 Prisma Client，TS 无法直接使用这个类型为 create 方法完成类型推导，同时我们又多了 ResolvedResponse 这一层。</p><p>为了解决这一问题，我们声明一个通用的响应类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">ResponseUnion<span class="token operator">&lt;</span>TData<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>  ResolvedResponse<span class="token operator">&lt;</span>MaybeNull<span class="token operator">&lt;</span>TData<span class="token operator">>></span> <span class="token operator">|</span> RejectedResponse<span class="token operator">&lt;</span>MaybeNull<span class="token operator">&lt;</span>TData<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后作为返回值类型使用：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ArticleService</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> prisma<span class="token operator">:</span> PrismaService<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">async</span> <span class="token function">create</span><span class="token punctuation">(</span>createInput<span class="token operator">:</span> ArticleCreateInput<span class="token punctuation">)</span><span class="token operator">:</span> ResponseUnion<span class="token operator">&lt;</span>Article<span class="token operator">></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而在更新方法中，我们需要先基于 ID 检查这一条记录是否存在，且仅在存在时才进行更新：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ArticleService</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> prisma<span class="token operator">:</span> PrismaService<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">async</span> <span class="token function">update</span><span class="token punctuation">(</span>updateInput<span class="token operator">:</span> ArticleUpdateInput<span class="token punctuation">)</span><span class="token operator">:</span> ResponseUnion<span class="token operator">&lt;</span>Article<span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> id <span class="token punctuation">&#125;</span> <span class="token operator">=</span> updateInput    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> record <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prisma<span class="token punctuation">.</span>article<span class="token punctuation">.</span><span class="token function">findUnique</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        where<span class="token operator">:</span> <span class="token punctuation">&#123;</span> id <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        include<span class="token operator">:</span> <span class="token punctuation">&#123;</span>          category<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>          tag<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>record<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RejectedResponse</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prisma<span class="token punctuation">.</span>article<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        where<span class="token operator">:</span> <span class="token punctuation">&#123;</span> id <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        data<span class="token operator">:</span> updateInput<span class="token punctuation">,</span>        include<span class="token operator">:</span> <span class="token punctuation">&#123;</span>          category<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>          tag<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResolvedResponse</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RejectedResponse</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果你希望在更新记录不存在时创建一条记录，可以使用 prisma 的 upsert 方法。</p></blockquote><p>查询接口中，我们希望实现全量查询和基于 ID 查询两个版本：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ArticleService</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> prisma<span class="token operator">:</span> PrismaService<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">async</span> <span class="token function">queryRecords</span><span class="token punctuation">(</span>    includeInvisible<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">false</span>  <span class="token punctuation">)</span><span class="token operator">:</span> ResponseUnion<span class="token operator">&lt;</span>Article<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prisma<span class="token punctuation">.</span>article<span class="token punctuation">.</span><span class="token function">findMany</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        where<span class="token operator">:</span> includeInvisible          <span class="token operator">?</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>          <span class="token operator">:</span> <span class="token punctuation">&#123;</span>              visible<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        include<span class="token operator">:</span> <span class="token punctuation">&#123;</span>          category<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>          tag<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResolvedResponse</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RejectedResponse</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">async</span> <span class="token function">querySingleRecord</span><span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> ResponseUnion<span class="token operator">&lt;</span>Article<span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prisma<span class="token punctuation">.</span>article<span class="token punctuation">.</span><span class="token function">findUnique</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        where<span class="token operator">:</span> <span class="token punctuation">&#123;</span> id <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        include<span class="token operator">:</span> <span class="token punctuation">&#123;</span>          category<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>          tag<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResolvedResponse</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RejectedResponse</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在全量查询中，我们支持了通过 includeVisible 选项进行过滤，而在单条查询中则不会进行过滤。</p><p>完成了 Service 后，Controller 其实就简单多了，我们通常会在这里进行鉴权、校验参数、限流拦截等操作，但现在我们只需要简单地调用 Service 即可。</p><p>创建与更新比较类似，我们放在一起看：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">MaybeArray<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Controller</span></span><span class="token punctuation">(</span><span class="token string">'/article'</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ArticleController</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">readonly</span> articleService<span class="token operator">:</span> ArticleService<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Post</span></span><span class="token punctuation">(</span><span class="token string">'/create'</span><span class="token punctuation">)</span>  <span class="token keyword">async</span> <span class="token function">create</span><span class="token punctuation">(</span>    <span class="token decorator"><span class="token at operator">@</span><span class="token function">Body</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> createInput<span class="token operator">:</span> ArticleCreateInput  <span class="token punctuation">)</span><span class="token operator">:</span> ResponseUnion<span class="token operator">&lt;</span>Article<span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>articleService<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>createInput<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Post</span></span><span class="token punctuation">(</span><span class="token string">'/update'</span><span class="token punctuation">)</span>  <span class="token keyword">async</span> <span class="token function">update</span><span class="token punctuation">(</span>    <span class="token decorator"><span class="token at operator">@</span><span class="token function">Body</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> updateInput<span class="token operator">:</span> ArticleUpdateInput  <span class="token punctuation">)</span><span class="token operator">:</span> ResponseUnion<span class="token operator">&lt;</span>Article<span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>articleService<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>updateInput<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>@Post</code> 声明了此接口需要通过 POST 方法访问，而通过 <code>@Body</code> 装饰器我们将请求携带的 Body 数据注入（<code>req.body</code>），然后直接传给对应的 Service 即可。</p><p>对于查询接口，我们通常使用 GET 方法访问，以及使用 URL 来传参，如 <code>/user/599</code> <code>/user?id=599</code> 两种常见方式。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Controller</span></span><span class="token punctuation">(</span><span class="token string">'/article'</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ArticleController</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">readonly</span> articleService<span class="token operator">:</span> ArticleService<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>  <span class="token keyword">async</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> ResponseUnion<span class="token operator">&lt;</span>Article<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>articleService<span class="token punctuation">.</span><span class="token function">queryRecords</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token string">'/:id'</span><span class="token punctuation">)</span>  <span class="token keyword">async</span> <span class="token function">queryById</span><span class="token punctuation">(</span>    <span class="token decorator"><span class="token at operator">@</span><span class="token function">Param</span></span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span> ParseIntPipe<span class="token punctuation">)</span> id<span class="token operator">:</span> <span class="token builtin">number</span>  <span class="token punctuation">)</span><span class="token operator">:</span> ResponseUnion<span class="token operator">&lt;</span>MaybeArray<span class="token operator">&lt;</span>Article<span class="token operator">>></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>articleService<span class="token punctuation">.</span><span class="token function">querySingleRecord</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们通过 <code>@Param</code> 注入 <code>@Get(&#39;/:id&#39;)</code> 中的 id 参数，由于这一解构出来的值会是字符串，而我们的结构定义中 id 为数字，因此需要使用 ParseIntPipe 来将其转化为数字类型。</p><p>最后，我们使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.apifox.cn%2F">Apifox</a> 来进行接口的调试，你也可以使用任意习惯的工具：</p><p><code>POST /article/create</code>：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7314b443ae7b47c3872633790b054945~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><code>GET /article</code>：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37eb9b4838754c41b4b197a87ceec6eb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><code>GET /article?id=20</code>：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5a7fc13bdce46f49738b00c7f7f2c8d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><code>POST /article/update</code>：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31fc1d35f6cd4dd9a524dbf2d90f16ed~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>完成了 Article 部分的开发仅仅只是开始，毕竟分类和标签也必不可少。但授人以鱼不如授人以渔，有了这一节的基础，再配合 NestJs 与 Prisma 事无巨细的官方文档，你完全可以独立完成剩下的部分。</p><p>好了，完成了以上代码后，你可以直接运行 <code>git push</code>，Heroku 会自动使用最新的代码进行部署。</p><p>除了业务逻辑开发以外，其实你也可以关注更多的功能部分，在 NestJs 中你可以找到校验、中间件、文件上传、日志、定时任务、缓存、限流等等功能，不妨试着把这些功能都加到这个 API 里！</p><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>通过这两节的学习，我们从 0 开发并部署了一个 Node API 到 Heroku 平台上。如果你此前未接触过 Nest 和 Prisma ，那最大的收获其实是学习了目前功能最全面的 NodeJs 框架 Nest ，以及下一代 ORM 工具 Prisma 的基本使用。同时，我们也学习了如何使用 Heroku 作为云端应用平台，它其实非常适合个人小项目开发，毕竟它提供了包括 CI 集成、数据库、监控、热更新、负载均衡以及域名服务等等基础设施。</p><p>小册到这里已经接近了尾声，下一节也就是最后一节，我们会来了解 TypeScript 中的 Compiler API 使用，我们将换一个方式来“用” TypeScript，其他的就不剧透啦。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>31.玩转 TypeScript AST：AST Checker 与 CodeMod</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/31.%E7%8E%A9%E8%BD%AC%20TypeScript%20AST%EF%BC%9AAST%20Checker%20%E4%B8%8E%20CodeMod/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/31.%E7%8E%A9%E8%BD%AC%20TypeScript%20AST%EF%BC%9AAST%20Checker%20%E4%B8%8E%20CodeMod/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识：Babel-的基本工作流程"><a href="#前置知识：Babel-的基本工作流程" class="headerlink" title="前置知识：Babel 的基本工作流程"></a>前置知识：Babel 的基本工作流程</h2><p>在本节的最开始，我有必要郑重说明下，我本身并不是科班出身，没有系统学习过编译原理，以下涉及编译原理的概念大部分来自于在社区的学习所得，也欢迎你指出其中的错误，我将认真对待并修正。</p><blockquote><p>本节原本是被作为短小精悍的漫谈篇呈现的，但有部分同学反馈对这部分知识确实有刚需，因此进行了大量内容扩充后加入到正文篇中。</p></blockquote><p>对大部分前端同学来说，提到编译原理第一时间想到的就是 Babel，即使你没有直接使用过它，也一定间接地接触过，不论是已经搭建好的项目还是更底层的 Webpack 与 Babel Loader 。</p><p>而 Babel 的作用你应该也至少了解过一些，其实它的核心功能就是<strong>语法降级</strong>。是的，就是 TypeScript 在编译时会进行的类型擦除与语法降级中的那个语法降级，Babel 的曾用名是 6to5，意为将 ES6 代码转换为 ES5 代码。这是因为，当时 ES6 已经算是时代的弄潮儿了，很多浏览器还无法完全支持其中的特性，这就需要 Babel 将其转换为能够在更低版本的浏览器上运行的代码。而它现在的这个名字，意为巴别塔，是圣经中记载的一座通天之塔，当时的人们只有一种语言，彼此之间精诚合作，尝试联合起来建立起通往天堂的高塔，而上帝为了阻止这一行动，让人类之间使用不同的语言，彼此之间无法沟通，而计划最终自然失败。Babel 使用这一名字，正是为了更好地宣告自己的使命：<strong>让所有各不相同的 JavaScript 语法，最终都能转换为能在相同环境下直接运行的代码</strong>。</p><p>可你是否了解 Babel 的工作流程？</p><p>从功能角度，Babel 的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel">源码</a>大致可以分为这么几个部分：</p><ul><li><p>核心部分，包括 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Fblob%2Fmain%2Fpackages%2Fbabel-parser%2FREADME.md">Parser</a>、<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Ftree%2Fmain%2Fpackages%2Fbabel-traverse">Transformer</a> 以及 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Ftree%2Fmain%2Fpackages%2Fbabel-generator">Generator</a>，它们主要负责对源码的解析、转换以及生成等工作。一份源码首先会被 Parser 通过词法分析与语法分析，转换为 AST，也就是抽象语法树的形式，然后由 Transformer 对这棵语法树上的 AST 结点进行遍历处理，比如将所有的函数声明转换为函数表达式，最后由 Generator 基于处理完毕的 AST 结点转换出新的代码，就实现了语法的降级。</p><p>AST 其实就是将代码的每个部分进行拆分，得到一棵树形的结构表示，你可以在 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fastexplorer.net%2F">AST Explorer</a> 上，实时查看一段代码转换完毕的 AST 结构。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8edd8090919144b19d9c2fd605cdfc2d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p></li><li><p>插件相关，如 <code>babel-plugin-syntax-jsx</code> <code>babel-plugin-transform-for-of</code> 以及 <code>babel-plugin-proposal-decorators</code> 等，上面的核心部分只包括最简单的处理逻辑，如果你想转换 JSX 代码，想将 for…of 降级为 for 循环，想使用装饰器等语法，就需要这些插件来支持，这些插件其实就是遍历 AST 时，对目标的 AST 结点注册处理逻辑。一般来说一个插件只会关注一种特定的语法。当然，每个浏览器支持的语法版本都是差异巨大的，因此我们需要 <code>babel-preset-env</code>，自动地基于浏览器版本去确定需要使用的插件。</p></li></ul><p>除了依赖 Babel Loader 这样的工具来进行源码的转换以外，其实你也可以使用 <code>@babel/core</code>，来编程式地调用 Babel 的 Compiler API ，并对应地配置插件、预设等等。</p><p>可以看到，在工作流程中其实有一样东西贯穿了整个过程，那就是 AST 。而这也是我们本节所关注的：如何玩转 TypeScript 的 AST。</p><h2 id="使用-TypeScript-Compiler-API"><a href="#使用-TypeScript-Compiler-API" class="headerlink" title="使用 TypeScript Compiler API"></a>使用 TypeScript Compiler API</h2><p>编译处理 TypeScript 代码，我们其实仍然可以使用 Babel，但实际上 TypeScript 本身就将几乎所有 Compiler API 都暴露了出来，也就是说如果你希望更贴近 tsc 的行为，其实更应该使用 TypeScript Compiler API 。</p><p>然而相比 Babel，TS Compiler API 的使用成本要高一些。我们直接看一个官方例子的精简版本，大致感受下其使用方式即可：</p><blockquote><p>由于本节的重点并不是详细介绍 Compiler API 的使用，因此并不会对其进行非常详细介绍。</p></blockquote><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> ts <span class="token keyword">from</span> <span class="token string">'typescript'</span><span class="token keyword">function</span> <span class="token function">makeFactorialFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 创建代表函数名 factorial 的 Identifier 结点</span>  <span class="token keyword">const</span> functionName <span class="token operator">=</span> ts<span class="token punctuation">.</span>factory<span class="token punctuation">.</span><span class="token function">createIdentifier</span><span class="token punctuation">(</span><span class="token string">'factorial'</span><span class="token punctuation">)</span>  <span class="token comment">// 创建代表参数名 n 的 Identifier 结点</span>  <span class="token keyword">const</span> paramName <span class="token operator">=</span> ts<span class="token punctuation">.</span>factory<span class="token punctuation">.</span><span class="token function">createIdentifier</span><span class="token punctuation">(</span><span class="token string">'n'</span><span class="token punctuation">)</span>  <span class="token comment">// 创建参数类型结点</span>  <span class="token keyword">const</span> paramType <span class="token operator">=</span> ts<span class="token punctuation">.</span>factory<span class="token punctuation">.</span><span class="token function">createKeywordTypeNode</span><span class="token punctuation">(</span>    ts<span class="token punctuation">.</span>SyntaxKind<span class="token punctuation">.</span>NumberKeyword  <span class="token punctuation">)</span>  <span class="token comment">// 创建参数的声明</span>  <span class="token keyword">const</span> parameter <span class="token operator">=</span> ts<span class="token punctuation">.</span>factory<span class="token punctuation">.</span><span class="token function">createParameterDeclaration</span><span class="token punctuation">(</span>    <span class="token keyword">undefined</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token keyword">undefined</span><span class="token punctuation">,</span>    paramName<span class="token punctuation">,</span>    <span class="token keyword">undefined</span><span class="token punctuation">,</span>    paramType  <span class="token punctuation">)</span>  <span class="token comment">// 创建表达式 n ≤ 1</span>  <span class="token keyword">const</span> condition <span class="token operator">=</span> ts<span class="token punctuation">.</span>factory<span class="token punctuation">.</span><span class="token function">createBinaryExpression</span><span class="token punctuation">(</span>    <span class="token comment">// n</span>    paramName<span class="token punctuation">,</span>    <span class="token comment">// ≤</span>    ts<span class="token punctuation">.</span>SyntaxKind<span class="token punctuation">.</span>LessThanEqualsToken<span class="token punctuation">,</span>    <span class="token comment">// 1</span>    ts<span class="token punctuation">.</span>factory<span class="token punctuation">.</span><span class="token function">createNumericLiteral</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span>  <span class="token comment">// 创建代码块</span>  <span class="token keyword">const</span> ifBody <span class="token operator">=</span> ts<span class="token punctuation">.</span>factory<span class="token punctuation">.</span><span class="token function">createBlock</span><span class="token punctuation">(</span>    <span class="token comment">// 创建代码块内的返回语句</span>    <span class="token punctuation">[</span>ts<span class="token punctuation">.</span>factory<span class="token punctuation">.</span><span class="token function">createReturnStatement</span><span class="token punctuation">(</span>ts<span class="token punctuation">.</span>factory<span class="token punctuation">.</span><span class="token function">createNumericLiteral</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token boolean">true</span>  <span class="token punctuation">)</span>  <span class="token comment">// 创建表达式 n - 1</span>  <span class="token keyword">const</span> decrementedArg <span class="token operator">=</span> ts<span class="token punctuation">.</span>factory<span class="token punctuation">.</span><span class="token function">createBinaryExpression</span><span class="token punctuation">(</span>    paramName<span class="token punctuation">,</span>    ts<span class="token punctuation">.</span>SyntaxKind<span class="token punctuation">.</span>MinusToken<span class="token punctuation">,</span>    ts<span class="token punctuation">.</span>factory<span class="token punctuation">.</span><span class="token function">createNumericLiteral</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span>  <span class="token comment">// 创建表达式 n * factorial(n - 1)</span>  <span class="token keyword">const</span> recurse <span class="token operator">=</span> ts<span class="token punctuation">.</span>factory<span class="token punctuation">.</span><span class="token function">createBinaryExpression</span><span class="token punctuation">(</span>    paramName<span class="token punctuation">,</span>    ts<span class="token punctuation">.</span>SyntaxKind<span class="token punctuation">.</span>AsteriskToken<span class="token punctuation">,</span>    <span class="token comment">// 创建函数调用表达式</span>    ts<span class="token punctuation">.</span>factory<span class="token punctuation">.</span><span class="token function">createCallExpression</span><span class="token punctuation">(</span>functionName<span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>decrementedArg<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span>  <span class="token keyword">const</span> statements <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token comment">// 创建 IF 语句</span>    ts<span class="token punctuation">.</span>factory<span class="token punctuation">.</span><span class="token function">createIfStatement</span><span class="token punctuation">(</span>condition<span class="token punctuation">,</span> ifBody<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// 创建 return 语句</span>    ts<span class="token punctuation">.</span>factory<span class="token punctuation">.</span><span class="token function">createReturnStatement</span><span class="token punctuation">(</span>recurse<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span>  <span class="token comment">// 创建函数声明</span>  <span class="token keyword">return</span> ts<span class="token punctuation">.</span>factory<span class="token punctuation">.</span><span class="token function">createFunctionDeclaration</span><span class="token punctuation">(</span>    <span class="token keyword">undefined</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span>ts<span class="token punctuation">.</span>factory<span class="token punctuation">.</span><span class="token function">createToken</span><span class="token punctuation">(</span>ts<span class="token punctuation">.</span>SyntaxKind<span class="token punctuation">.</span>ExportKeyword<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token keyword">undefined</span><span class="token punctuation">,</span>    functionName<span class="token punctuation">,</span>    <span class="token keyword">undefined</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span>parameter<span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token comment">// 函数返回值类型</span>    ts<span class="token punctuation">.</span>factory<span class="token punctuation">.</span><span class="token function">createKeywordTypeNode</span><span class="token punctuation">(</span>ts<span class="token punctuation">.</span>SyntaxKind<span class="token punctuation">.</span>NumberKeyword<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// 函数体</span>    ts<span class="token punctuation">.</span>factory<span class="token punctuation">.</span><span class="token function">createBlock</span><span class="token punctuation">(</span>statements<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 创建一个虚拟的源文件</span><span class="token keyword">const</span> resultFile <span class="token operator">=</span> ts<span class="token punctuation">.</span><span class="token function">createSourceFile</span><span class="token punctuation">(</span>  <span class="token string">'./source.ts'</span><span class="token punctuation">,</span>  <span class="token string">''</span><span class="token punctuation">,</span>  ts<span class="token punctuation">.</span>ScriptTarget<span class="token punctuation">.</span>Latest<span class="token punctuation">,</span>  <span class="token boolean">false</span><span class="token punctuation">,</span>  ts<span class="token punctuation">.</span>ScriptKind<span class="token punctuation">.</span><span class="token constant">TS</span><span class="token punctuation">)</span><span class="token keyword">const</span> printer <span class="token operator">=</span> ts<span class="token punctuation">.</span><span class="token function">createPrinter</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> newLine<span class="token operator">:</span> ts<span class="token punctuation">.</span>NewLineKind<span class="token punctuation">.</span>LineFeed <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">const</span> result <span class="token operator">=</span> printer<span class="token punctuation">.</span><span class="token function">printNode</span><span class="token punctuation">(</span>  ts<span class="token punctuation">.</span>EmitHint<span class="token punctuation">.</span>Unspecified<span class="token punctuation">,</span>  <span class="token function">makeFactorialFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  resultFile<span class="token punctuation">)</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这么一长串代码，最后会生成这样的一段函数声明：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">1</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们从最基础的 identifier （代表变量名的结点）开始创建，组装参数、if 语句条件与代码块、函数的返回语句，最后通过 <code>createFunctionDeclaration</code> 完成组装。要想流畅地使用，你需要对 Expression、Declaration、Statement 等 AST 的结点类型有比较清晰地了解，比如上面的 If 语句需要使用哪些 token 来组装，还需要了解 TypeScript 的 AST，如 interface、类型别名、装饰器等实际的 AST 结构。</p><p>TypeScript Compiler API 和 Babel、JSCodeShift 等工具的使用方式都不同，Babel 是声明式的 Visitor 模式，我们声明对哪一部分语句做哪些处理，然后 Babel 在遍历 AST 时（<code>@babel/traverse</code>），发现这些语句被注册了操作，就进行对应地执行：</p><blockquote><p>以下示例来自于神光的文章分享，也推荐各位有兴趣进一步学习编译原理的同学关注神光老师的社区分享。</p></blockquote><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">declare</span> <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">'@babel/helper-plugin-utils'</span><span class="token punctuation">)</span><span class="token comment">// 不允许函数类型的赋值</span><span class="token keyword">const</span> noFuncAssignLint <span class="token operator">=</span> <span class="token keyword">declare</span><span class="token punctuation">(</span><span class="token punctuation">(</span>api<span class="token punctuation">,</span> options<span class="token punctuation">,</span> dirname<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  api<span class="token punctuation">.</span><span class="token function">assertVersion</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>    <span class="token function">pre</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      file<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'errors'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    visitor<span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token function">AssignmentExpression</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> state<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> errors <span class="token operator">=</span> state<span class="token punctuation">.</span>file<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'errors'</span><span class="token punctuation">)</span>        <span class="token keyword">const</span> assignTarget <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'left'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">const</span> binding <span class="token operator">=</span> path<span class="token punctuation">.</span>scope<span class="token punctuation">.</span><span class="token function">getBinding</span><span class="token punctuation">(</span>assignTarget<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>binding<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>            binding<span class="token punctuation">.</span>path<span class="token punctuation">.</span><span class="token function">isFunctionDeclaration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>            binding<span class="token punctuation">.</span>path<span class="token punctuation">.</span><span class="token function">isFunctionExpression</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">const</span> tmp <span class="token operator">=</span> Error<span class="token punctuation">.</span>stackTraceLimit            Error<span class="token punctuation">.</span>stackTraceLimit <span class="token operator">=</span> <span class="token number">0</span>            errors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>              path<span class="token punctuation">.</span><span class="token function">buildCodeFrameError</span><span class="token punctuation">(</span><span class="token string">'can not reassign to function'</span><span class="token punctuation">,</span> Error<span class="token punctuation">)</span>            <span class="token punctuation">)</span>            Error<span class="token punctuation">.</span>stackTraceLimit <span class="token operator">=</span> tmp          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token function">post</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'errors'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而 jscodeshift 则提供的是命令式的 API：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>fileInfo<span class="token punctuation">,</span> api<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> api    <span class="token punctuation">.</span><span class="token function">jscodeshift</span><span class="token punctuation">(</span>fileInfo<span class="token punctuation">.</span>source<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">findVariableDeclarators</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">renameTo</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">toSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然命令式看起来很简单，但却可能导致对 AST 节点的遗漏（如果底层封装没有完全覆盖掉边界情况），就像鱼和熊掌不可兼得一样。而 TypeScript Compiler API 同样属于命令式，只不过它的使用风格并非链式，而更像是组合式。</p><p>铺垫了这么多，是时候请出我们本节的主角了。</p><h2 id="使用-ts-morph"><a href="#使用-ts-morph" class="headerlink" title="使用 ts-morph"></a>使用 ts-morph</h2><p>上面的例子看下来，可能有部分同学已经被劝退了，这一堆眼花缭乱的 API，我咋知道啥时候该用哪个，难道还要先从头学一遍编译原理？</p><p>当然不，你可以永远相信 JavaScript 社区。为了简化 TypeScript AST 的操作，我们本节的主角 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fts-morph">ts-morph</a> 诞生了，它的原名为 <code>ts-simple-ast</code>，从这两个名字你都能感受到它的目的：<strong>让 AST 操作更简单一些</strong>（morph 意为变形）。</p><p>我们直接来看它的使用方式，直观地感受下它是如何实现更简单的 AST 操作的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> path <span class="token keyword">from</span> <span class="token string">'path'</span><span class="token keyword">import</span> chalk <span class="token keyword">from</span> <span class="token string">'chalk'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Project<span class="token punctuation">,</span> SyntaxKind <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'ts-morph'</span><span class="token comment">// 实例化一个“项目实例”</span><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Project</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 将某个路径的文件添加到这个项目内</span><span class="token keyword">const</span> source <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">addSourceFileAtPath</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'./source.ts'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">/** * 创建一个接口 * * interface IUser &#123; &#125; */</span><span class="token keyword">const</span> interfaceDec <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">addInterface</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token string">'IUser'</span><span class="token punctuation">,</span>  properties<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 新增属性</span>interfaceDec<span class="token punctuation">.</span><span class="token function">addProperties</span><span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token string">'name'</span><span class="token punctuation">,</span>    type<span class="token operator">:</span> <span class="token string">'string'</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token string">'age'</span><span class="token punctuation">,</span>    type<span class="token operator">:</span> <span class="token string">'number'</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">// 添加 JSDoc 注释 @author Linbudu</span>interfaceDec<span class="token punctuation">.</span><span class="token function">addJsDoc</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  tags<span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      tagName<span class="token operator">:</span> <span class="token string">'author'</span><span class="token punctuation">,</span>      text<span class="token operator">:</span> <span class="token string">'Linbudu'</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 添加泛型 T extends Record&lt;string, any></span>interfaceDec<span class="token punctuation">.</span><span class="token function">addTypeParameter</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token string">'T'</span><span class="token punctuation">,</span>  constraint<span class="token operator">:</span> <span class="token string">'Record&lt;string, any>'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 获取接口名称</span>interfaceDec<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 删除这个接口声明</span>interfaceDec<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 创建一条导入：import &#123; readFile, rmSync &#125; from 'fs';</span><span class="token keyword">const</span> importDec <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">addImportDeclaration</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  namedImports<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'readFile'</span><span class="token punctuation">,</span> <span class="token string">'rmSync'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  moduleSpecifier<span class="token operator">:</span> <span class="token string">'fs'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 新增具名导入 appendFile</span>importDec<span class="token punctuation">.</span><span class="token function">addNamedImport</span><span class="token punctuation">(</span><span class="token string">'appendFile'</span><span class="token punctuation">)</span><span class="token comment">// 设置默认导入 fs</span>importDec<span class="token punctuation">.</span><span class="token function">setDefaultImport</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token comment">// 删除默认导入</span>importDec<span class="token punctuation">.</span><span class="token function">removeDefaultImport</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 删除命名空间导入</span>importDec<span class="token punctuation">.</span><span class="token function">removeNamespaceImport</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 删除这条导入声明</span>importDec<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，ts-morph 提供了一系列直观的封装方法，只要调用这些方法就可以完成对 AST 的各种操作，包括新增、更新、删除、读取等等！</p><p>通过使用 ts-morph，你可以使用非常简便的方式来完成各种有趣好玩的操作，比如我们下面会讲到的为 React 组件添加 memo、检查并更新导入语句、从 JSON 文件转换到 TypeScript 类型等等。而实际实现中，当然也是基于 Compiler API 的封装，但是它屏蔽了 Statement、Expression、Declaration、Token 等等概念，直接提供给你应用层的实现：创建一个接口，添加泛型参数，添加属性，添加继承，将其设置为导出，完成！在这个过程中，你并不需要理解底层发生了哪些 AST 结点的变化和操作。</p><p>光是这样，其实还是具有一定使用成本，毕竟要对 AST 进行操作，还是需要分析出整个 AST 结构，以及定位到需要操作的目标 AST 结点。如果是和我一样没有学习过编译原理的同学，这一步仍然是天堑。</p><p>感谢万能的社区，我们可以使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fts-ast-viewer.com%2F%23">TS-AST-Viewer</a> 这个在线网页来直观地检查一段代码的 AST 结构：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ccee9c0586f4623b1b4eda66b8e17c3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>从左到右依次是输入的源码（左上）与对应的 Compiler API 代码（左下）、AST 结构以及其在 TypeScript 内部的编译产物。</p><p>你可以通过右上角的配置来调整 TS 版本等功能：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7eedb2f9376d452d9ce71bb6895f24a7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><blockquote><p>除了 TS AST Viewer 以外，此前你可能也使用过支持数十种语言或 SDL，以及其对应的 parser 的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fastexplorer.net%2F">AST Explorer</a>，它们的功能是类似的，但 AST Explorer 目前并不支持使用 TypeScript Compiler API 来解析 TS 代码：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1b10bd2e6a14930a044a680878597c5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p></blockquote><p>有了 TS AST Viewer，我们的操作流程就会变得非常流畅了。首先一级级向下找到目标 AST 结点，这一步我们可以使用 ts-morph 提供的 getFirstChildByKind 方法来获取一个 AST 结点内我们需要的子结点，“ByKind” 的 Kind 指的是 TypeScript Compiler API 内的 SyntaxKind 枚举，它描述了所有可能的 AST 结点类型。</p><p>拿到目标 AST 结点后，我们就可以调用上面已经提供好的方法（如导入声明的 <code>getModuleSpecifierValue</code> 方法可以直接获得此导入的模块名），最后保存即可。</p><p>最后，ts-morph 其实也并不能完全替代原生 Compiler API，它并没有对 Block 内的 AST 操作进行封装，比如最开始我们使用 Compiler API 创建函数的例子，如果换成 ts-morph ，那么对于函数体内的逻辑它是无能为力的，你要么直接写入字符串，要么将这部分仍然使用原生的 Compiler API 实现。</p><h2 id="AST-Checker-与-CodeMod"><a href="#AST-Checker-与-CodeMod" class="headerlink" title="AST Checker 与 CodeMod"></a>AST Checker 与 CodeMod</h2><p>了解了 ts-morph 的基本使用，接下来我们就通过几个具有实际意义的示例进一步掌握它。这些示例基本都是我遇见过的实际场景，如果不通过 AST 操作，就需要自己手动一个个处理。</p><p>这些操作其实可以分为两大类：AST Checker 与 CodeMod。其中 AST Checker 指的是完全不进行新增/更新/删除操作，只是通过 AST + 预设的条件检查源码是否符合要求，比如不允许调用某个方法、不允许默认导出、要求某个导入必须存在，都属于 AST Checker 的范畴。</p><blockquote><p>关于 AST Checker 与 ESLint 的区别，请参考扩展阅读部分。</p></blockquote><p>而 CodeMod 你此前可能已经使用过，它通常会在基础框架发生大版本更新时出现，用来降低使用者的迁移成本，比如 Antd Design 的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40ant-design%2Fcodemod-v4">codemod</a>，Material UI 的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40mui%2Fcodemod">codemod</a> 等，这些 codemod 会进行依赖升级、配置文件更新以及源码更新等操作，这里我们指的 codemod，其实就只是源码更新这一部分。它需要对源码进行新增、更新以及删除等等操作。</p><p>接下来我们会使用 ts-morph 来实现数个示例，它们没有什么难度，毕竟我们的目的在于熟悉“分析-定位-处理-保存”这个工作流程嘛。而且有了 ts-morph 的加持，很多 AST 操作的难度都会下降几个级别。</p><h3 id="示例：导入语句"><a href="#示例：导入语句" class="headerlink" title="示例：导入语句"></a>示例：导入语句</h3><p>许多场景的 AST 操作中，其实都会涉及对导入语句的处理。比如 CodeMod 会将你旧版本的导入更新为新版本的导入，或者更换导入语句的导入路径（模块名），而在某些工程场景下，AST Checker 也会检查代码中是否进行了必需的 polyfill 导入。</p><p>我们的源码如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> readFileSync <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'fs'</span><span class="token keyword">import</span> <span class="token string">'some_required_polyfill'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>操作后的代码如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token string">'some_required_polyfill'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> readFile <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'fs/promises'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这个例子中，我们希望进行两种操作：</p><ul><li>将来自于 fs 的 sync api 导入，更换为来自 <code>fs/promise</code> 的 async api，如 <code>import &#123; readFile &#125; from &#39;fs/promises&#39;</code></li><li>检查是否存在对 <code>some_required_polyfill</code> 的导入</li></ul><p>首先第一步，一定是分析源代码的 AST 结构：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c21521468d74cf2af32280bf84a131f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>整理一下思路：</p><ul><li>将 fs 更改为 fs/promises</li><li>将来自 fs 的，以 Sync 结尾的导入进行更改</li><li>检查是否存在以 <code>some_required_polyfill</code> 为导入名的导入声明</li></ul><p>直接看具体实现：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> path <span class="token keyword">from</span> <span class="token string">'path'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Project<span class="token punctuation">,</span> SyntaxKind<span class="token punctuation">,</span> SourceFile<span class="token punctuation">,</span> ImportDeclaration <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'ts-morph'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> uniq <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'lodash'</span><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Project</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> source <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">addSourceFileAtPath</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'./source.ts'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 获取所有导入声明中的模块名</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getImportModuleSpecifiers</span><span class="token punctuation">(</span>source<span class="token operator">:</span> SourceFile<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">uniq</span><span class="token punctuation">(</span>    source<span class="token punctuation">.</span><span class="token function">getImportDeclarations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=></span> i<span class="token punctuation">.</span><span class="token function">getModuleSpecifierValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token constant">REQUIRED</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'some_required_polyfill'</span><span class="token punctuation">]</span><span class="token keyword">const</span> allDeclarations <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">getImportDeclarations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> allSpecifiers <span class="token operator">=</span> <span class="token function">getImportModuleSpecifiers</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token constant">REQUIRED</span><span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=></span> allSpecifiers<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'missing required polyfill'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 设计一个通用的替换模式</span><span class="token keyword">const</span> <span class="token constant">FORBIDDEN</span> <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token punctuation">&#123;</span>    <span class="token comment">// 要被替换的导入路径</span>    moduleSpecifier<span class="token operator">:</span> <span class="token string">'fs'</span><span class="token punctuation">,</span>    <span class="token comment">// 替换为这个值</span>    replacement<span class="token operator">:</span> <span class="token string">'fs/promises'</span><span class="token punctuation">,</span>    <span class="token comment">// 原本的导入如何更新</span>    <span class="token function-variable function">namedImportsReplacement</span><span class="token operator">:</span> <span class="token punctuation">(</span>raw<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span>      raw<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">'Sync'</span><span class="token punctuation">)</span> <span class="token operator">?</span> raw<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">:</span> raw<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token keyword">const</span> <span class="token constant">FORBIDDEN_SPECIFIERS</span> <span class="token operator">=</span> <span class="token constant">FORBIDDEN</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=></span> i<span class="token punctuation">.</span>moduleSpecifier<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> specifier <span class="token keyword">of</span> allSpecifiers<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">FORBIDDEN_SPECIFIERS</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>specifier<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> target <span class="token operator">=</span> allDeclarations<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>      <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=></span>        <span class="token comment">// 检查是否是要被替换的模块</span>        i<span class="token punctuation">.</span><span class="token function">getModuleSpecifierValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> specifier    <span class="token punctuation">)</span>    <span class="token comment">// 找到要被替换的导入声明</span>    <span class="token keyword">const</span> replacementMatch <span class="token operator">=</span> <span class="token constant">FORBIDDEN</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>      <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=></span> i<span class="token punctuation">.</span>moduleSpecifier <span class="token operator">===</span> specifier    <span class="token punctuation">)</span>    <span class="token comment">// 收集原本的具名导入</span>    <span class="token keyword">const</span> namedImports <span class="token operator">=</span> target<span class="token operator">?.</span><span class="token function">getNamedImports</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">??</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment">// 替换为新的具名导入</span>    <span class="token keyword">const</span> namedImportsReplacement <span class="token operator">=</span> namedImports<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=></span>      replacementMatch<span class="token operator">?.</span><span class="token function">namedImportsReplacement</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span>    <span class="token comment">// 移除原本的导入</span>    target<span class="token operator">?.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 增加新的导入</span>    source<span class="token punctuation">.</span><span class="token function">addImportDeclaration</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      moduleSpecifier<span class="token operator">:</span> replacementMatch<span class="token operator">?.</span>replacement<span class="token operator">!</span><span class="token punctuation">,</span>      namedImports<span class="token operator">:</span> namedImportsReplacement<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        name<span class="token operator">:</span> i<span class="token operator">!</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们使用的 API 主要包括：</p><ul><li><code>source.getImportDeclarations()</code>，获取源码的所有导入声明</li><li><code>source.addImportDeclaration</code>，源码新增导入声明语句</li><li><code>i.getModuleSpecifierValue</code>，获取导入声明的模块名（或者说导入路径）</li><li><code>target?.getNamedImports</code>，获取导入声明的具名导入</li></ul><p>扩展：如何处理默认导入、命名空间导入的形式？</p><h3 id="示例：添加装饰器"><a href="#示例：添加装饰器" class="headerlink" title="示例：添加装饰器"></a>示例：添加装饰器</h3><p>在装饰器一节我们说到，可以使用方法装饰器来测量一个方法的调用耗时，但一个一个加未免太过麻烦，更好的方式是通过 AST 来批量处理目标 Class 的目标方法：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">abstract</span> <span class="token function">handle</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">NotHandler</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">EventHandler</span> <span class="token keyword">implements</span> <span class="token class-name">Handler</span> <span class="token punctuation">&#123;</span>  <span class="token function">handle</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">MessageHandler</span> <span class="token keyword">implements</span> <span class="token class-name">Handler</span> <span class="token punctuation">&#123;</span>  <span class="token function">handle</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其处理结果应当是这样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">abstract</span> <span class="token function">handle</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">NotHandler</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">EventHandler</span> <span class="token keyword">implements</span> <span class="token class-name">Handler</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">PerformanceMark</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token function">handle</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">MessageHandler</span> <span class="token keyword">implements</span> <span class="token class-name">Handler</span> <span class="token punctuation">&#123;</span>  <span class="token decorator"><span class="token at operator">@</span><span class="token function">PerformanceMark</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token function">handle</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们使用抽象类来区分目标 Class，即只有实现了某一抽象类的 Class 才需要进行处理。</p><p>首先分析 AST 结构：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20561d4d6440420f8113a333654cd3e0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>整理一下实现思路：</p><ul><li>拿到所有实现了 Handler 抽象类的 Class 声明</li><li>为这些声明内部的 handle 方法添加 <code>@PerformanceMark</code> 装饰器</li></ul><p>完整实现如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> path <span class="token keyword">from</span> <span class="token string">'path'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Project<span class="token punctuation">,</span> ClassDeclaration <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'ts-morph'</span><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Project</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> source <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">addSourceFileAtPath</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'./source.ts'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token constant">IMPLS</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Handler'</span><span class="token punctuation">]</span><span class="token comment">// 获取所有目标 Class 声明</span><span class="token keyword">const</span> filteredClassDeclarations<span class="token operator">:</span> ClassDeclaration<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> source  <span class="token punctuation">.</span><span class="token function">getClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> impls <span class="token operator">=</span> cls<span class="token punctuation">.</span><span class="token function">getImplements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>impl<span class="token punctuation">)</span> <span class="token operator">=></span> impl<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token constant">IMPLS</span><span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">(</span>impl<span class="token punctuation">)</span> <span class="token operator">=></span> impls<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>impl<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token constant">METHODS</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'handle'</span><span class="token punctuation">]</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> cls <span class="token keyword">of</span> filteredClassDeclarations<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 拿到所有方法</span>  <span class="token keyword">const</span> methods <span class="token operator">=</span> cls<span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token operator">=></span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> method <span class="token keyword">of</span> methods<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">METHODS</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 拿到目标方法声明</span>      <span class="token keyword">const</span> methodDeclaration <span class="token operator">=</span> cls<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token operator">!</span>      methodDeclaration<span class="token punctuation">.</span><span class="token function">addDecorator</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        name<span class="token operator">:</span> <span class="token string">'PerformanceMark'</span><span class="token punctuation">,</span>        arguments<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们主要使用了这么几个 API：</p><ul><li><code>source.getClasses</code>，获取源码中所有的 Class 声明</li><li><code>cls.getImplements</code>，获取 Class 声明实现的抽象类</li><li><code>cls.getMethods</code> 与 <code>cls.getMethod</code>，获取 Class 声明中的方法声明</li><li><code>methodDeclaration.addDecorator</code>，为方法声明新增装饰器</li></ul><p>扩展：试试给方法的参数也添加方法参数装饰器？</p><h3 id="示例：添加-memo"><a href="#示例：添加-memo" class="headerlink" title="示例：添加 memo"></a>示例：添加 memo</h3><p>为 React 组件添加 memo 是一个常见的优化手段，我们是否可以通过 AST 操作来批量为组件添加 memo ？</p><p>我们的源码是这样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useState <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">const</span> <span class="token function-variable function">Comp</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> Comp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>处理后的结果则是这样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> memo<span class="token punctuation">,</span> useState <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">const</span> <span class="token function-variable function">Comp</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">memo</span><span class="token punctuation">(</span>Comp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，我们需要添加具名导入，以及修改默认导出表达式两个步骤。</p><p>首先分析 AST 结构：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/776e37d6052c4bf3a703d0bdcf7e146f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>可以看到，我们需要处理的两处分别为 NamedImports 与 ExportAssignment ，接下来就简单了：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> path <span class="token keyword">from</span> <span class="token string">'path'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Project<span class="token punctuation">,</span> SyntaxKind<span class="token punctuation">,</span> SourceFile <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'ts-morph'</span><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Project</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> source <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">addSourceFileAtPath</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'./source.tsx'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 获取默认导出</span><span class="token keyword">const</span> exportDefaultAssignment <span class="token operator">=</span> source  <span class="token punctuation">.</span><span class="token function">getFirstChildByKind</span><span class="token punctuation">(</span>SyntaxKind<span class="token punctuation">.</span>SyntaxList<span class="token punctuation">)</span><span class="token operator">!</span>  <span class="token punctuation">.</span><span class="token function">getFirstChildByKind</span><span class="token punctuation">(</span>SyntaxKind<span class="token punctuation">.</span>ExportAssignment<span class="token punctuation">)</span><span class="token operator">!</span><span class="token comment">// 获取原本的导出语句的组件名</span><span class="token keyword">const</span> targetIdentifier <span class="token operator">=</span> exportDefaultAssignment  <span class="token operator">?.</span><span class="token function">getFirstChildByKind</span><span class="token punctuation">(</span>SyntaxKind<span class="token punctuation">.</span>Identifier<span class="token punctuation">)</span>  <span class="token operator">?.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!</span><span class="token comment">// 获取 react 对应的导入声明</span><span class="token keyword">const</span> reactImport <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">getImportDeclaration</span><span class="token punctuation">(</span>  <span class="token punctuation">(</span>imp<span class="token punctuation">)</span> <span class="token operator">=></span> imp<span class="token punctuation">.</span><span class="token function">getModuleSpecifierValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'react'</span><span class="token punctuation">)</span><span class="token operator">!</span><span class="token comment">// 新增一个具名导入</span>reactImport<span class="token punctuation">.</span><span class="token function">insertNamedImport</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'memo'</span><span class="token punctuation">)</span><span class="token comment">// 新增 memo 包裹</span><span class="token operator">!</span>targetIdentifier<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'memo'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>  exportDefaultAssignment<span class="token punctuation">.</span><span class="token function">setExpression</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">memo(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>targetIdentifier<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们主要调用了这些 API：</p><ul><li><code>source.getFirstChildByKind(SyntaxKind.SyntaxList)</code>，获取一个 AST 结点下首个目标类型的子结点，在上面我们都是直接使用 <code>source.getClasses()</code> 形式获取目标类型，而这里则是另外一种方式，<code>source.getFirstChildByKind(SyntaxKind.SyntaxList).getFirstChildByKind(SyntaxKind.ExportAssignment)</code> 即意味着拿到源码中的第一个导出语句。需要注意的是，使用这种方式必须首先拿到 <code>SyntaxKind.SyntaxList</code> 类型的子结点。</li><li><code>source.getImportDeclaration</code>，获取源码中所有的导入声明</li><li><code>imp.getModuleSpecifierValue</code>，获取导入的模块名</li><li><code>import.insertNamedImport</code>，为导入声明插入一个具名导入</li><li><code>exportDefaultAssignment.setExpression</code>，修改导出语句的表达式</li></ul><p>扩展：上面我们直接将默认导出语句作为了组件，然后通过修改它的表达式来实现添加 memo。不妨试试如何支持 <code>export const</code> 形式的组件导出？</p><h3 id="示例：JSON-转类型定义"><a href="#示例：JSON-转类型定义" class="headerlink" title="示例：JSON 转类型定义"></a>示例：JSON 转类型定义</h3><p>这个例子可能是最最刚需的一个了，把后端响应的 JSON 放进去，就得到了 TypeScript 的类型定义。</p><p>我们输入的 json 是这样的：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"linbudu"</span><span class="token punctuation">,</span>  <span class="token property">"age"</span><span class="token operator">:</span> <span class="token number">22</span><span class="token punctuation">,</span>  <span class="token property">"sex"</span><span class="token operator">:</span> <span class="token string">"male"</span><span class="token punctuation">,</span>  <span class="token property">"favors"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"execrise"</span><span class="token punctuation">,</span> <span class="token string">"writting"</span><span class="token punctuation">,</span> <span class="token number">999</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"job"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"programmer"</span><span class="token punctuation">,</span>    <span class="token property">"stack"</span><span class="token operator">:</span> <span class="token string">"javascript"</span><span class="token punctuation">,</span>    <span class="token property">"company"</span><span class="token operator">:</span> <span class="token string">"alibaba"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"pets"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"dog"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"cat"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终输出的类型定义是这样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">IStruct</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  age<span class="token operator">:</span> <span class="token builtin">number</span>  sex<span class="token operator">:</span> <span class="token builtin">string</span>  favors<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span>  IJob<span class="token operator">:</span> IJob  pets<span class="token operator">:</span> IStructPets<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">IJob</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  stack<span class="token operator">:</span> <span class="token builtin">string</span>  company<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">IStructPets</span> <span class="token punctuation">&#123;</span>  id<span class="token operator">:</span> <span class="token builtin">number</span>  type<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体实现其实并不复杂，由于 JSON 的限制，我们无需处理函数之类的类型，但也无法实现字面量类型与枚举这样精确的定义。然而绝大部分情况下，JSON 中的值类型其实还是字符串、数字、布尔值以及对象与数组这五位。</p><p>我们来整理一下思路：</p><ul><li>遍历 JSON</li><li>对于原始类型元素，直接使用 typeof （注意，是 JavaScript 中的 typeof，不是类型查询操作符）的值作为类型，调用 <code>interfaceDeclaration.addProperty</code> 方法新增属性</li><li>对于对象类型，遍历此对象类型，将此对象类型生成的接口也调用 <code>source.addInterface</code> 方法添加到源码中，并将其名称调用 <code>interfaceDeclaration.addProperty</code> 添加到顶层的对象中</li><li>对于数组类型，如果其中是原始类型，提取所有原始类型值的类型，合并为联合类型，如果其中是对象类型，则遍历其中的对象类型，类似上一步。</li></ul><p>来看完整的代码：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> path <span class="token keyword">from</span> <span class="token string">'path'</span><span class="token keyword">import</span> fs <span class="token keyword">from</span> <span class="token string">'fs-extra'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Project <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'ts-morph'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> capitalize<span class="token punctuation">,</span> uniq <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'lodash'</span><span class="token keyword">import</span> json <span class="token keyword">from</span> <span class="token string">'./source.json'</span><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Project</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> filePath <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'./source.ts'</span><span class="token punctuation">)</span>fs<span class="token punctuation">.</span><span class="token function">rmSync</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span>fs<span class="token punctuation">.</span><span class="token function">ensureFileSync</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token keyword">const</span> source <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">addSourceFileAtPath</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">objectToInterfaceStruct</span><span class="token punctuation">(</span>  identifier<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>  input<span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">unknown</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> interfaceDeclaration <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">addInterface</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> identifier<span class="token punctuation">,</span>    isExported<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 最简单的情况，直接添加属性</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'string'</span><span class="token punctuation">,</span> <span class="token string">'number'</span><span class="token punctuation">,</span> <span class="token string">'boolean'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      interfaceDeclaration<span class="token punctuation">.</span><span class="token function">addProperty</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        name<span class="token operator">:</span> key<span class="token punctuation">,</span>        type<span class="token operator">:</span> <span class="token keyword">typeof</span> value<span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 简单起见，不处理混合或者更复杂的情况</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 对象类型元素</span>      <span class="token keyword">const</span> objectElement <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">typeof</span> v <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span>      <span class="token comment">// 原始类型元素</span>      <span class="token keyword">const</span> primitiveElement <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">=></span>        <span class="token punctuation">[</span><span class="token string">'string'</span><span class="token punctuation">,</span> <span class="token string">'number'</span><span class="token punctuation">,</span> <span class="token string">'boolean'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> v<span class="token punctuation">)</span>      <span class="token punctuation">)</span>      <span class="token keyword">const</span> primitiveElementTypes <span class="token operator">=</span> <span class="token function">uniq</span><span class="token punctuation">(</span>primitiveElement<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">typeof</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment">// 对对象类型元素，只取第一个来提取类型</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>objectElement<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 再次遍历此方法</span>        <span class="token keyword">const</span> objectType <span class="token operator">=</span> <span class="token function">objectToInterfaceStruct</span><span class="token punctuation">(</span>          <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>identifier<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token function">capitalize</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>          objectElement<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token punctuation">)</span>        interfaceDeclaration<span class="token punctuation">.</span><span class="token function">addProperty</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>          name<span class="token operator">:</span> key<span class="token punctuation">,</span>          type<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>objectType<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">[]</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        interfaceDeclaration<span class="token punctuation">.</span><span class="token function">addProperty</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>          name<span class="token operator">:</span> key<span class="token punctuation">,</span>          <span class="token comment">// 使用联合类型 + 数组作为此属性的类型</span>          type<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>primitiveElementTypes<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">' | '</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">)[]</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">continue</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 对于对象类型，再次遍历</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> value <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> nestedStruct <span class="token operator">=</span> <span class="token function">objectToInterfaceStruct</span><span class="token punctuation">(</span>        <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">I</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token function">capitalize</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>        value <span class="token keyword">as</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">unknown</span><span class="token operator">></span>      <span class="token punctuation">)</span>      interfaceDeclaration<span class="token punctuation">.</span><span class="token function">addProperty</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        name<span class="token operator">:</span> key<span class="token punctuation">,</span>        <span class="token comment">// 使用从接口结构得到的接口名称</span>        type<span class="token operator">:</span> nestedStruct<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> interfaceDeclaration<span class="token punctuation">&#125;</span><span class="token function">objectToInterfaceStruct</span><span class="token punctuation">(</span><span class="token string">'IStruct'</span><span class="token punctuation">,</span> json<span class="token punctuation">)</span>source<span class="token punctuation">.</span><span class="token function">saveSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这一部分，我们主要使用两个 API ：</p><ul><li><code>source.addInterface</code>，在源码中新增一个接口声明，如：</li><li><code>interfaceDeclaration.addProperty</code>，为接口声明新增一个属性，如：</li></ul><p>扩展：上面的处理逻辑并没有很好地处理掉对象类型与数组类型中的复杂情况，比如数组中既有原始类型也有对象类型，不妨试着完善一下这部分逻辑？</p><h3 id="示例：基于-JSDoc-的任务过期检测"><a href="#示例：基于-JSDoc-的任务过期检测" class="headerlink" title="示例：基于 JSDoc 的任务过期检测"></a>示例：基于 JSDoc 的任务过期检测</h3><p>很多时候，我们可能会写一些存在过期时效的代码，比如紧急更新、临时 bugfix 等，如果在规模较为庞大的代码库中，很可能你写完就忘记这个方法只是临时方法了。这个示例中，我们会使用 JSDoc 的形式来标记一个方法的过期时间，并通过 AST 来检查此方法是否过期：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">/** * @expires 2022-08-01 * @author linbudu * @description 这是一个临时的 bugfix，需要在下次更新时删除 */</span><span class="token keyword">function</span> <span class="token function">tempFix</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * @expires 2022-01-01 * @author linbudu * @description 这是一个临时的兼容 */</span><span class="token keyword">function</span> <span class="token function">tempSolution</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 工具方法 */</span><span class="token keyword">function</span> <span class="token function">utils</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 TS AST Viewer 目前不支持 JSDoc 的解析，这里我们直接来整理一下实现思路：</p><ul><li>检查所有函数的 JSDoc 区域</li><li>如果发现了 <code>@expires</code>，对比其标注的过期时间与当前的时间</li><li>如果过期，抛出错误，并指出 <code>@author</code> 标记的作者</li></ul><p>直接来看实现：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> path <span class="token keyword">from</span> <span class="token string">'path'</span><span class="token keyword">import</span> chalk <span class="token keyword">from</span> <span class="token string">'chalk'</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Project<span class="token punctuation">,</span> SyntaxKind<span class="token punctuation">,</span> SourceFile<span class="token punctuation">,</span> FunctionDeclaration <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'ts-morph'</span><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Project</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> source <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">addSourceFileAtPath</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'./source.ts'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 收集所有的函数声明</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getAllFunctionDeclarations</span><span class="token punctuation">(</span>  source<span class="token operator">:</span> SourceFile<span class="token punctuation">)</span><span class="token operator">:</span> FunctionDeclaration<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> functionDeclarationList <span class="token operator">=</span> source    <span class="token punctuation">.</span><span class="token function">getFirstChildByKind</span><span class="token punctuation">(</span>SyntaxKind<span class="token punctuation">.</span>SyntaxList<span class="token punctuation">)</span><span class="token operator">!</span>    <span class="token punctuation">.</span><span class="token function">getChildrenOfKind</span><span class="token punctuation">(</span>SyntaxKind<span class="token punctuation">.</span>FunctionDeclaration<span class="token punctuation">)</span>  <span class="token keyword">return</span> functionDeclarationList<span class="token punctuation">&#125;</span><span class="token comment">// 收集所有存在 JSDoc 的函数声明</span><span class="token keyword">const</span> filteredFuncDeclarations <span class="token operator">=</span> <span class="token function">getAllFunctionDeclarations</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>  <span class="token punctuation">(</span>func<span class="token punctuation">)</span> <span class="token operator">=></span> func<span class="token punctuation">.</span><span class="token function">getJsDocs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> func <span class="token keyword">of</span> filteredFuncDeclarations<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> jsdocContent <span class="token operator">=</span> func<span class="token punctuation">.</span><span class="token function">getJsDocs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token keyword">const</span> tags <span class="token operator">=</span> jsdocContent<span class="token punctuation">.</span><span class="token function">getTags</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> expireTag <span class="token operator">=</span> tags<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span> <span class="token operator">=></span> tag<span class="token punctuation">.</span><span class="token function">getTagName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'expires'</span><span class="token punctuation">)</span>  <span class="token comment">// 如果不存在 @expires 标签，则跳过</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>expireTag<span class="token punctuation">)</span> <span class="token keyword">continue</span>  <span class="token comment">// 将其值处理为可解析的字符串</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> expireDesc<span class="token punctuation">]</span> <span class="token operator">=</span> expireTag<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\*|\n</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> expireDate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>expireDesc<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 对比时间</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>expireDate <span class="token operator">&lt;</span> now<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> authorTag <span class="token operator">=</span> tags<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span> <span class="token operator">=></span> tag<span class="token punctuation">.</span><span class="token function">getTagName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'author'</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> author<span class="token punctuation">]</span> <span class="token operator">=</span> authorTag      <span class="token operator">?</span> authorTag<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\*|\n</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span>      <span class="token operator">:</span> <span class="token string">'unknown'</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>      chalk<span class="token punctuation">.</span><span class="token function">red</span><span class="token punctuation">(</span>        <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Function </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>chalk<span class="token punctuation">.</span><span class="token function">yellow</span><span class="token punctuation">(</span>          func<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> is expired, author: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>chalk<span class="token punctuation">.</span><span class="token function">white</span><span class="token punctuation">(</span>author<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>      <span class="token punctuation">)</span>    <span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用效果是这样的：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/164763d6b99141b9bd6ad40c314b5fe3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>扩展：上面的例子只能基于硬编码的日期进行处理，而另外一种可能的情况是基于版本来做检查，比如某一部分代码应该在 <code>package.json</code> 中的 <code>version</code> 到达 <code>1.0.0</code> 以前被再次优化一遍，不妨来试一下支持这种情况？</p><p>以上的示例应该能帮助你领会到，使用 ts-morph 来进行源码检查与操作的窍门。同时你可能注意到了，上面的示例我们封装了不少方法，如 <code>getAllFunctionDeclarations</code>、<code>getClassDeclarations</code>、<code>getImportDeclarations</code> 等，这也是我比较推荐的一种方式：在 ts-morph 上进一步封装 AST 方法，让 AST 操作就像调用 Lodash 方法一样简单。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这一节，我们主要学习了如何使用 TypeScript 的 Compiler API 和 ts-morph 来对 TS 源码进行操作，就像数据库的 CRUD 一样，对源码的常见操作其实也可以被归类为检查、变更、新增这么几类。</p><p>对没有系统学习过编译原理的同学，其实更推荐使用 ts-morph 来简化这些 AST 操作。原因上面我们也已经了解到了，ts-morph 通过更符合直觉的 API 封装掉了很多底层的操作，能够大大地简化使用成本与理解负担。</p><p>当然，由于封装带来了黑盒的底层实现与各种不确定性，如果你对操作的稳定性要求高，最好的方式还是使用原生的 Compiler API 或 Babel 一点点进行实现。</p><p>而通过 TS AST Viewer 的帮助，我们还可以更进一步简化操作。检查 AST 结构、确定目标 AST 结构、执行操作以及保存，就能完成一次处理。</p><p>最后，除了本节给到的操作示例，你还可以根据自身的实际需要来探索更多有趣的例子，试着来感受“换一种方式使用 TypeScript”的乐趣吧！</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="AST-Checker-与-ESLint"><a href="#AST-Checker-与-ESLint" class="headerlink" title="AST Checker 与 ESLint"></a>AST Checker 与 ESLint</h3><p>在上面的介绍中，听起来 AST Checker 和 ESLint 很相似，都是检查代码是否符合规则，并且 ESLint 也是通过 AST 来进行检查，如 AST Explorer 中使用 TypeScript ESLint Parser：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81a6a1eea91a40b3ba48dbebc48db056~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>然而二者的差异实际上非常大。首先， Lint 不会涉及业务逻辑的检查，比如我们要求对某个 polyfill 的导入必须存在，或者要求必须调用某个全局的顶级方法，此时就应该是 AST Checker 的工作范畴，而非 Lint。Lint 更多关注的是纯粹的、完全不涉及业务逻辑的规则。</p><p>另外，Lint 规则的维度通常更高，比如我要求团队内的所有代码库都必须遵守一系列规则。而 AST Checker 的规则通常只是项目维度的，比如只在几个项目内要求遵守这条规则，这也就意味着 AST Checker 的规则不具备或很难具备可推广性。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>32.感谢相伴：是结束，也是开始</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/32.%E6%84%9F%E8%B0%A2%E7%9B%B8%E4%BC%B4%EF%BC%9A%E6%98%AF%E7%BB%93%E6%9D%9F%EF%BC%8C%E4%B9%9F%E6%98%AF%E5%BC%80%E5%A7%8B/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/32.%E6%84%9F%E8%B0%A2%E7%9B%B8%E4%BC%B4%EF%BC%9A%E6%98%AF%E7%BB%93%E6%9D%9F%EF%BC%8C%E4%B9%9F%E6%98%AF%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<p>在本节开始前，我想先感谢每一位读者，感谢你们的肯定与支持，也希望小册中的内容能够让你收获明显的成长。</p><p>这本小册是我的第一本小册，肯定还存在许多不足之处，比如错别字、示例代码的呈现以及内容的组织方面等等，幸运的是我拥有许多耐心细致的读者帮我“捉虫”，我也会在发现这些问题时第一时间改正。</p><p>从上线到现在，我也收获了许多真诚的评价，严格来说，目前大部分评价对内容都是持肯定态度的。而对于持批评态度的评价，我也尽可能进行了内容的优化与调整。无论评价是正面还是负面，其实都代表读者认真地阅读了内容，这里再次感谢每一位同学的反馈。</p><h2 id="是结束"><a href="#是结束" class="headerlink" title="是结束"></a>是结束</h2><p>天下没有不散的筵席，小册的正文内容就到这里结束了，不妨让我们再回顾下这一路我们都学习了什么。</p><p>类型基础部分（1 - 5 节），作为入门阶段到进阶阶段之间的过渡，在这里我们<strong>在入门的基础上</strong>，按照小册的节奏重新介绍了这些相对简单的概念，也为后面的进阶预留了扩展空间。</p><p>内置类型工具部分（6 - 8 节、12 - 13 节），我们对 TypeScript 茫茫多的类型工具进行了逐个击破，明确了这些类型工具各自的作用与使用场景，同时为类型编程的学习打好了基础。</p><p>类型系统部分（10 - 12 节、14 - 15 节），作为这本小册区分于市面上所有其他 TypeScript 教程的特色，我们了解了结构化类型系统、类型层级、协变与逆变等类型系统的核心概念。有必要再次重申：<strong>类型系统不仅能帮助你更好地理解复杂类型编程的底层原理，也能够让你获得独立解决各种类型问题的能力。</strong></p><p>类型编程部分（13 节、16 - 19 节），我们按照内置工具类型基础、内置工具类型扩展以及模板字符串类型的顺序组织了对类型编程的学习，帮助你从最简单的例子开始理解类型编程的四大范式：<strong>访问性修饰工具类型</strong>、<strong>结构工具类型</strong>、<strong>集合工具类型</strong>以及<strong>模式匹配工具类型</strong>。在不考虑类型体操的情况下，这部分知识已经能够涵盖你日常开发需要的 80% 以上场景了。</p><p>工程部分（20 - 31 节），光学类型能力可不能说掌握了 TypeScript，因此我们花了将近 1/3 的篇幅来学习工程侧的应用。从 React、ESLint 到 ECMAScript，从装饰器、依赖注入到 TSConfig 全解，再从 Node 应用开发到 Compiler API 开发，加上此前的类型能力，现在我们可以说自己身经百战了。</p><p>无论你正处于哪个阶段，这些内容都一定能或多或少帮助到你，而这就是我创作这本小册的初衷。</p><h2 id="也是开始"><a href="#也是开始" class="headerlink" title="也是开始"></a>也是开始</h2><p>虽然到这里，小册的正文内容已经划上句点，但这本小册还没有完全结束。我们还会有数节漫谈篇内容作为番外。</p><p>漫谈篇的内容不会包含任何新的 TypeScript 知识点，你只需要读过一遍就能理解并化为己用，不需要打开编辑器，不需要准备笔记本，不需要特别安静的学习环境。</p><p>目前已经确定的漫谈篇内容包括：</p><ul><li>漫谈：面试中的 TypeScript 技能水平检验</li><li>漫谈：拥抱下一代 Node 框架—— DeepKit</li></ul><p>需要说明的是，漫谈篇的内容并不会正文一样动辄 3000 字，而是会尽可能控制在 1500 字以内，你应该把它当小说，而不是当论文看。</p><p>另外，未来我可能还会有新的掘金小册面世，如果这本小册让你感觉收获满满，也欢迎你关注我的下一本小册~</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>最后，这本小册之所以能成功面世，离不开许多人在这个过程中的帮助。在此，我想再次向他们致以最诚挚的谢意。</p><p>感谢掘金小编的一路跟随与耐心审校，在这本小册中学习到的写作经验也是我的重要收获之一。</p><p>感谢 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.zhihu.com%2Fpeople%2Fxunzhaohailan">寻找海蓝</a>、<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.zhihu.com%2Fpeople%2Fzhaojinxiang">某兔</a>、<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.zhihu.com%2Fpeople%2Fkingwl">王文璐</a>、<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.zhihu.com%2Fpeople%2Fdi-xu-guang-50">神光</a> 等前辈的无私创作分享，在我学习 TypeScript 的过程中，最幸运的一件事就是能阅读到他们的作品。</p><p>感谢 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.zhihu.com%2Fpeople%2Fqing-feng-yi-yang">冴羽</a> 老师帮我进行的安利和推广，也推荐所有在阅读这本小册时卡住的同学，先阅读冴羽老师的 TypeScript 入门教程，完成筑基阶段的积累。</p><p>感谢你的一路陪伴，也期待与你的再次相见。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试中的 TypeScript</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/33.%E6%BC%AB%E8%B0%88%E7%AF%87%EF%BC%9A%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%20TypeScript/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/33.%E6%BC%AB%E8%B0%88%E7%AF%87%EF%BC%9A%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%20TypeScript/</url>
      
        <content type="html"><![CDATA[<p>TypeScript 在前端领域的重要性正在不断提升，那么很自然地，面试过程中对 TypeScript 技能的考察也会逐渐上升到和 Vue / React 技能一样的地位。</p><p>那么，如果 TypeScript 在面试中出现，它又会变成什么样子？首先你可以放心的是，面试中大概率不会出现超出这本小册的知识难度，如果出现了，那可能说明这场面试比较奇妙…</p><p>在这一节中，我们会来聊聊几个可能出现的面试题，依次进行一下从及格线到优秀回答的进阶。</p><blockquote><p>本节不会包含过于基础的内容，如 TypeScript 中包含的基础类型、类型断言的语法这种。</p></blockquote><h2 id="interface-与-type-异同点"><a href="#interface-与-type-异同点" class="headerlink" title="interface 与 type 异同点"></a>interface 与 type 异同点</h2><p>这可能是最经典的一道 TS 面试题了，因此这里我们放在第一个知识点来讲解。</p><h3 id="及格线"><a href="#及格线" class="headerlink" title="及格线"></a>及格线</h3><p>不论如何，以下这些概念是你需要基本了解的，否则很容易被怀疑是否真的深入使用过 TypeScript 。</p><ul><li>在对象扩展情况下，interface 使用 extends 关键字，而 type 使用交叉类型（<code>&amp;</code>）。</li><li>同名的 interface 会自动合并，并且在合并时会要求兼容原接口的结构。</li><li>interface 与 type 都可以描述对象类型、函数类型、Class 类型，但 interface 无法像 type 那样表达元组、一组联合类型等等。</li><li>interface 无法使用映射类型等类型工具，也就意味着在类型编程场景中我们还是应该使用 type 。</li></ul><h3 id="优秀回答"><a href="#优秀回答" class="headerlink" title="优秀回答"></a>优秀回答</h3><p>只是回答这些概念定义显得过于枯燥，而且很容易被认为像是在背书，因此你可以穿插自己在工程中的实践， 比如小册中提过的，使用 interface 来定义对象类型，使用类型别名来处理函数签名、联合类型、工具类型等等。这同样也代表了你对这两个工具的理解：<strong>interface 就是描述对象对外暴露的接口，其不应该具有过于复杂的类型逻辑，最多局限于泛型约束与索引类型这个层面。而 type alias 就是用于将一组类型的重命名，或是对类型进行复杂编程。</strong></p><p>另外，你也可以提到在官方的 Wiki 中，特别说明了在对象扩展的情况下，使用接口继承要比交叉类型的性能更好。</p><h2 id="类型兼容性比较"><a href="#类型兼容性比较" class="headerlink" title="类型兼容性比较"></a>类型兼容性比较</h2><p>这一问题主要考察你是否了解 TypeScript 类型系统的基本工作原理，以及使用的深入程度。因为通常来说，只有具有一定经验的使用者才会开始了解类型兼容性的相关规则，而了解这部分规则也就意味着你至少能够独立解决相当一部分类型报错。</p><h3 id="及格线-1"><a href="#及格线-1" class="headerlink" title="及格线"></a>及格线</h3><p>TypeScript 使用鸭子类型，也即结构化类型系统进行类型兼容性的比较，即对于两个属性完全一致的类型，就认为它们属于同一种类型。而对于 A 类型、A + B 类型，认为后者属于前者的子类型。另外 TypeScript 类型中还存在着一部分特殊的规则，如 object、{} 以及 Top Type 等。</p><h3 id="优秀回答-1"><a href="#优秀回答-1" class="headerlink" title="优秀回答"></a>优秀回答</h3><p>能回答出上面这些内容已经不错了，但你可是阅读完了这本小册的同学，怎么能轻易止步。如果想进一步升华回答，还可以从以下方面进行扩展。</p><ul><li><strong>结构化类型系统到标称类型系统</strong>，你可以表达你不仅了解结构化类型系统，还了解与其可以作为对比的标称类型系统，包括存在意义与比较方式，以及如何在 TS 中实现标称类型系统。</li><li><strong>类型层级</strong>，类型兼容性的比较本质上其实也就是在类型层级中进行比较，一个类型能够兼容其子类型，就这么回事，因此，不妨扩展地讲一讲 TS 的类型层级是怎么样的。</li></ul><h2 id="any、unknown-与-never"><a href="#any、unknown-与-never" class="headerlink" title="any、unknown 与 never"></a>any、unknown 与 never</h2><p>这一部分主要考察你对内置 Top Type、Bottom Type 的理解，属于相对少见的考察，因此通常也不会要求过高。</p><h3 id="及格线-2"><a href="#及格线-2" class="headerlink" title="及格线"></a>及格线</h3><p>具体内容已经在小册中详细描述，这里只做简单叙述。any 与 unknown 在 TypeScript 类型层级中属于最顶层的 Top Type，也就意味所有类型都是它俩的子类型。而 never 则相反，作为 Bottom Type 的它是所有类型的子类型。</p><h3 id="优秀回答-2"><a href="#优秀回答-2" class="headerlink" title="优秀回答"></a>优秀回答</h3><p>面试的重要原则之一就是 WHY，在回答一个知识点的同时，如果能把这个知识点背后的存在原因也讲述清楚，很难不让面试官暗暗点头为你折服，因此你可以考虑从以下这么几个角度出发来进行扩展。</p><ul><li><strong>为什么需要 Top Type 与 Bottom Type ？</strong> 在实际开发中，我们不可能确保对所有地方的类型都进行精确的描述，因此就需要 Top Type 来表示一个包含任意类型的类型。而在类型编程中，如果对两个不存在交集的类型强行进行交集运算，也需要一个类型表示这个不存在的类型。这就是 Top Type 与 Bottom Type 的存在意义。</li><li><strong>类型层级</strong>，Top 与 Bottom 本身就是在描述它们在类型层级中的位置，因此，如果你能给面试官讲一遍从 Bottom 向上到 Top 的类型链，我觉得起码在 TypeScript 这个技能点上你已经基本得到肯定了。</li><li><strong>条件类型</strong>，Top Type 与 Bottom Type 带来的底层规则还不止表现在类型兼容性方面，在条件类型中同样存在对它们的特殊逻辑，请回想 any 与 never 在条件类型中的表现。</li></ul><h2 id="工具类型实现"><a href="#工具类型实现" class="headerlink" title="工具类型实现"></a>工具类型实现</h2><p>这一部分有可能需要你进行手写，但对于完成了整本小册阅读的你来说，肯定不是难事，这一部分就不做过多叙述了。</p><h3 id="及格线-3"><a href="#及格线-3" class="headerlink" title="及格线"></a>及格线</h3><p>比较简单的工具类型手写可能包括 Partial（Require）、Pick（Omit）、ReturnType（ParameterType），小册中均已介绍了相关实现与原理，这里就不再赘述。</p><h3 id="优秀回答-3"><a href="#优秀回答-3" class="headerlink" title="优秀回答"></a>优秀回答</h3><p>在完成手写的基础上，其实你也可以主动进行扩展。</p><ul><li>我不仅能写出这些基础实现，还能写出其在实际应用场景中的增强版，比如 DeepPartial 与 MarkAsPartial，PickByType 与 PickByStrictType 等等。</li><li>我不仅了解这些工具类型的实现，还了解它们可以被归纳为访问性修饰工具类型、结构处理工具类型、集合工具类型与模式匹配工具类型等等，同时对它们实现过程中使用到的类型工具也有较为深入的了解。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一节我们专项学习了几个可能在面试中被作为高频考点的 TypeScript 知识点，至于它们为什么会高频出现，其实也是有原因的，相比其它部分知识，这些考点难度适中，又能很少地筛选掉没有实际使用经验的候选人。而如果要进一步考察技能水平，则可能会考察类型工具使用、类型的控制流分析、复杂的类型编程以及装饰器等知识，这些内容同样在小册中有所体现。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.掌握字面量类型与枚举，让你的类型再精确一些</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/4.%E6%8E%8C%E6%8F%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%9E%9A%E4%B8%BE%EF%BC%8C%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%86%8D%E7%B2%BE%E7%A1%AE%E4%B8%80%E4%BA%9B/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/4.%E6%8E%8C%E6%8F%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%9E%9A%E4%B8%BE%EF%BC%8C%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%86%8D%E7%B2%BE%E7%A1%AE%E4%B8%80%E4%BA%9B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>了解了原始类型与对象类型以后，我们已经能完成简单场景的类型标注了。但这还远远不够，我们还可以让这些类型标注更精确一些。比如，有一个接口结构，它描述了响应的消息结构：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">IRes</span> <span class="token punctuation">&#123;</span>  code<span class="token operator">:</span> <span class="token builtin">number</span>  status<span class="token operator">:</span> <span class="token builtin">string</span>  data<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在大多数情况下，这里的 code 与 status 实际值会来自于一组确定值的集合，比如 code 可能是 10000 / 10001 / 50000，status 可能是 <code>&quot;success&quot;</code> / <code>&quot;failure&quot;</code>。而上面的类型只给出了一个宽泛的 number（string），此时我们既不能在访问 code 时获得精确的提示，也失去了 TypeScript 类型即文档的功能。</p><p>这个时候要怎么做？</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F02-literal-and-enum">Literal and Enum</a></p></blockquote><h2 id="字面量类型与联合类型"><a href="#字面量类型与联合类型" class="headerlink" title="字面量类型与联合类型"></a>字面量类型与联合类型</h2><p>我们可以使用联合类型加上字面量类型，把上面的例子改写成这样：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Res</span> <span class="token punctuation">&#123;</span>  code<span class="token operator">:</span> <span class="token number">10000</span> <span class="token operator">|</span> <span class="token number">10001</span> <span class="token operator">|</span> <span class="token number">50000</span>  status<span class="token operator">:</span> <span class="token string">'success'</span> <span class="token operator">|</span> <span class="token string">'failure'</span>  data<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候，我们就能在访问时获得精确地类型推导了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a428d95d0eee4c269302df47bf45e7b3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="image.png"></p><p>对于 <code>declare var res: Res</code>，你可以认为它其实就是快速生成一个符合指定类型，但没有实际值的变量，同时它也不存在于运行时中。上面引入了一些新的概念，我们来一个一个了解。</p><h2 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h2><p>最开始你可能觉得很神奇，<code>&quot;success&quot;</code> 不是一个值吗？为什么它也可以作为类型？在 TypeScript 中，这叫做<strong>字面量类型（Literal Types）</strong>，它代表着比原始类型更精确的类型，同时也是原始类型的子类型（关于类型层级，我们会在后面详细了解）。</p><p>字面量类型主要包括<strong>字符串字面量类型</strong>、<strong>数字字面量类型</strong>、<strong>布尔字面量类型</strong>和<strong>对象字面量类型</strong>，它们可以直接作为类型标注：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> str<span class="token operator">:</span> <span class="token string">'linbudu'</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span><span class="token keyword">const</span> num<span class="token operator">:</span> <span class="token number">599</span> <span class="token operator">=</span> <span class="token number">599</span><span class="token keyword">const</span> bool<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token operator">=</span> <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>为什么说字面量类型比原始类型更精确？我们可以看这么个例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 报错！不能将类型“"linbudu599"”分配给类型“"linbudu"”。</span><span class="token keyword">const</span> str1<span class="token operator">:</span> <span class="token string">'linbudu'</span> <span class="token operator">=</span> <span class="token string">'linbudu599'</span><span class="token keyword">const</span> str2<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span><span class="token keyword">const</span> str3<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'linbudu599'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码，原始类型的值可以包括任意的同类型值，而字面量类型要求的是<strong>值级别的字面量一致</strong>。</p><p>单独使用字面量类型比较少见，因为单个字面量类型并没有什么实际意义。它通常和联合类型（即这里的 <code>|</code>）一起使用，表达一组字面量类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Tmp</span> <span class="token punctuation">&#123;</span>  bool<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token operator">|</span> <span class="token boolean">false</span>  num<span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span>  str<span class="token operator">:</span> <span class="token string">'lin'</span> <span class="token operator">|</span> <span class="token string">'bu'</span> <span class="token operator">|</span> <span class="token string">'du'</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>而联合类型你可以理解为，它代表了<strong>一组类型的可用集合</strong>，只要最终赋值的类型属于联合类型的成员之一，就可以认为符合这个联合类型。联合类型对其成员并没有任何限制，除了上面这样对同一类型字面量的联合，我们还可以将各种类型混合到一起：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Tmp</span> <span class="token punctuation">&#123;</span>  mixed<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token operator">|</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token number">599</span> <span class="token operator">|</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里有几点需要注意的：</p><ul><li>对于联合类型中的函数类型，需要使用括号<code>()</code>包裹起来</li><li>函数类型并不存在字面量类型，因此这里的 <code>(() =&gt; &#123;&#125;)</code> 就是一个合法的函数类型</li><li>你可以在联合类型中进一步嵌套联合类型，但这些嵌套的联合类型最终都会被展平到第一级中</li></ul><p>联合类型的常用场景之一是通过多个对象类型的联合，来实现手动的互斥属性，即这一属性如果有字段 1，那就没有字段 2：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Tmp</span> <span class="token punctuation">&#123;</span>  user<span class="token operator">:</span>    <span class="token operator">|</span> <span class="token punctuation">&#123;</span>        vip<span class="token operator">:</span> <span class="token boolean">true</span>        expires<span class="token operator">:</span> <span class="token builtin">string</span>      <span class="token punctuation">&#125;</span>    <span class="token operator">|</span> <span class="token punctuation">&#123;</span>        vip<span class="token operator">:</span> <span class="token boolean">false</span>        promotion<span class="token operator">:</span> <span class="token builtin">string</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">declare</span> <span class="token keyword">var</span> tmp<span class="token operator">:</span> Tmp<span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>user<span class="token punctuation">.</span>vip<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>user<span class="token punctuation">.</span>expires<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，user 属性会满足普通用户与 VIP 用户两种类型，这里 vip 属性的类型基于布尔字面量类型声明。我们在实际使用时可以通过判断此属性为 true ，确保接下来的类型推导都会将其类型收窄到 VIP 用户的类型（即联合类型的第一个分支）。这一能力的使用涉及类型守卫与类型控制流分析，我们会在后面的章节详细来说。</p><p>我们也可以通过类型别名来复用一组字面量联合类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Code</span> <span class="token operator">=</span> <span class="token number">10000</span> <span class="token operator">|</span> <span class="token number">10001</span> <span class="token operator">|</span> <span class="token number">50000</span><span class="token keyword">type</span> <span class="token class-name">Status</span> <span class="token operator">=</span> <span class="token string">'success'</span> <span class="token operator">|</span> <span class="token string">'failure'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>除了原始类型的字面量类型以外，对象类型也有着对应的字面量类型。</p><h3 id="对象字面量类型"><a href="#对象字面量类型" class="headerlink" title="对象字面量类型"></a>对象字面量类型</h3><p>类似的，对象字面量类型就是一个对象类型的值。当然，这也就意味着这个对象的值全都为字面量值：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Tmp</span> <span class="token punctuation">&#123;</span>  obj<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token string">'linbudu'</span>    age<span class="token operator">:</span> <span class="token number">18</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> tmp<span class="token operator">:</span> Tmp <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  obj<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token string">'linbudu'</span><span class="token punctuation">,</span>    age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要实现一个对象字面量类型，意味着完全的实现这个类型每一个属性的每一个值。对象字面量类型在实际开发中的使用较少，我们只需要了解。</p><p>总的来说，在需要更精确类型的情况下，我们可以使用字面量类型加上联合类型的方式，将类型从 string 这种宽泛的原始类型直接收窄到 <code>&quot;resolved&quot; | &quot;pending&quot; | &quot;rejected&quot;</code> 这种精确的字面量类型集合。</p><p>需要注意的是，<strong>无论是原始类型还是对象类型的字面量类型，它们的本质都是类型而不是值</strong>。它们在编译时同样会被擦除，同时也是被存储在内存中的类型空间而非值空间。</p><p>如果说字面量类型是对原始类型的进一步扩展（对象字面量类型的使用较少），那么枚举在某些方面则可以理解为是对对象类型的扩展。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举并不是 JavaScript 中原生的概念，在其他语言中它都是老朋友了（Java、C#、Swift 等）。目前也已经存在给 JavaScript（ECMAScript）引入枚举支持的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frbuckton%2Fproposal-enum">proposal-enum</a> 提案，但还未被提交给 TC39 ，仍处于 Stage 0 阶段。</p><p>如果要和 JavaScript 中现有的概念对比，我想最贴切的可能就是你曾经写过的 constants 文件了：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">Home_Page_Url</span><span class="token operator">:</span> <span class="token string">'url1'</span><span class="token punctuation">,</span>  <span class="token literal-property property">Setting_Page_Url</span><span class="token operator">:</span> <span class="token string">'url2'</span><span class="token punctuation">,</span>  <span class="token literal-property property">Share_Page_Url</span><span class="token operator">:</span> <span class="token string">'url3'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token comment">// 或是这样：</span><span class="token keyword">export</span> <span class="token keyword">const</span> PageUrl <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">Home_Page_Url</span><span class="token operator">:</span> <span class="token string">'url1'</span><span class="token punctuation">,</span>  <span class="token literal-property property">Setting_Page_Url</span><span class="token operator">:</span> <span class="token string">'url2'</span><span class="token punctuation">,</span>  <span class="token literal-property property">Share_Page_Url</span><span class="token operator">:</span> <span class="token string">'url3'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果把这段代码替换为枚举，会是如下的形式：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">enum</span> PageUrl <span class="token punctuation">&#123;</span>  Home_Page_Url <span class="token operator">=</span> <span class="token string">'url1'</span><span class="token punctuation">,</span>  Setting_Page_Url <span class="token operator">=</span> <span class="token string">'url2'</span><span class="token punctuation">,</span>  Share_Page_Url <span class="token operator">=</span> <span class="token string">'url3'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> home <span class="token operator">=</span> PageUrl<span class="token punctuation">.</span>Home_Page_Url<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这么做的好处非常明显。首先，你拥有了更好的类型提示。其次，这些常量被真正地<strong>约束在一个命名空间</strong>下（上面的对象声明总是差点意思）。如果你没有声明枚举的值，它会默认使用数字枚举，并且从 0 开始，以 1 递增：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">enum</span> Items <span class="token punctuation">&#123;</span>  Foo<span class="token punctuation">,</span>  Bar<span class="token punctuation">,</span>  Baz<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，<code>Items.Foo</code> , <code>Items.Bar</code> , <code>Items.Baz</code>的值依次是 0，1，2 。</p><p>如果你只为某一个成员指定了枚举值，那么之前未赋值成员仍然会使用从 0 递增的方式，之后的成员则会开始从枚举值递增。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">enum</span> Items <span class="token punctuation">&#123;</span>  <span class="token comment">// 0</span>  Foo<span class="token punctuation">,</span>  Bar <span class="token operator">=</span> <span class="token number">599</span><span class="token punctuation">,</span>  <span class="token comment">// 600</span>  Baz<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在数字型枚举中，你可以使用延迟求值的枚举值，比如函数：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token function-variable function">returnNum</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">499</span><span class="token keyword">enum</span> Items <span class="token punctuation">&#123;</span>  Foo <span class="token operator">=</span> <span class="token function">returnNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  Bar <span class="token operator">=</span> <span class="token number">599</span><span class="token punctuation">,</span>  Baz<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但要注意，延迟求值的枚举值是有条件的。<strong>如果你使用了延迟求值，那么没有使用延迟求值的枚举成员必须放在使用常量枚举值声明的成员之后（如上例），或者放在第一位</strong>：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">enum</span> Items <span class="token punctuation">&#123;</span>  Baz<span class="token punctuation">,</span>  Foo <span class="token operator">=</span> <span class="token function">returnNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  Bar <span class="token operator">=</span> <span class="token number">599</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TypeScript 中也可以同时使用字符串枚举值和数字枚举值：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">enum</span> Mixed <span class="token punctuation">&#123;</span>  Num <span class="token operator">=</span> <span class="token number">599</span><span class="token punctuation">,</span>  Str <span class="token operator">=</span> <span class="token string">'linbudu'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>枚举和对象的重要差异在于，<strong>对象是单向映射的</strong>，我们只能从键映射到键值。而<strong>枚举是双向映射的</strong>，即你可以从枚举成员映射到枚举值，也可以从枚举值映射到枚举成员：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">enum</span> Items <span class="token punctuation">&#123;</span>  Foo<span class="token punctuation">,</span>  Bar<span class="token punctuation">,</span>  Baz<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> fooValue <span class="token operator">=</span> Items<span class="token punctuation">.</span>Foo <span class="token comment">// 0</span><span class="token keyword">const</span> fooKey <span class="token operator">=</span> Items<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">// "Foo"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要了解这一现象的本质，我们需要来看一看枚举的编译产物，如以上的枚举会被编译为以下 JavaScript 代码：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token string">'use strict'</span><span class="token keyword">var</span> Items<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>Items<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Items<span class="token punctuation">[</span><span class="token punctuation">(</span>Items<span class="token punctuation">[</span><span class="token string">'Foo'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Foo'</span>  Items<span class="token punctuation">[</span><span class="token punctuation">(</span>Items<span class="token punctuation">[</span><span class="token string">'Bar'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Bar'</span>  Items<span class="token punctuation">[</span><span class="token punctuation">(</span>Items<span class="token punctuation">[</span><span class="token string">'Baz'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Baz'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Items <span class="token operator">||</span> <span class="token punctuation">(</span>Items <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>obj[k] = v</code> 的返回值即是 v，因此这里的 <code>obj[obj[k] = v] = k</code> 本质上就是进行了 <code>obj[k] = v</code> 与 <code>obj[v] = k</code> 这样两次赋值。</p><p>但需要注意的是，仅有值为数字的枚举成员才能够进行这样的双向枚举，<strong>字符串枚举成员仍然只会进行单次映射</strong>：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">enum</span> Items <span class="token punctuation">&#123;</span>  Foo<span class="token punctuation">,</span>  Bar <span class="token operator">=</span> <span class="token string">'BarValue'</span><span class="token punctuation">,</span>  Baz <span class="token operator">=</span> <span class="token string">'BazValue'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token comment">// 编译结果，只会进行 键-值 的单向映射</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token string">'use strict'</span><span class="token punctuation">)</span><span class="token keyword">var</span> Items<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>Items<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Items<span class="token punctuation">[</span><span class="token punctuation">(</span>Items<span class="token punctuation">[</span><span class="token string">'Foo'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Foo'</span>  Items<span class="token punctuation">[</span><span class="token string">'Bar'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'BarValue'</span>  Items<span class="token punctuation">[</span><span class="token string">'Baz'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'BazValue'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Items <span class="token operator">||</span> <span class="token punctuation">(</span>Items <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了数字枚举与字符串枚举这种分类以外，其实还存在着普通枚举与常量枚举这种分类方式。</p><h3 id="常量枚举"><a href="#常量枚举" class="headerlink" title="常量枚举"></a>常量枚举</h3><p>常量枚举和枚举相似，只是其声明多了一个 const：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token keyword">enum</span> Items <span class="token punctuation">&#123;</span>  Foo<span class="token punctuation">,</span>  Bar<span class="token punctuation">,</span>  Baz<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> fooValue <span class="token operator">=</span> Items<span class="token punctuation">.</span>Foo <span class="token comment">// 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它和普通枚举的差异主要在访问性与编译产物。对于常量枚举，你<strong>只能通过枚举成员访问枚举值</strong>（而不能通过值访问成员）。同时，在编译产物中并不会存在一个额外的辅助对象（如上面的 Items 对象），对枚举成员的访问会被<strong>直接内联替换为枚举的值</strong>。以上的代码会被编译为如下形式：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> fooValue <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">/* Foo */</span> <span class="token comment">// 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>实际上，常量枚举的表现、编译产物还受到配置项 <code>--isolatedModules</code> 以及 <code>--preserveConstEnums</code> 等的影响，我们会在后面的 TSConfig 详解中了解更多。</p></blockquote><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节中，我们了解了字面量类型和枚举的使用，包括字面量类型的分类，与联合类型的结合使用，以及枚举与其编译产物等等。</p><p>对于字面量类型，我们可以使用它来提供更精确的类型标注。比如，你可以将如用户类型与请求状态码这一类属性的类型，都使用<strong>字面量类型＋联合类型</strong>的形式改写，获得更详细的类型信息与更严格的类型约束。</p><p>而对于枚举，我们可以使用它来替换掉之前使用对象进行常量收敛的代码，而如果你希望减少编译后的代码，可以进一步地使用在编译后会被完全抹除的常量枚举。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="类型控制流分析中的字面量类型"><a href="#类型控制流分析中的字面量类型" class="headerlink" title="类型控制流分析中的字面量类型"></a>类型控制流分析中的字面量类型</h3><p>除了手动声明字面量类型以外，实际上 TypeScript 也会在某些情况下将变量类型推导为字面量类型，看这个例子：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eecde2e8de214264a42dd74da8c8e17b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="image.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6931f3897d674a8d9803164e5f4d7f2f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="image.png"></p><p>你会发现，使用 const 声明的变量，其类型会从值推导出最精确的字面量类型。而对象类型则只会推导至符合其属性结构的接口，不会使用字面量类型：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/742ad435155e41e293abedf0fe8d053e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="image.png"></p><p>要解答这个现象，需要你回想 let 和 const 声明的意义。我们知道，使用 let 声明的变量是可以再次赋值的，在 TypeScript 中要求赋值类型始终与原类型一致（如果声明了的话）。因此对于 let 声明，<strong>只需要推导至这个值从属的类型即可</strong>。而 const 声明的原始类型变量将不再可变，因此类型可以直接一步到位收窄到最精确的字面量类型，但对象类型变量仍可变（但同样会要求其属性值类型保持一致）。</p><p>这些现象的本质都是 TypeScript 的类型控制流分析，我们会在后面的类型系统部分中讲到。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.探秘内置类型：any、unknown、never 与类型断言</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/6.%E6%8E%A2%E7%A7%98%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%EF%BC%9Aany%E3%80%81unknown%E3%80%81never%20%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/6.%E6%8E%A2%E7%A7%98%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%EF%BC%9Aany%E3%80%81unknown%E3%80%81never%20%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>此前我们学习基础类型标注、字面量类型与枚举、函数与 Class 等概念时，实际上一直在用 JavaScript 的概念来进行映射，或者说这可以看作是 JavaScript 代码到 TypeScript 代码的第一步迁移。而这一节，我们要学习的则是，<strong>如何使用 TypeScript 提供的内置类型在类型世界里获得更好的编程体验</strong>。</p><p>首先是内置的可用于标注的类型，包括 any、unknown 与 never，加上这一部分我们就掌握了 TypeScript 中所有的内置类型标注。然后是类型断言这一重要能力，我们会介绍它的正确使用场景、双重断言与非空断言等，以及类型断言的幕后原理——类型层级。</p><p>这一节是全新的知识，JavaScript 中基本没有类似的概念。但你也不用担心，我们会一步一步从 0 开始学习，让你顺利进入类型编程的世界。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F04-any-unknown-never">Any &amp; Unknown &amp; Never</a></p></blockquote><h2 id="内置类型：any-、unknown-与-never"><a href="#内置类型：any-、unknown-与-never" class="headerlink" title="内置类型：any 、unknown 与 never"></a>内置类型：any 、unknown 与 never</h2><p>有些时候，我们的 TS 代码并不需要十分精确严格的类型标注。比如 console.log 方法就能够接受任意类型的参数，不管你是数组、字符串、对象或是其他的，统统来者不拒。那么，我们难道要把所有类型用联合类型串起来？</p><p>这当然不现实，为了能够表示“任意类型”，TypeScript 中提供了一个内置类型 any ，来表示所谓的任意类型。此时我们就可以使用 any 作为参数的类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token operator">...</span>optionalParams<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这里，一个被标记为 any 类型的参数可以接受任意类型的值。除了 message 是 any 以外，optionalParams 作为一个 rest 参数，也使用 <code>any[]</code> 进行了标记，这就意味着你可以使用任意类型的任意数量类型来调用这个方法。除了显式的标记一个变量或参数为 any，在某些情况下你的变量/参数也会被隐式地推导为 any。比如使用 let 声明一个变量但不提供初始值，以及不为函数参数提供类型标注：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// any</span><span class="token keyword">let</span> foo<span class="token comment">// foo、bar 均为 any</span><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> bar<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上的函数声明在 tsconfig 中启用了 <code>noImplicitAny</code> 时会报错，你可以显式为这两个参数指定 any 类型，或者暂时关闭这一配置（不推荐）。而 any 类型的变量几乎无所不能，它可以在声明后再次接受任意类型的值，同时可以被赋值给任意其它类型的变量：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 被标记为 any 类型的变量可以拥有任意类型的值</span><span class="token keyword">let</span> anyVar<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span>anyVar <span class="token operator">=</span> <span class="token boolean">false</span>anyVar <span class="token operator">=</span> <span class="token string">'linbudu'</span>anyVar <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  site<span class="token operator">:</span> <span class="token string">'juejin'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token function-variable function">anyVar</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 标记为具体类型的变量也可以接受任何 any 类型的值</span><span class="token keyword">const</span> val1<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> anyVar<span class="token keyword">const</span> val2<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> anyVar<span class="token keyword">const</span> <span class="token function-variable function">val3</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> anyVar<span class="token keyword">const</span> val4<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> anyVar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以在 any 类型变量上任意地进行操作，包括赋值、访问、方法调用等等，此时可以认为类型推导与检查是被完全禁用的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">let</span> anyVar<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token keyword">null</span>anyVar<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>bar<span class="token punctuation">.</span><span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span>anyVar<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>prop1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>而 any 类型的主要意义，其实就是为了表示一个<strong>无拘无束的“任意类型”，它能兼容所有类型，也能够被所有类型兼容</strong>。这一作用其实也意味着类型世界给你开了一个外挂，无论什么时候，你都可以使用 any 类型跳过类型检查。当然，运行时出了问题就需要你自己负责了。</p><blockquote><p>any 的本质是类型系统中的顶级类型，即 Top Type，这是许多类型语言中的重要概念，我们会在类型层级部分讲解。</p></blockquote><p>any 类型的万能性也导致我们经常滥用它，比如类型不兼容了就 any 一下，类型不想写了也 any 一下，不确定可能会是啥类型还是 any 一下。此时的 TypeScript 就变成了令人诟病的 AnyScript。为了避免这一情况，我们要记住以下使用小 tips ：</p><ul><li>如果是类型不兼容报错导致你使用 any，考虑用类型断言替代，我们下面就会开始介绍类型断言的作用。</li><li>如果是类型太复杂导致你不想全部声明而使用 any，考虑将这一处的类型去断言为你需要的最简类型。如你需要调用 <code>foo.bar.baz()</code>，就可以先将 foo 断言为一个具有 bar 方法的类型。</li><li>如果你是想表达一个未知类型，更合理的方式是使用 unknown。</li></ul><p>unknown 类型和 any 类型有些类似，一个 unknown 类型的变量可以再次赋值为任意其它类型，但只能赋值给 any 与 unknown 类型的变量：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">let</span> unknownVar<span class="token operator">:</span> <span class="token builtin">unknown</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span>unknownVar <span class="token operator">=</span> <span class="token boolean">false</span>unknownVar <span class="token operator">=</span> <span class="token string">'linbudu'</span>unknownVar <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  site<span class="token operator">:</span> <span class="token string">'juejin'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token function-variable function">unknownVar</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> val1<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> unknownVar <span class="token comment">// Error</span><span class="token keyword">const</span> val2<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> unknownVar <span class="token comment">// Error</span><span class="token keyword">const</span> <span class="token function-variable function">val3</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> unknownVar <span class="token comment">// Error</span><span class="token keyword">const</span> val4<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> unknownVar <span class="token comment">// Error</span><span class="token keyword">const</span> val5<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> unknownVar<span class="token keyword">const</span> val6<span class="token operator">:</span> <span class="token builtin">unknown</span> <span class="token operator">=</span> unknownVar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>unknown 和 any 的一个主要差异体现在赋值给别的变量时，any 就像是 <strong>“我身化万千无处不在”</strong> ，所有类型都把它当自己人。而 unknown 就像是 <strong>“我虽然身化万千，但我坚信我在未来的某一刻会得到一个确定的类型”</strong> ，只有 any 和 unknown 自己把它当自己人。简单地说，any 放弃了所有的类型检查，而 unknown 并没有。这一点也体现在对 unknown 类型的变量进行属性访问时：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">let</span> unknownVar<span class="token operator">:</span> <span class="token builtin">unknown</span>unknownVar<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 报错：对象类型为 unknown</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>要对 unknown 类型进行属性访问，需要进行类型断言（别急，马上就讲类型断言！），即“虽然这是一个未知的类型，但我跟你保证它在这里就是这个类型！”：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">let</span> unknownVar<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">;</span><span class="token punctuation">(</span>unknownVar <span class="token keyword">as</span> <span class="token punctuation">&#123;</span> <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在类型未知的情况下，更推荐使用 unknown 标注。这相当于你使用额外的心智负担保证了类型在各处的结构，后续重构为具体类型时也可以获得最初始的类型信息，同时还保证了类型检查的存在。当然，unknown 用起来很麻烦，一堆类型断言写起来可不太好看。归根结底，到底用哪个完全取决于你自己，毕竟语言只是工具嘛。</p><p>如果说，any 与 unknown 是比原始类型、对象类型等更广泛的类型，也就是说它们更上层一些，就像 string 字符串类型比 <code>&#39;linbudu&#39;</code> 字符串字面量更上层一些，即 any/unknown -&gt; 原始类型、对象类型 -&gt; 字面量类型。那么，<strong>是否存在比字面量类型更底层一些的类型</strong>？</p><p>这里的上层与底层，其实即意味着包含类型信息的多少。any 类型包括了任意的类型，字符串类型包括任意的字符串字面量类型，而字面量类型只表示一个精确的值类型。如要还要更底层，也就是再少一些类型信息，那就只能什么都没有了。</p><p>而内置类型 never 就是这么一个“什么都没有”的类型。此前我们已经了解了另一个“什么都没有”的类型，void。但相比于 void ，never 还要更加空白一些。</p><h3 id="虚无的-never-类型"><a href="#虚无的-never-类型" class="headerlink" title="虚无的 never 类型"></a>虚无的 never 类型</h3><p>是不是有点不好理解？我们看一个联合类型的例子就能 get 到一些了。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">UnionWithNever</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span> <span class="token operator">|</span> <span class="token number">599</span> <span class="token operator">|</span> <span class="token boolean">true</span> <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token operator">|</span> <span class="token builtin">never</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将鼠标悬浮在类型别名之上，你会发现这里显示的类型是<code>&quot;linbudu&quot; | 599 | true | void</code>。never 类型被直接无视掉了，而 void 仍然存在。这是因为，void 作为类型表示一个空类型，就像没有返回值的函数使用 void 来作为返回值类型标注一样，void 类型就像 JavaScript 中的 null 一样代表“这里有类型，但是个空类型”。</p><p>而 never 才是一个“什么都没有”的类型，它甚至不包括空的类型，严格来说，<strong>never 类型不携带任何的类型信息</strong>，因此会在联合类型中被直接移除，比如我们看 void 和 never 的类型兼容性：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">let</span> v1<span class="token operator">:</span> <span class="token builtin">never</span><span class="token keyword">declare</span> <span class="token keyword">let</span> v2<span class="token operator">:</span> <span class="token keyword">void</span>v1 <span class="token operator">=</span> v2 <span class="token comment">// X 类型 void 不能赋值给类型 never</span>v2 <span class="token operator">=</span> v1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在编程语言的类型系统中，never 类型被称为 <strong>Bottom Type</strong>，是<strong>整个类型系统层级中最底层的类型</strong>。和 null、undefined 一样，它是所有类型的子类型，但只有 never 类型的变量能够赋值给另一个 never 类型变量。</p><p>通常我们不会显式地声明一个 never 类型，它主要被类型检查所使用。但在某些情况下使用 never 确实是符合逻辑的，比如一个只负责抛出错误的函数：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">justThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">never</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在类型流的分析中，一旦一个返回值类型为 never 的函数被调用，那么下方的代码都会被视为无效的代码（即无法执行到）：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">justThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">never</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>input <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">justThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 等同于 return 语句后的代码，即 Dead Code</span>    <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">'linbudu'</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们也可以显式利用它来进行类型检查，即上面在联合类型中 never 类型神秘消失的原因。假设，我们需要对一个联合类型的每个类型分支进行不同处理：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">const</span> strOrNumOrBool<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'str!'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'num!'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">'boolean'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bool!'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Unknown input type: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>strOrNumOrBool<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们希望这个变量的每一种类型都需要得到妥善处理，在最后可以抛出一个错误，但这是运行时才会生效的措施，是否能在类型检查时就分析出来？</p><p>实际上，由于 TypeScript 强大的类型分析能力，每经过一个 if 语句处理，<code>strOrNumOrBool</code> 的类型分支就会减少一个（因为已经被对应的 typeof 处理过）。而在最后的 else 代码块中，它的类型只剩下了 never 类型，即一个无法再细分、本质上并不存在的虚空类型。在这里，我们可以利用 never 类型变量仅能赋值给 never 类型变量的特性，来巧妙地分支处理检查：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 一定是字符串！</span>  strOrNumOrBool<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  strOrNumOrBool<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">'boolean'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  strOrNumOrBool <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> _exhaustiveCheck<span class="token operator">:</span> <span class="token builtin">never</span> <span class="token operator">=</span> strOrNumOrBool  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Unknown input type: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>_exhaustiveCheck<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设某个粗心的同事新增了一个类型分支，<code>strOrNumOrBool</code> 变成了 <code>strOrNumOrBoolOrFunc</code>，却忘记新增对应的处理分支，此时在 else 代码块中就会出现将 Function 类型赋值给 never 类型变量的类型错误。这实际上就是利用了类型分析能力与 never 类型只能赋值给 never 类型这一点，来确保联合类型变量被妥善处理。</p><p>前面我们提到了主动使用 never 类型的两种方式，而 never 其实还会在某些情况下不请自来。比如说，你可能遇到过这样的类型错误：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">)</span> <span class="token comment">// 类型“string”的参数不能赋给类型“never”的参数。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时这个未标明类型的数组被推导为了 <code>never[]</code> 类型，这种情况仅会在你启用了 <code>strictNullChecks</code> 配置，同时禁用了 <code>noImplicitAny</code> 配置时才会出现。解决的办法也很简单，为这个数组声明一个具体类型即可。关于这两个配置的具体作用，我们会在后面有详细的介绍。</p><p>在这一部分，我们了解了 TypeScript 中 <strong>Top Type</strong>(any / unknown) 与 <strong>Bottom Type</strong>（never）它们的表现。在讲 any 的时候，我们在小 tips 中提到，可以使用类型断言来避免对 any 类型的滥用。那么接下来，我们就来学习类型断言这一概念。</p><h2 id="类型断言：警告编译器不准报错"><a href="#类型断言：警告编译器不准报错" class="headerlink" title="类型断言：警告编译器不准报错"></a>类型断言：警告编译器不准报错</h2><p>类型断言能够显式告知类型检查程序当前这个变量的类型，可以进行类型分析地修正、类型。它其实就是一个将变量的已有类型更改为新指定类型的操作，它的基本语法是 <code>as NewType</code>，你可以将 any / unknown 类型断言到一个具体的类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">let</span> unknownVar<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">;</span><span class="token punctuation">(</span>unknownVar <span class="token keyword">as</span> <span class="token punctuation">&#123;</span> <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>还可以 as 到 any 来为所欲为，跳过所有的类型检查：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> str<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span><span class="token punctuation">;</span><span class="token punctuation">(</span>str <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>也可以在联合类型中断言一个具体的分支：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>union<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>union <span class="token keyword">as</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>union <span class="token keyword">as</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'599'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是类型断言的正确使用方式是，在 TypeScript 类型分析不正确或不符合预期时，将其断言为此处的正确类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">IFoo</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">declare</span> <span class="token keyword">const</span> obj<span class="token operator">:</span> <span class="token punctuation">&#123;</span>  foo<span class="token operator">:</span> IFoo<span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> foo <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">as</span> IFoo <span class="token punctuation">&#125;</span> <span class="token operator">=</span> obj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里从 <code>&#123;&#125;</code> 字面量类型断言为了 <code>IFoo</code> 类型，即为解构赋值默认值进行了预期的类型断言。当然，更严谨的方式应该是定义为 <code>Partial&lt;IFoo&gt;</code> 类型，即 IFoo 的属性均为可选的。</p><p>除了使用 as 语法以外，你也可以使用 <code>&lt;&gt;</code> 语法。它虽然书写更简洁，但效果一致，只是在 TSX 中尖括号断言并不能很好地被分析出来。你也可以通过 TypeScript ESLint 提供的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftypescript-eslint%2Ftypescript-eslint%2Fblob%2Fmain%2Fpackages%2Feslint-plugin%2Fdocs%2Frules%2Fconsistent-type-assertions.md"><code>consistent-type-assertions</code></a> 规则来约束断言风格。</p><p>需要注意的是，类型断言应当是在迫不得己的情况下使用的。虽然说我们可以用类型断言纠正不正确的类型分析，但类型分析在大部分场景下还是可以智能地满足我们需求的。</p><p>总的来说，在实际场景中，还是 <code>as any</code> 这一种操作更多。但这也是让你的代码编程 AnyScript 的罪魁祸首之一，请务必小心使用。</p><h3 id="双重断言"><a href="#双重断言" class="headerlink" title="双重断言"></a>双重断言</h3><p>如果在使用类型断言时，原类型与断言类型之间差异过大，也就是指鹿为马太过离谱，离谱到了指鹿为霸王龙的程度，TypeScript 会给你一个类型报错：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> str<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span><span class="token comment">// 从 X 类型 到 Y 类型的断言可能是错误的，blabla</span><span class="token punctuation">;</span><span class="token punctuation">(</span>str <span class="token keyword">as</span> <span class="token punctuation">&#123;</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此时它会提醒你先断言到 unknown 类型，再断言到预期类型，就像这样：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> str<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span><span class="token punctuation">;</span><span class="token punctuation">(</span>str <span class="token keyword">as</span> <span class="token builtin">unknown</span> <span class="token keyword">as</span> <span class="token punctuation">&#123;</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 使用尖括号断言</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token punctuation">&#123;</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token builtin">unknown</span><span class="token operator">></span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为你的断言类型和原类型的差异太大，需要先断言到一个通用的类，即 any / unknown。这一通用类型包含了所有可能的类型，因此<strong>断言到它</strong>和<strong>从它断言到另一个类型</strong>差异不大。</p><h3 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h3><p>非空断言其实是类型断言的简化，它使用 <code>!</code> 语法，即 <code>obj!.func()!.prop</code> 的形式标记前面的一个声明一定是非空的（实际上就是剔除了 null 和 undefined 类型），比如这个例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">const</span> foo<span class="token operator">:</span> <span class="token punctuation">&#123;</span>  func<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    prop<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword">null</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>foo<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prop<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，func 在 foo 中不一定存在，prop 在 func 调用结果中不一定存在，且可能为 null，我们就会收获两个类型报错。如果不管三七二十一地坚持调用，想要解决掉类型报错就可以使用非空断言：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">foo<span class="token punctuation">.</span>func<span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prop<span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其应用位置类似于可选链：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">foo<span class="token punctuation">.</span>func<span class="token operator">?.</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prop<span class="token operator">?.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但不同的是，非空断言的运行时仍然会保持调用链，因此在运行时可能会报错。而可选链则会在某一个部分收到 undefined 或 null 时直接短路掉，不会再发生后面的调用。</p><p>非空断言的常见场景还有 <code>document.querySelector</code>、<code>Array.find</code> 方法等：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#id'</span><span class="token punctuation">)</span><span class="token operator">!</span><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">599</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">=></span> item <span class="token operator">===</span> <span class="token number">599</span><span class="token punctuation">)</span><span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为什么说非空断言是类型断言的简写？因为上面的非空断言实际上等价于以下的类型断言操作：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token punctuation">;</span><span class="token punctuation">(</span>  <span class="token punctuation">(</span>    foo<span class="token punctuation">.</span>func <span class="token keyword">as</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      prop<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prop <span class="token keyword">as</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>怎么样，非空断言是不是简单多了？你可以通过 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftypescript-eslint%2Ftypescript-eslint%2Fblob%2Fmain%2Fpackages%2Feslint-plugin%2Fdocs%2Frules%2Fnon-nullable-type-assertion-style.md"><code>non-nullable-type-assertion-style</code></a> 规则来检查代码中是否存在类型断言能够被简写为非空断言的情况。</p><p>类型断言还有一种用法是作为代码提示的辅助工具，比如对于以下这个稍微复杂的接口：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">IStruct</span> <span class="token punctuation">&#123;</span>  foo<span class="token operator">:</span> <span class="token builtin">string</span>  bar<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    barPropA<span class="token operator">:</span> <span class="token builtin">string</span>    barPropB<span class="token operator">:</span> <span class="token builtin">number</span>    <span class="token function-variable function">barMethod</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span>    baz<span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设你想要基于这个结构随便实现一个对象，你可能会使用类型标注：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> obj<span class="token operator">:</span> IStruct <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个时候等待你的是一堆类型报错，你必须规规矩矩地实现整个接口结构才可以。但如果使用类型断言，我们可以在保留类型提示的前提下，不那么完整地实现这个结构：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 这个例子是不会报错的</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token operator">&lt;</span>IStruct<span class="token operator">></span><span class="token punctuation">&#123;</span>  bar<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    baz<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类型提示仍然存在：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa8331c0f2e7484784c442dc822a2c98~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>在你错误地实现结构时仍然可以给到你报错信息：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/533a1b0315934f0fb4e6a831970b71c0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节中，我们学习了 TypeScript 中的内置类型 any、unknown 与 never，包括它们的类型兼容性表现与使用场景。而在另外一部分类型断言中，我们了解了类型断言的基本使用，以及结合内置类型 any 的使用场景。</p><p>在下一节，我们会开始对 TypeScript 类型工具的学习，进一步探索 TypeScript 的类型世界，包括类型别名、交叉类型、索引类型、映射类型等等。如果说基础类型是积木，那这些类型工具就是积木工厂？它们在基础类型的基础之上进行类型编程运算如组合、过滤等，得到更贴近你实际需要形状的积木，也带你认识到，原来不止可以对变量进行编程，类型也可以！</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="类型层级初探"><a href="#类型层级初探" class="headerlink" title="类型层级初探"></a>类型层级初探</h3><p>这一节的知识点其实都和 TypeScript 的类型层级有所关联，我们会在后面的类型系统部分有专门一节进行详细地讲述，这里只做简单地描述来供有兴趣的同学提前了解。</p><p>前面我们已经说到，any 与 unknown 属于 <strong>Top Type</strong>，表现在它们包含了所有可能的类型，而 never 属于 <strong>Bottom Type</strong>，表现在它是一个虚无的、不存在的类型。那么加上此前学习的原始类型与字面量类型等，按照类型的包含来进行划分，我们大概能梳理出这么个类型层级关系。</p><ul><li>最顶级的类型，any 与 unknown</li><li>特殊的 Object ，它也包含了所有的类型，但和 Top Type 比还是差了一层</li><li>String、Boolean、Number 这些装箱类型</li><li>原始类型与对象类型</li><li>字面量类型，即更精确的原始类型与对象类型嘛，需要注意的是 null 和 undefined 并不是字面量类型的子类型</li><li>最底层的 never</li></ul><blockquote><p>实际上这个层级链并不完全，因为还有联合类型、交叉类型、函数类型的情况，我们会在后面专门有一节进行讲解~</p></blockquote><p>而实际上类型断言的工作原理也和类型层级有关，在判断断言是否成立，即差异是否能接受时，实际上判断的即是这两个类型是否能够找到一个公共的父类型。比如 <code>&#123; &#125;</code> 和 <code>&#123; name: string &#125;</code> 其实可以认为拥有公共的父类型 <code>&#123;&#125;</code>（一个新的 <code>&#123;&#125;</code>！你可以理解为这是一个基类，参与断言的 <code>&#123; &#125;</code> 和 <code>&#123; name: string &#125;</code> 其实是它的派生类）。</p><p>如果找不到具有意义的公共父类型呢？这个时候就需要请出 <strong>Top Type</strong> 了，如果我们把它先断言到 <strong>Top Type</strong>，那么就拥有了公共父类型 <strong>Top Type</strong>，再断言到具体的类型也是同理。你可以理解为先向上断言，再向下断言，比如前面的双重断言可以改写成这样：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> str<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span><span class="token punctuation">;</span><span class="token punctuation">(</span>str <span class="token keyword">as</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token punctuation">&#123;</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">as</span> <span class="token punctuation">&#123;</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这一部分的扩展阅读只是为了让你提前意识到类型层级的存在，并不需要完全理解，毕竟我们后面还有一整节会讲类型系统层级呢。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.函数与 Class 中的类型：详解函数重载与面向对象</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/5.%E5%87%BD%E6%95%B0%E4%B8%8E%20Class%20%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%9A%E8%AF%A6%E8%A7%A3%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/5.%E5%87%BD%E6%95%B0%E4%B8%8E%20Class%20%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%9A%E8%AF%A6%E8%A7%A3%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>在前面的入门环节中，我们了解了日常开发中最常用的、基础的变量类型标注，包括原始类型、对象类型、字面量类型与枚举类型。而实际开发中还有一个重要的朋友：<strong>函数</strong>。函数能够帮助我们进一步抽离与封装代码逻辑，所以掌握函数类型必不可少。如果说函数代表着面向过程的编程，那么 Class 则代表着面向对象的编程，而它也是 ES6 新特性的重要一部分———我们终于可以和各种花式继承告别了。</p><p>这一节，我们会介绍函数与 Class 的类型标注，以及一些在 TypeScript 中独有或相比 JavaScript 更加完全的概念，如<strong>重载</strong>与<strong>面向对象的编程</strong>等。函数部分，我们主要关注其参数类型、返回值类型以及重载的应用。 Class 部分，除了类型以外，我们还会学习访问性修饰符、继承、抽象类等来自于面向对象理念的实际使用。</p><p>这一节之后，我们就算正式入门 TypeScript 了。此时，你已经掌握了从 JavaScript 迁移到 TypeScript 后的主要技巧，可以开始大胆地在新项目中使用 TypeScript 了。</p><p>是不是很期待？让我们赶快开始今天的课程吧！</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F03-function-and-class">Function and Class</a></p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的类型签名"><a href="#函数的类型签名" class="headerlink" title="函数的类型签名"></a>函数的类型签名</h3><p>如果说变量的类型是描述了这个变量的值类型，那么函数的类型就是描述了<strong>函数入参类型与函数返回值类型</strong>，它们同样使用<code>:</code>的语法进行类型标注。我们直接看最简单的例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> name<span class="token punctuation">.</span>length<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在函数类型中同样存在着类型推导。比如在这个例子中，你可以不写返回值处的类型，它也能被正确推导为 number 类型。</p><p>在 JavaScript 中，我们称 <code>function name () &#123;&#125;</code> 这一声明函数的方式为<strong>函数声明（*Function Declaration*）</strong>。除了函数声明以外，我们还可以通过<strong>函数表达式（*Function Expression*）</strong>，即 <code>const foo = function()&#123;&#125;</code> 的形式声明一个函数。在表达式中进行类型声明的方式是这样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> name<span class="token punctuation">.</span>length<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们也可以像对变量进行类型标注那样，对 <code>foo</code> 这个变量进行类型声明：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function-variable function">number</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> name<span class="token punctuation">.</span>length<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的 <code>(name: string) =&gt; number</code> 看起来很眼熟，对吧？它是 ES6 的重要特性之一：箭头函数。但在这里，它其实是 TypeScript 中的<strong>函数类型签名</strong>。而实际的箭头函数，我们的类型标注也是类似的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 方式一</span><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> name<span class="token punctuation">.</span>length<span class="token punctuation">&#125;</span><span class="token comment">// 方式二</span><span class="token keyword">const</span> <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function-variable function">number</span> <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> name<span class="token punctuation">.</span>length<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在方式二的声明方式中，你会发现函数类型声明混合箭头函数声明时，代码的可读性会非常差。因此，一般不推荐这么使用，要么<strong>直接在函数中进行参数和返回值的类型声明</strong>，要么<strong>使用类型别名将函数声明抽离出来</strong>：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">FuncFoo</span> <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">number</span><span class="token keyword">const</span> foo<span class="token operator">:</span> <span class="token function-variable function">FuncFoo</span> <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> name<span class="token punctuation">.</span>length<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果只是为了描述这个函数的类型结构，我们甚至可以使用 interface 来进行函数声明：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">FuncFooStruct</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这时的 interface 被称为 <strong>Callable Interface</strong>，看起来可能很奇怪，但我们可以这么认为，interface 就是用来描述一个类型结构的，而函数类型本质上也是一个结构固定的类型罢了。</p><h3 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h3><p>在 TypeScript 中，一个没有返回值（即没有调用 return 语句）的函数，其返回类型应当被标记为 void 而不是 undefined，即使它实际的值是 undefined。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 没有调用 return 语句</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 调用了 return 语句，但没有返回值</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原因和我们在原始类型与对象类型一节中讲到的：<strong>在 TypeScript 中，undefined 类型是一个实际的、有意义的类型值，而 void 才代表着空的、没有意义的类型值。</strong> 相比之下，void 类型就像是 JavaScript 中的 null 一样。因此在我们没有实际返回值时，使用 void 类型能更好地说明这个函数<strong>没有进行返回操作</strong>。但在上面的第二个例子中，其实更好的方式是使用 undefined ：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">undefined</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时我们想表达的则是，这个函数<strong>进行了返回操作，但没有返回实际的值</strong>。</p><h3 id="可选参数与-rest-参数"><a href="#可选参数与-rest-参数" class="headerlink" title="可选参数与 rest 参数"></a>可选参数与 rest 参数</h3><p>在很多时候，我们会希望函数的参数可以更灵活，比如它不一定全都必传，当你不传入参数时函数会使用此参数的默认值。正如在对象类型中我们使用 <code>?</code> 描述一个可选属性一样，在函数类型中我们也使用 <code>?</code> 描述一个可选参数：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 在函数逻辑中注入可选参数默认值</span><span class="token keyword">function</span> <span class="token function">foo1</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> age<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> inputAge <span class="token operator">=</span> age <span class="token operator">||</span> <span class="token number">18</span> <span class="token comment">// 或使用 age ?? 18</span>  <span class="token keyword">return</span> name<span class="token punctuation">.</span>length <span class="token operator">+</span> inputAge<span class="token punctuation">&#125;</span><span class="token comment">// 直接为可选参数声明默认值</span><span class="token keyword">function</span> <span class="token function">foo2</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> inputAge <span class="token operator">=</span> age  <span class="token keyword">return</span> name<span class="token punctuation">.</span>length <span class="token operator">+</span> inputAge<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，<strong>可选参数必须位于必选参数之后</strong>。毕竟在 JavaScript 中函数的入参是按照位置（形参），而不是按照参数名（名参）进行传递。当然，我们也可以直接将可选参数与默认值合并，但此时就不能够使用 <code>?</code> 了，因为既然都有默认值，那肯定是可选参数啦。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> inputAge <span class="token operator">=</span> age <span class="token operator">||</span> <span class="token number">18</span>  <span class="token keyword">return</span> name<span class="token punctuation">.</span>length <span class="token operator">+</span> inputAge<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在某些情况下，这里的可选参数类型也可以省略，如这里原始类型的情况可以直接从提供的默认值类型推导出来。但对于联合类型或对象类型的复杂情况，还是需要老老实实地进行标注。</p><p>对于 rest 参数的类型标注也比较简单，由于其实际上是一个数组，这里我们也应当使用数组类型进行标注：</p><blockquote><p>对于 any 类型，你可以简单理解为它包含了一切可能的类型，我们会在下一节详细介绍。</p></blockquote><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>arg1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然，你也可以使用我们前面学习的元祖类型进行标注：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>arg1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">boolean</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>在某些逻辑较复杂的情况下，函数可能有多组入参类型和返回值类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span>foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> bar<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>bar<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">String</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> foo <span class="token operator">*</span> <span class="token number">599</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个实例中，函数的返回类型基于其入参 <code>bar</code> 的值，并且从其内部逻辑中我们知道，当 <code>bar</code> 为 true，返回值为 string 类型，否则为 number 类型。而这里的类型签名完全没有体现这一点，我们只知道它的返回值是这么个联合类型。</p><p>要想实现与入参关联的返回值类型，我们可以使用 TypeScript 提供的<strong>函数重载签名（*Overload Signature*）</strong>，将以上的例子使用重载改写：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span>foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> bar<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span>foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> bar<span class="token operator">?</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span>foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> bar<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>bar<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">String</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> foo <span class="token operator">*</span> <span class="token number">599</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> res1 <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">599</span><span class="token punctuation">)</span> <span class="token comment">// number</span><span class="token keyword">const</span> res2 <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">599</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// string</span><span class="token keyword">const</span> res3 <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">599</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment">// number</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们的三个 <code>function func</code> 其实具有不同的意义：</p><ul><li><code>function func(foo: number, bar: true): string</code>，重载签名一，传入 bar 的值为 true 时，函数返回值为 string 类型。</li><li><code>function func(foo: number, bar?: false): number</code>，重载签名二，不传入 bar，或传入 bar 的值为 false 时，函数返回值为 number 类型。</li><li><code>function func(foo: number, bar?: boolean): string | number</code>，函数的实现签名，会包含重载签名的所有可能情况。</li></ul><p>基于重载签名，我们就实现了将入参类型和返回值类型的可能情况进行关联，获得了更精确的类型标注能力。</p><p>这里有一个需要注意的地方，拥有多个重载声明的函数在被调用时，是按照重载的声明顺序往下查找的。因此在第一个重载声明中，为了与逻辑中保持一致，即在 bar 为 true 时返回 string 类型，这里我们需要将第一个重载声明的 bar 声明为必选的字面量类型。</p><blockquote><p>你可以试着为第一个重载声明的 bar 参数也加上可选符号，然后就会发现第一个函数调用错误地匹配到了第一个重载声明。</p></blockquote><p>实际上，TypeScript 中的重载更像是伪重载，<strong>它只有一个具体实现，其重载体现在方法调用的签名上而非具体实现上</strong>。而在如 C++ 等语言中，重载体现在多个<strong>名称一致但入参不同的函数实现上</strong>，这才是更广义上的函数重载。</p><h3 id="异步函数、Generator-函数等类型签名"><a href="#异步函数、Generator-函数等类型签名" class="headerlink" title="异步函数、Generator 函数等类型签名"></a>异步函数、Generator 函数等类型签名</h3><p>对于异步函数、Generator 函数、异步 Generator 函数的类型签名，其参数签名基本一致，而返回值类型则稍微有些区别：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">genFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Iterable<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">async</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">asyncGenFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> AsyncIterable<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，Generator 函数与异步 Generator 函数现在已经基本不再使用，这里仅做了解即可。而对于异步函数（即标记为 async 的函数），其返回值必定为一个 Promise 类型，而 Promise 内部包含的类型则通过泛型的形式书写，即 <code>Promise&lt;T&gt;</code>（关于泛型我们会在后面进行详细了解）。</p><p>在函数这一节中，我们主要关注函数的类型标注。因为 TypeScript 中的函数实际上相比 JavaScript 也只是多在重载这一点上，我们需要着重掌握的仍然是类型标注。但在 Class 中，我们的学习重点其实更侧重于其语法与面向对象的编程理念。</p><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h3 id="类与类成员的类型签名"><a href="#类与类成员的类型签名" class="headerlink" title="类与类成员的类型签名"></a>类与类成员的类型签名</h3><p>一个函数的主要结构即是参数、逻辑和返回值，对于逻辑的类型标注其实就是对普通代码的标注，所以我们只介绍了对参数以及返回值地类型标注。而到了 Class 中其实也一样，它的主要结构只有<strong>构造函数</strong>、<strong>属性</strong>、<strong>方法</strong>和<strong>访问符（*Accessor*）</strong>，我们也只需要关注这三个部分即可。这里我要说明一点，有的同学可能认为装饰器也是 Class 的结构，但我个人认为它并不是 Class 携带的逻辑，不应该被归类在这里。</p><blockquote><p>而对于这些结构的具体意义以及 Class 的入门语法，你可以阅读阮一峰老师的 ES6 标准入门。</p></blockquote><p>属性的类型标注类似于变量，而构造函数、方法、存取器的类型编标注类似于函数：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  prop<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>inputProp<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>prop <span class="token operator">=</span> inputProp  <span class="token punctuation">&#125;</span>  <span class="token function">print</span><span class="token punctuation">(</span>addon<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>prop<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> and </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>addon<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">get</span> <span class="token function">propA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>prop<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">+A</span><span class="token template-punctuation string">`</span></span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">set</span> <span class="token function">propA</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>prop <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>value<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">+A</span><span class="token template-punctuation string">`</span></span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>唯一需要注意的是，setter 方法<strong>不允许进行返回值的类型标注</strong>，你可以理解为 setter 的返回值并不会被消费，它是一个只关注过程的函数。类的方法同样可以进行函数那样的重载，且语法基本一致，这里我们不再赘述。</p><p>就像函数可以通过<strong>函数声明</strong>与<strong>函数表达式</strong>创建一样，类也可以通过<strong>类声明</strong>和<strong>类表达式</strong>的方式创建。很明显上面的写法即是类声明，而使用类表达式的语法则是这样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> Foo <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token punctuation">&#123;</span>  prop<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>inputProp<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>prop <span class="token operator">=</span> inputProp  <span class="token punctuation">&#125;</span>  <span class="token function">print</span><span class="token punctuation">(</span>addon<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>prop<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> and </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>addon<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>在 TypeScript 中我们能够为 Class 成员添加这些修饰符：<code>public</code> / <code>private</code> / <code>protected</code> / <code>readonly</code>。除 readonly 以外，其他三位都属于访问性修饰符，而 readonly 属于操作性修饰符（就和 interface 中的 readonly 意义一致）。</p><p>这些修饰符应用的位置在成员命名前：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> prop<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>inputProp<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>prop <span class="token operator">=</span> inputProp  <span class="token punctuation">&#125;</span>  <span class="token keyword">protected</span> <span class="token function">print</span><span class="token punctuation">(</span>addon<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>prop<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> and </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>addon<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">get</span> <span class="token function">propA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>prop<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">+A</span><span class="token template-punctuation string">`</span></span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">set</span> <span class="token function">propA</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>propA <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>value<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">+A</span><span class="token template-punctuation string">`</span></span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>我们通常不会为构造函数添加修饰符，而是让它保持默认的 public。在扩展阅读中我们会讲到 private 修饰构造函数的场景。</p></blockquote><p>如果没有其他语言学习经验，你可能不太理解 public / private / protected 的意义，我们简单做个解释。</p><ul><li>public：此类成员在<strong>类、类的实例、子类</strong>中都能被访问。</li><li>private：此类成员仅能在<strong>类的内部</strong>被访问。</li><li>protected：此类成员仅能在<strong>类与子类中</strong>被访问，你可以将类和类的实例当成两种概念，即一旦实例化完毕（出厂零件），那就和类（工厂）没关系了，即<strong>不允许再访问受保护的成员</strong>。</li></ul><p>当你不显式使用访问性修饰符，成员的访问性默认会被标记为 public。实际上，在上面的例子中，我们通过构造函数为类成员赋值的方式还是略显麻烦，需要声明类属性以及在构造函数中进行赋值。简单起见，我们可以<strong>在构造函数中对参数应用访问性修饰符</strong>：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> arg1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token keyword">private</span> arg2<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，参数会被直接作为类的成员（即实例的属性），免去后续的手动赋值。</p><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>在 TypeScript 中，你可以使用 static 关键字来标识一个成员为静态成员：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">static</span> <span class="token function">staticHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token function">instanceHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不同于实例成员，在类的内部静态成员无法通过 this 来访问，需要通过 <code>Foo.staticHandler</code> 这种形式进行访问。我们可以查看编译到 ES5 及以下 target 的 JavaScript 代码（ES6 以上就原生支持静态成员了），来进一步了解它们的区别：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> Foo <span class="token operator">=</span> <span class="token comment">/** @class */</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  Foo<span class="token punctuation">.</span><span class="token function-variable function">staticHandler</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">instanceHandler</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> Foo<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从中我们可以看到，<strong>静态成员直接被挂载在函数体上</strong>，而<strong>实例成员挂载在原型上</strong>，这就是二者的最重要差异：<strong>静态成员不会被实例继承，它始终只属于当前定义的这个类（以及其子类）</strong>。而原型对象上的实例成员则会<strong>沿着原型链进行传递</strong>，也就是能够被继承。</p><p>而对于静态成员和实例成员的使用时机，其实并不需要非常刻意地划分。比如我会用<strong>类 + 静态成员</strong>来收敛变量与 utils 方法：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Utils</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> identifier <span class="token operator">=</span> <span class="token string">'linbudu'</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token function">makeUHappy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    Utils<span class="token punctuation">.</span><span class="token function">studyWithU</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token function">studyWithU</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>Utils<span class="token punctuation">.</span><span class="token function">makeUHappy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="继承、实现、抽象类"><a href="#继承、实现、抽象类" class="headerlink" title="继承、实现、抽象类"></a>继承、实现、抽象类</h3><p>既然说到 Class，那就一定离不开继承。与 JavaScript 一样，TypeScript 中也使用 extends 关键字来实现继承：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对于这里的两个类，比较严谨的称呼是 <strong>基类（*Base*）</strong> 与 <strong>派生类（*Derived*）</strong>。当然，如果你觉得叫父类与子类更容易理解也没问题。关于基类与派生类，我们需要了解的主要是<strong>派生类对基类成员的访问与覆盖操作</strong>。</p><p>基类中的哪些成员能够被派生类访问，完全是由其访问性修饰符决定的。我们在上面其实已经介绍过，派生类中可以访问到使用 <code>public</code> 或 <code>protected</code> 修饰符的基类成员。除了访问以外，基类中的方法也可以在派生类中被覆盖，但我们仍然可以通过 super 访问到基类中的方法：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span>  <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span>  <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在派生类中覆盖基类方法时，我们并不能确保派生类的这一方法能覆盖基类方法，万一基类中不存在这个方法呢？所以，TypeScript 4.3 新增了 <code>override</code> 关键字，来确保派生类尝试覆盖的方法一定在基类中存在定义：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span>  <span class="token function">printWithLove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span>  override <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里 TS 将会给出错误，因为<strong>尝试覆盖的方法并未在基类中声明</strong>。通过这一关键字我们就能确保首先这个方法在基类中存在，同时标识这个方法在派生类中被覆盖了。</p><p>除了基类与派生类以外，还有一个比较重要的概念：<strong>抽象类</strong>。抽象类是对类结构与方法的抽象，简单来说，<strong>一个抽象类描述了一个类中应当有哪些成员（属性、方法等）</strong>，<strong>一个抽象方法描述了这一方法在实际实现中的结构</strong>。我们知道类的方法和函数非常相似，包括结构，因此抽象方法其实描述的就是这个方法的<strong>入参类型</strong>与<strong>返回值类型</strong>。</p><p>抽象类使用 abstract 关键字声明：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbsFoo</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">abstract</span> absProp<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token keyword">abstract</span> <span class="token keyword">get</span> <span class="token function">absGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token keyword">abstract</span> <span class="token function">absMethod</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，抽象类中的成员也需要使用 abstract 关键字才能被视为抽象类成员，如这里的抽象方法。我们可以实现（implements）一个抽象类：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token keyword">implements</span> <span class="token class-name">AbsFoo</span> <span class="token punctuation">&#123;</span>  absProp<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span>  <span class="token keyword">get</span> <span class="token function">absGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token string">'linbudu'</span>  <span class="token punctuation">&#125;</span>  <span class="token function">absMethod</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> name  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，我们必须完全实现这个抽象类的每一个抽象成员。需要注意的是，在 TypeScript 中<strong>无法声明静态的抽象成员</strong>。</p><p>对于抽象类，它的本质就是描述类的结构。看到结构，你是否又想到了 interface？是的。interface 不仅可以声明函数结构，也可以声明类的结构：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">FooStruct</span> <span class="token punctuation">&#123;</span>  absProp<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token keyword">get</span> <span class="token function">absGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token function">absMethod</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token keyword">implements</span> <span class="token class-name">FooStruct</span> <span class="token punctuation">&#123;</span>  absProp<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span>  <span class="token keyword">get</span> <span class="token function">absGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token string">'linbudu'</span>  <span class="token punctuation">&#125;</span>  <span class="token function">absMethod</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> name  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，我们让类去实现了一个接口。这里接口的作用和抽象类一样，都是<strong>描述这个类的结构</strong>。除此以外，我们还可以使用 <strong>Newable Interface</strong> 来描述一个类的结构（类似于描述函数结构的 <strong>Callable Interface</strong>）：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">FooStruct</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Foo<span class="token punctuation">&#125;</span><span class="token keyword">declare</span> <span class="token keyword">const</span> NewableFoo<span class="token operator">:</span> FooStruct<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NewableFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 上面有问题，参考这个</span><span class="token comment">// https://stackoverflow.com/questions/13407036/how-does-interfaces-with-construct-signatures-work</span><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">FooStruct</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">new</span> <span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> Foo<span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">FooFromString</span> <span class="token keyword">implements</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'ctor invoked'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">FooObj</span><span class="token punctuation">(</span>n<span class="token operator">:</span> FooStruct<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">n</span><span class="token punctuation">(</span><span class="token string">'hello!'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">FooObj</span><span class="token punctuation">(</span>FooFromString<span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节，我们了解了 TypeScript 中的函数与类，它们分别代表了面向过程与面向对象的编程理念。对于函数，我们着重了解其结构体的类型，即参数类型（可选参数与剩余参数）与返回值类型的标注。而对于类，实际上我们了解的更多是新的语法，如访问性修饰符 <code>public</code> / <code>private</code> / <code>protected</code> ，操作修饰符 <code>readonly</code> ，静态成员 static ，抽象类 abstract ，以及 override 等在 JavaScript（ECMAScript）中不存在或实现并不完全的能力。</p><p>对于函数与类，你需要更多地实际使用才能掌握得更好。不妨继续对你手上的 JavaScript 进行改造，让函数与类都能披上类型的铠甲，获得完整的类型能力。</p><p>在下一节，我们将要接触的就是 JavaScript 中完全没有类似概念的新朋友了，它们是 TypeScript 类型编程最基础的一部分，包括了 any 、 unknown 、never 内置类型，以及类型断言等概念，这些类型工具会是你以后玩转类型编程时最常打交道的一部分。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="私有构造函数"><a href="#私有构造函数" class="headerlink" title="私有构造函数"></a>私有构造函数</h3><p>上面说到，我们通常不会对类的构造函数进行访问性修饰，如果我们一定要试试呢？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>看起来好像没什么问题，但是当你想要实例化这个类时，一行美丽的操作就会出现：<strong>类的构造函数被标记为私有，且只允许在类内部访问</strong>。</p><p>那这就很奇怪了，我们要一个不能实例化的类有啥用？摆设吗？</p><p>还真不是，有些场景下私有构造函数确实有奇妙的用法，比如像我一样把类作为 utils 方法时，此时 Utils 类内部全部都是静态成员，我们也并不希望真的有人去实例化这个类。此时就可以使用私有构造函数来阻止它被错误地实例化：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Utils</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> identifier <span class="token operator">=</span> <span class="token string">'linbudu'</span>  <span class="token keyword">private</span> <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token function">makeUHappy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者在一个类希望把实例化逻辑通过方法来实现，而不是通过 new 的形式时，也可以使用私有构造函数来达成目的。</p><p>你可能会想到，既然有私有构造函数，那没道理没有受保护的构造函数（<code>protected</code>）啊？还真有。但这里我想留给你自己去探寻，你可以先查找下这么做的意义，再想想，什么场景下我们非用它不可？</p><h3 id="SOLID-原则"><a href="#SOLID-原则" class="headerlink" title="SOLID 原则"></a>SOLID 原则</h3><p>SOLID 原则是面向对象编程中的基本原则，它包括以下这些五项基本原则。</p><p>S，<strong>单一功能原则</strong>，<strong>一个类应该仅具有一种职责</strong>，这也意味着只存在一种原因使得需要修改类的代码。如对于一个数据实体的操作，其读操作和写操作也应当被视为两种不同的职责，并被分配到两个类中。更进一步，对实体的业务逻辑和对实体的入库逻辑也都应该被拆分开来。</p><p>O，<strong>开放封闭原则</strong>，<strong>一个类应该是可扩展但不可修改的</strong>。即假设我们的业务中支持通过微信、支付宝登录，原本在一个 login 方法中进行 if else 判断，假设后面又新增了抖音登录、美团登录，难道要再加 else if 分支（或 switch case）吗？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">enum</span> LoginType <span class="token punctuation">&#123;</span>  WeChat<span class="token punctuation">,</span>  TaoBao<span class="token punctuation">,</span>  TikTok<span class="token punctuation">,</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Login</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token function">handler</span><span class="token punctuation">(</span>type<span class="token operator">:</span> LoginType<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> LoginType<span class="token punctuation">.</span>WeChat<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> LoginType<span class="token punctuation">.</span>TikTok<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> LoginType<span class="token punctuation">.</span>TaoBao<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Invalid Login Type!'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然不，基于开放封闭原则，我们应当将登录的基础逻辑抽离出来，不同的登录方式通过扩展这个基础类来实现自己的特殊逻辑。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">LoginHandler</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">abstract</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">WeChatLoginHandler</span> <span class="token keyword">implements</span> <span class="token class-name">LoginHandler</span> <span class="token punctuation">&#123;</span>  <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">TaoBaoLoginHandler</span> <span class="token keyword">implements</span> <span class="token class-name">LoginHandler</span> <span class="token punctuation">&#123;</span>  <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">TikTokLoginHandler</span> <span class="token keyword">implements</span> <span class="token class-name">LoginHandler</span> <span class="token punctuation">&#123;</span>  <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Login</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> handlerMap<span class="token operator">:</span> Record<span class="token operator">&lt;</span>LoginType<span class="token punctuation">,</span> LoginHandler<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span>LoginType<span class="token punctuation">.</span>TaoBao<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">TaoBaoLoginHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span>LoginType<span class="token punctuation">.</span>TikTok<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">TikTokLoginHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span>LoginType<span class="token punctuation">.</span>WeChat<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">WeChatLoginHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token function">handler</span><span class="token punctuation">(</span>type<span class="token operator">:</span> LoginType<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    Login<span class="token punctuation">.</span>handlerMap<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>L，<strong>里式替换原则</strong>，<strong>一个派生类可以在程序的任何一处对其基类进行替换</strong>。这也就意味着，子类完全继承了父类的一切，对父类进行了功能地扩展（而非收窄）。</p><p>I，<strong>接口分离原则</strong>，<strong>类的实现方应当只需要实现自己需要的那部分接口</strong>。比如微信登录支持指纹识别，支付宝支持指纹识别和人脸识别，这个时候微信登录的实现类应该不需要实现人脸识别方法才对。这也就意味着我们提供的抽象类应当按照功能维度拆分成粒度更小的组成才对。</p><p>D，<strong>依赖倒置原则</strong>，这是实现开闭原则的基础，它的核心思想即是<strong>对功能的实现应该依赖于抽象层</strong>，即不同的逻辑通过实现不同的抽象类。还是登录的例子，我们的登录提供方法应该基于共同的登录抽象类实现（LoginHandler），最终调用方法也基于这个抽象类，而不是在一个高阶登录方法中去依赖多个低阶登录提供方。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.类型编程好帮手：TypeScript 类型工具（上）</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/7.%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E5%A5%BD%E5%B8%AE%E6%89%8B%EF%BC%9ATypeScript%20%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/7.%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E5%A5%BD%E5%B8%AE%E6%89%8B%EF%BC%9ATypeScript%20%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>上一节，我们了解了 TypeScript 中的内置类型 any、unknown 与 never，也提到这些内置类型实际上是最基础的“积木”。那想要利用好这些“积木”，我们还需要一些实用的类型工具。它们就像是锤子、锯子和斧子，有了它们的帮助，我们甚至可以拼装出摩天大楼！</p><p>在实际的类型编程中，为了满足各种需求下的类型定义，我们通常会结合使用这些类型工具。因此，我们一定要清楚这些类型工具各自的使用方法和功能。</p><p>所以，接下来我们会用两节课的时间来聊聊这些类型工具。类型工具顾名思义，它就是对类型进行处理的工具。如果按照使用方式来划分，类型工具可以分成三类：<strong>操作符、关键字与专用语法</strong>。我们会在这两节中掌握这些不同的使用方式，以及如何去结合地进行使用。</p><p>而按照使用目的来划分，类型工具可以分为 <strong>类型创建</strong> 与 <strong>类型安全保护</strong> 两类。这一节我们将学习的类型工具就属于类型创建，它们的作用都是基于已有的类型创建新的类型，这些类型工具包括类型别名、交叉类型、索引类型与映射类型。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F05_1-internal-type-tools">Internal Type Tools</a></p></blockquote><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名可以说是 TypeScript 类型编程中最重要的一个功能，从一个简单的函数类型别名，到让你眼花缭乱的类型体操，都离不开类型别名。虽然很重要，但它的使用却并不复杂：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们通过 <code>type</code> 关键字声明了一个类型别名 A ，同时它的类型等价于 string 类型。类型别名的作用主要是对一组类型或一个特定类型结构进行封装，以便于在其它地方进行复用。</p><p>比如抽离一组联合类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">StatusCode</span> <span class="token operator">=</span> <span class="token number">200</span> <span class="token operator">|</span> <span class="token number">301</span> <span class="token operator">|</span> <span class="token number">400</span> <span class="token operator">|</span> <span class="token number">500</span> <span class="token operator">|</span> <span class="token number">502</span><span class="token keyword">type</span> <span class="token class-name">PossibleDataTypes</span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token keyword">const</span> status<span class="token operator">:</span> StatusCode <span class="token operator">=</span> <span class="token number">502</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>抽离一个函数类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Event<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token keyword">const</span> clickHandler<span class="token operator">:</span> <span class="token function-variable function">Handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> moveHandler<span class="token operator">:</span> <span class="token function-variable function">Handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> dragHandler<span class="token operator">:</span> <span class="token function-variable function">Handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>声明一个对象类型，就像接口那样：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ObjType</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关于接口和类型别名的取舍，请参考原始类型与对象类型一节。</p></blockquote><p>看起来类型别名真的非常简单，不就是声明了一个变量让类型声明更简洁和易于拆分吗？如果真的只是把它作为类型别名，用来进行特定类型的抽离封装，那的确很简单。然而，类型别名还能作为工具类型。<strong>工具类同样基于类型别名，只是多了个泛型</strong>。</p><p>如果你还不了解泛型也无需担心，现阶段我们只要了解它和类型别名相关的使用就可以了。至于更复杂的泛型使用场景，我们后面会详细了解。</p><p>在类型别名中，类型别名可以这么声明自己能够接受泛型（我称之为泛型坑位）。一旦接受了泛型，我们就叫它工具类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Factory<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>虽然现在类型别名摇身一变成了工具类型，但它的基本功能仍然是创建类型，只不过工具类型能够接受泛型参数，实现<strong>更灵活的类型创建功能</strong>。从这个角度看，工具类型就像一个函数一样，泛型是入参，内部逻辑基于入参进行某些操作，再返回一个新的类型。比如在上面这个工具类型中，我们就简单接受了一个泛型，然后把它作为联合类型的一个成员，返回了这个联合类型。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> foo<span class="token operator">:</span> Factory<span class="token operator">&lt;</span><span class="token builtin">boolean</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然，我们一般不会直接使用工具类型来做类型标注，而是再度声明一个新的类型别名：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">FactoryWithBool</span> <span class="token operator">=</span> Factory<span class="token operator">&lt;</span><span class="token builtin">boolean</span><span class="token operator">></span><span class="token keyword">const</span> foo<span class="token operator">:</span> FactoryWithBool <span class="token operator">=</span> <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>同时，泛型参数的名称（上面的 T ）也不是固定的。通常我们使用大写的 T / K / U / V / M / O …这种形式。如果为了可读性考虑，我们也可以写成大驼峰形式（即在驼峰命名的基础上，首字母也大写）的名称，比如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Factory<span class="token operator">&lt;</span>NewType<span class="token operator">></span></span> <span class="token operator">=</span> NewType <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>声明一个简单、有实际意义的工具类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">MaybeNull<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">null</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个工具类型会接受一个类型，并返回一个包括 null 的联合类型。这样一来，在实际使用时就可以确保你处理了可能为空值的属性读取与方法调用：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">MaybeNull<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token keyword">function</span> <span class="token function">process</span><span class="token punctuation">(</span>input<span class="token operator">:</span> MaybeNull<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  input<span class="token operator">?.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似的还有 MaybePromise、MaybeArray。这也是我在日常开发中最常使用的一类工具类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">MaybeArray<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment">// 函数泛型我们会在后面了解~</span><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">ensureArray</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>input<span class="token operator">:</span> MaybeArray<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token operator">?</span> input <span class="token operator">:</span> <span class="token punctuation">[</span>input<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，类型别名中可以接受任意个泛型，以及为泛型指定约束、默认值等，这些内容我们都会在泛型一节深入了解。</p><p>总之，对于工具类型来说，它的主要意义是<strong>基于传入的泛型进行各种类型操作</strong>，得到一个新的类型。而这个类型操作的指代就非常非常广泛了，甚至说类型编程的大半难度都在这儿呢，这也是这本小册占据篇幅最多的部分。</p><h2 id="联合类型与交叉类型"><a href="#联合类型与交叉类型" class="headerlink" title="联合类型与交叉类型"></a>联合类型与交叉类型</h2><p>在原始类型与对象类型一节，我们了解了联合类型。但实际上，联合类型还有一个和它有点像的孪生兄弟：<strong>交叉类型</strong>。它和联合类型的使用位置一样，只不过符号是<code>&amp;</code>，即按位与运算符。</p><p>实际上，正如联合类型的符号是<code>|</code>，它代表了按位或，即只需要符合联合类型中的一个类型，既可以认为实现了这个联合类型，如<code>A | B</code>，只需要实现 A 或 B 即可。</p><p>而代表着按位与的 <code>&amp;</code> 则不同，你需要符合这里的所有类型，才可以说实现了这个交叉类型，即 <code>A &amp; B</code>，<strong>需要同时满足 A 与 B 两个类型</strong>才行。</p><p>我们声明一个交叉类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">NameStruct</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">AgeStruct</span> <span class="token punctuation">&#123;</span>  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">ProfileStruct</span> <span class="token operator">=</span> NameStruct <span class="token operator">&amp;</span> AgeStruct<span class="token keyword">const</span> profile<span class="token operator">:</span> ProfileStruct <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token string">'linbudu'</span><span class="token punctuation">,</span>  age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显这里的 profile 对象需要同时符合这两个对象的结构。从另外一个角度来看，ProfileStruct 其实就是一个新的，同时包含 NameStruct 和 AgeStruct 两个接口所有属性的类型。这里是对于对象类型的合并，那对于原始类型呢？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">StrAndNum</span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">&amp;</span> <span class="token builtin">number</span> <span class="token comment">// never</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以看到，它竟然变成 never 了！看起来很奇怪，但想想我们前面给出的定义，新的类型会同时符合交叉类型的所有成员，存在既是 string 又是 number 的类型吗？当然不。实际上，这也是 never 这一 BottomType 的实际意义之一，描述<strong>根本不存在的类型</strong>嘛。</p><p>对于对象类型的交叉类型，其内部的同名属性类型同样会按照交叉类型进行合并：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Struct1</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  primitiveProp<span class="token operator">:</span> <span class="token builtin">string</span>  objectProp<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">Struct2</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  primitiveProp<span class="token operator">:</span> <span class="token builtin">number</span>  objectProp<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    age<span class="token operator">:</span> <span class="token builtin">number</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">Composed</span> <span class="token operator">=</span> Struct1 <span class="token operator">&amp;</span> Struct2<span class="token keyword">type</span> <span class="token class-name">PrimitivePropType</span> <span class="token operator">=</span> Composed<span class="token punctuation">[</span><span class="token string">'primitiveProp'</span><span class="token punctuation">]</span> <span class="token comment">// never</span><span class="token keyword">type</span> <span class="token class-name">ObjectPropType</span> <span class="token operator">=</span> Composed<span class="token punctuation">[</span><span class="token string">'objectProp'</span><span class="token punctuation">]</span> <span class="token comment">// &#123; name: string; age: number; &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是两个联合类型组成的交叉类型呢？其实还是类似的思路，既然只需要实现一个联合类型成员就能认为是实现了这个联合类型，那么各实现两边联合类型中的一个就行了，也就是两边联合类型的交集：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">UnionIntersection1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 1 | 2</span><span class="token keyword">type</span> <span class="token class-name">UnionIntersection2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">symbol</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token builtin">string</span> <span class="token comment">// string</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>总结一下交叉类型和联合类型的区别就是，联合类型只需要符合成员之一即可（<code>||</code>），而交叉类型需要严格符合每一位成员（<code>&amp;&amp;</code>）。</p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>索引类型指的不是某一个特定的类型工具，它其实包含三个部分：<strong>索引签名类型</strong>、<strong>索引类型查询</strong>与<strong>索引类型访问</strong>。目前很多社区的学习教程并没有这一点进行说明，实际上这三者都是独立的类型工具。唯一共同点是，<strong>它们都通过索引的形式来进行类型操作</strong>，但索引签名类型是<strong>声明</strong>，后两者则是<strong>读取</strong>。接下来，我们来依次介绍三个部分。</p><h3 id="索引签名类型"><a href="#索引签名类型" class="headerlink" title="索引签名类型"></a>索引签名类型</h3><p>索引签名类型主要指的是在接口或类型别名中，通过以下语法来<strong>快速声明一个键值类型一致的类型结构</strong>：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">AllStringTypes</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">AllStringTypes</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时，即使你还没声明具体的属性，对于这些类型结构的属性访问也将全部被视为 string 类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">AllStringTypes</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">PropType1</span> <span class="token operator">=</span> AllStringTypes<span class="token punctuation">[</span><span class="token string">'linbudu'</span><span class="token punctuation">]</span> <span class="token comment">// string</span><span class="token keyword">type</span> <span class="token class-name">PropType2</span> <span class="token operator">=</span> AllStringTypes<span class="token punctuation">[</span><span class="token string">'599'</span><span class="token punctuation">]</span> <span class="token comment">// string</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中我们声明的键的类型为 string（<code>[key: string]</code>），这也意味着在实现这个类型结构的变量中<strong>只能声明字符串类型的键</strong>：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">AllStringTypes</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> foo<span class="token operator">:</span> AllStringTypes <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  linbudu<span class="token operator">:</span> <span class="token string">'599'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但由于 JavaScript 中，对于 <code>obj[prop]</code> 形式的访问会将<strong>数字索引访问转换为字符串索引访问</strong>，也就是说， <code>obj[599]</code> 和 <code>obj[&#39;599&#39;]</code> 的效果是一致的。因此，在字符串索引签名类型中我们仍然可以声明数字类型的键。类似的，symbol 类型也是如此：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> foo<span class="token operator">:</span> AllStringTypes <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  linbudu<span class="token operator">:</span> <span class="token string">'599'</span><span class="token punctuation">,</span>  <span class="token number">599</span><span class="token operator">:</span> <span class="token string">'linbudu'</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'ddd'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token string">'symbol'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>索引签名类型也可以和具体的键值对类型声明并存，但这时这些具体的键值类型也需要符合索引签名类型的声明：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">AllStringTypes</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 类型“number”的属性“propA”不能赋给“string”索引类型“boolean”。</span>  propA<span class="token operator">:</span> <span class="token builtin">number</span>  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的符合即指子类型，因此自然也包括联合类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">StringOrBooleanTypes</span> <span class="token punctuation">&#123;</span>  propA<span class="token operator">:</span> <span class="token builtin">number</span>  propB<span class="token operator">:</span> <span class="token builtin">boolean</span>  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>索引签名类型的一个常见场景是在重构 JavaScript 代码时，为内部属性较多的对象声明一个 any 的索引签名类型，以此来暂时支持<strong>对类型未明确属性的访问</strong>，并在后续一点点补全类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">AnyTypeHere</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> foo<span class="token operator">:</span> AnyTypeHere<span class="token punctuation">[</span><span class="token string">'linbudu'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'any value'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="索引类型查询"><a href="#索引类型查询" class="headerlink" title="索引类型查询"></a>索引类型查询</h3><p>刚才我们已经提到了索引类型查询，也就是 keyof 操作符。严谨地说，它可以将对象中的所有键转换为对应字面量类型，然后再组合成联合类型。注意，<strong>这里并不会将数字类型的键名转换为字符串类型字面量，而是仍然保持为数字类型字面量</strong>。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  linbudu<span class="token operator">:</span> <span class="token number">1</span>  <span class="token number">599</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">FooKeys</span> <span class="token operator">=</span> <span class="token keyword">keyof</span> Foo <span class="token comment">// "linbudu" | 599</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果觉得不太好理解，我们可以写段伪代码来模拟 <strong>“从键名到联合类型”</strong> 的过程。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">FooKeys</span> <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">" | "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>除了应用在已知的对象类型结构上以外，你还可以直接 <code>keyof any</code> 来生产一个联合类型，它会由所有可用作对象键值的类型组成：<code>string | number | symbol</code>。也就是说，它是由无数字面量类型组成的，由此我们可以知道， <strong>keyof 的产物必定是一个联合类型</strong>。</p><p>&gt;</p><h3 id="索引类型访问"><a href="#索引类型访问" class="headerlink" title="索引类型访问"></a>索引类型访问</h3><p>在 JavaScript 中我们可以通过 <code>obj[expression]</code> 的方式来动态访问一个对象属性（即计算属性），expression 表达式会先被执行，然后使用返回值来访问属性。而 TypeScript 中我们也可以通过类似的方式，只不过这里的 expression 要换成类型。接下来，我们来看个例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">NumberRecord</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">PropType</span> <span class="token operator">=</span> NumberRecord<span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span> <span class="token comment">// number</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，我们使用 string 这个类型来访问 NumberRecord。由于其内部声明了数字类型的索引签名，这里访问到的结果即是 number 类型。注意，其访问方式与返回值均是类型。</p><p>更直观的例子是通过字面量类型来进行索引类型访问：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  propA<span class="token operator">:</span> <span class="token builtin">number</span>  propB<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">PropAType</span> <span class="token operator">=</span> Foo<span class="token punctuation">[</span><span class="token string">'propA'</span><span class="token punctuation">]</span> <span class="token comment">// number</span><span class="token keyword">type</span> <span class="token class-name">PropBType</span> <span class="token operator">=</span> Foo<span class="token punctuation">[</span><span class="token string">'propB'</span><span class="token punctuation">]</span> <span class="token comment">// boolean</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看起来这里就是普通的值访问，但实际上这里的<code>&#39;propA&#39;</code>和<code>&#39;propB&#39;</code>都是<strong>字符串字面量类型</strong>，<strong>而不是一个 JavaScript 字符串值</strong>。索引类型查询的本质其实就是，<strong>通过键的字面量类型（<code>&#39;propA&#39;</code>）访问这个键对应的键值类型（<code>number</code>）</strong>。</p><p>看到这你肯定会想到，上面的 keyof 操作符能一次性获取这个对象所有的键的字面量类型，是否能用在这里？当然，这可是 TypeScript 啊。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  propA<span class="token operator">:</span> <span class="token builtin">number</span>  propB<span class="token operator">:</span> <span class="token builtin">boolean</span>  propC<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">PropTypeUnion</span> <span class="token operator">=</span> Foo<span class="token punctuation">[</span><span class="token keyword">keyof</span> Foo<span class="token punctuation">]</span> <span class="token comment">// string | number | boolean</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用字面量联合类型进行索引类型访问时，其结果就是将联合类型每个分支对应的类型进行访问后的结果，重新组装成联合类型。<strong>索引类型查询、索引类型访问通常会和映射类型一起搭配使用</strong>，前两者负责访问键，而映射类型在其基础上访问键值类型，我们在下面一个部分就会讲到。</p><p>注意，在未声明索引签名类型的情况下，我们不能使用 <code>NumberRecord[string]</code> 这种原始类型的访问方式，而只能通过键名的字面量类型来进行访问。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  propA<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token comment">// 类型“Foo”没有匹配的类型“string”的索引签名。</span><span class="token keyword">type</span> <span class="token class-name">PropAType</span> <span class="token operator">=</span> Foo<span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>索引类型的最佳拍档之一就是映射类型，同时映射类型也是类型编程中常用的一个手段。</p><h2 id="映射类型：类型编程的第一步"><a href="#映射类型：类型编程的第一步" class="headerlink" title="映射类型：类型编程的第一步"></a>映射类型：类型编程的第一步</h2><p>不同于索引类型包含好几个部分，映射类型指的就是一个确切的类型工具。看到映射这个词你应该能联想到 JavaScript 中数组的 map 方法，实际上也是如此，映射类型的主要作用即是<strong>基于键名映射到键值类型</strong>。概念不好理解，我们直接来看例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Stringify<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个工具类型会接受一个对象类型（假设我们只会这么用），使用 keyof 获得这个对象类型的键名组成字面量联合类型，然后通过映射类型（即这里的 in 关键字）将这个联合类型的每一个成员映射出来，并将其键值类型设置为 string。</p><p>具体使用的表现是这样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  prop1<span class="token operator">:</span> <span class="token builtin">string</span>  prop2<span class="token operator">:</span> <span class="token builtin">number</span>  prop3<span class="token operator">:</span> <span class="token builtin">boolean</span>  <span class="token function-variable function">prop4</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">StringifiedFoo</span> <span class="token operator">=</span> Stringify<span class="token operator">&lt;</span>Foo<span class="token operator">></span><span class="token comment">// 等价于</span><span class="token keyword">interface</span> <span class="token class-name">StringifiedFoo</span> <span class="token punctuation">&#123;</span>  prop1<span class="token operator">:</span> <span class="token builtin">string</span>  prop2<span class="token operator">:</span> <span class="token builtin">string</span>  prop3<span class="token operator">:</span> <span class="token builtin">string</span>  prop4<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还是可以用伪代码的形式进行说明：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> StringifiedFoo <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> k <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  StringifiedFoo<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>看起来好像很奇怪，我们应该很少会需要把一个接口的所有属性类型映射到 string？这有什么意义吗？别忘了，既然拿到了键，那键值类型其实也能拿到：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Clone<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的<code>T[K]</code>其实就是上面说到的索引类型访问，我们使用键的字面量类型访问到了键值的类型，这里就相当于克隆了一个接口。需要注意的是，这里其实只有<code>K in</code>属于映射类型的语法，<code>keyof T</code>属于 keyof 操作符，<code>[K in keyof T]</code>的<code>[]</code>属于索引签名类型，<code>T[K]</code>属于索引类型访问。</p><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>这一节，我们认识了类型工具中的类型别名、联合类型、索引类型以及映射类型。这些工具代表了类型工具中用于创建新类型的部分，但它们实现创建的方式却五花八门，以下这张表格概括了它们的实现方式与常见搭配</p><div class="table-container"><table><thead><tr><th>类型工具</th><th>创建新类型的方式</th><th>常见搭配</th></tr></thead><tbody><tr><td>类型别名</td><td>将一组类型/类型结构封装，作为一个新的类型</td><td>联合类型、映射类型</td></tr><tr><td>工具类型</td><td>在类型别名的基础上，基于泛型去动态创建新类型</td><td>基本所有类型工具</td></tr><tr><td>联合类型</td><td>创建一组类型集合，满足其中一个类型即满足这个联合类型（\</td><td>\</td><td>）</td><td>类型别名、工具类型</td></tr><tr><td>交叉类型</td><td>创建一组类型集合，满足其中所有类型才满足映射联合类型（&amp;&amp;）</td><td>类型别名、工具类型</td></tr><tr><td>索引签名类型</td><td>声明一个拥有任意属性，键值类型一致的接口结构</td><td>映射类型</td></tr><tr><td>索引类型查询</td><td>从一个接口结构，创建一个由其键名字符串字面量组成的联合类型</td><td>映射类型</td></tr><tr><td>索引类型访问</td><td>从一个接口结构，使用键名字符串字面量访问到对应的键值类型</td><td>类型别名、映射类型</td></tr><tr><td>映射类型</td><td>从一个联合类型依次映射到其内部的每一个类型</td><td>工具类型</td></tr><tr><td></td><td></td></tr></tbody></table></div><p>在下一节，我们会继续来介绍类型工具中的类型查询操作符 typeof 以及类型守卫，如果说这一节我们了解的工具主要是生产新的类型，那类型守卫就像是流水线的质量检查员一样，它可以帮助你的代码进一步提升类型安全性。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8.类型编程好帮手：TypeScript 类型工具（下）</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/8.%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E5%A5%BD%E5%B8%AE%E6%89%8B%EF%BC%9ATypeScript%20%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/8.%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E5%A5%BD%E5%B8%AE%E6%89%8B%EF%BC%9ATypeScript%20%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>上一节我们主要了解了类型别名、联合类型与交叉类型、索引类型与映射类型这几样类型工具。在大部分时候，这些类型工具的作用是<strong>基于已有的类型去创建出新的类型</strong>，即类型工具的重要作用之一。</p><p>而除了类型的创建以外，<strong>类型的安全保</strong>障同样属于类型工具的能力之一，我们本节要介绍的就是两个主要用于类型安全的类型工具：<strong>类型查询操作符</strong>与<strong>类型守卫</strong>。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F05_2-internal-type-tools">Internal Type Tools</a></p></blockquote><h2 id="类型查询操作符：熟悉又陌生的-typeof"><a href="#类型查询操作符：熟悉又陌生的-typeof" class="headerlink" title="类型查询操作符：熟悉又陌生的 typeof"></a>类型查询操作符：熟悉又陌生的 typeof</h2><p>TypeScript 存在两种功能不同的 typeof 操作符。我们最常见的一种 typeof 操作符就是 JavaScript 中，用于检查变量类型的 typeof ，它会返回 <code>&quot;string&quot;</code> / <code>&quot;number&quot;</code> / <code>&quot;object&quot;</code> / <code>&quot;undefined&quot;</code> 等值。而除此以外， TypeScript 还新增了用于类型查询的 typeof ，即 <strong>Type Query Operator</strong>，这个 typeof 返回的是一个 TypeScript 类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'linbudu'</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'linbudu'</span> <span class="token punctuation">&#125;</span><span class="token keyword">const</span> nullVar <span class="token operator">=</span> <span class="token keyword">null</span><span class="token keyword">const</span> undefinedVar <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token keyword">const</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> input<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">Str</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> str <span class="token comment">// "linbudu"</span><span class="token keyword">type</span> <span class="token class-name">Obj</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> obj <span class="token comment">// &#123; name: string; &#125;</span><span class="token keyword">type</span> <span class="token class-name">Null</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> nullVar <span class="token comment">// null</span><span class="token keyword">type</span> <span class="token class-name">Undefined</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> <span class="token keyword">undefined</span> <span class="token comment">// undefined</span><span class="token keyword">type</span> <span class="token class-name">Func</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> func <span class="token comment">// (input: string) => boolean</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你不仅可以直接在类型标注中使用 typeof，还能在工具类型中使用 typeof。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> input<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> func2<span class="token operator">:</span> <span class="token keyword">typeof</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> name <span class="token operator">===</span> <span class="token string">'linbudu'</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们暂时不用深入了解 ReturnType 这个工具类型，只需要知道它会返回一个函数类型中返回值位置的类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> input<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token comment">// boolean</span><span class="token keyword">type</span> <span class="token class-name">FuncReturnType</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token keyword">typeof</span> func<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>绝大部分情况下，typeof 返回的类型就是当你把鼠标悬浮在变量名上时出现的推导后的类型，并且是<strong>最窄的推导程度（即到字面量类型的级别）</strong>。你也不必担心混用了这两种 typeof，在逻辑代码中使用的 typeof 一定会是 JavaScript 中的 typeof，而类型代码（如类型标注、类型别名中等）中的一定是类型查询的 typeof 。同时，为了更好地避免这种情况，也就是隔离类型层和逻辑层，类型查询操作符后是不允许使用表达式的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token function-variable function">isInputValid</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> input<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 不允许表达式</span><span class="token keyword">let</span> isValid<span class="token operator">:</span> <span class="token keyword">typeof</span> <span class="token function">isInputValid</span><span class="token punctuation">(</span><span class="token string">"linbudu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类型守卫"><a href="#类型守卫" class="headerlink" title="类型守卫"></a>类型守卫</h2><p>TypeScript 中提供了非常强大的类型推导能力，它会随着你的代码逻辑不断尝试收窄类型，这一能力称之为<strong>类型的控制流分析</strong>（也可以简单理解为类型推导）。</p><p>这么说有点抽象，我们可以想象有一条河流，它从上而下流过你的程序，随着代码的分支分出一条条支流，在最后重新合并为一条完整的河流。在河流流动的过程中，如果遇到了有特定条件才能进入的河道（比如 if else 语句、switch case 语句等），那河流流过这里就会收集对应的信息，等到最后合并时，它们就会嚷着交流：<strong>“我刚刚流过了一个只有字符串类型才能进入的代码分支！”</strong> <strong>“我刚刚流过了一个只有函数类型才能进入的代码分支！”</strong>……就这样，它会把整个程序的类型信息都收集完毕。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> input <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> input <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们在 never 类型一节中学到的也是如此。在类型控制流分析下，每流过一个 if 分支，后续联合类型的分支就少了一个，因为这个类型已经在这个分支处理过了，不会进入下一个分支：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">const</span> strOrNumOrBool<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 一定是字符串！</span>  strOrNumOrBool<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 一定是数字！</span>  strOrNumOrBool<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">'boolean'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 一定是布尔值！</span>  strOrNumOrBool <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 要是走到这里就说明有问题！</span>  <span class="token keyword">const</span> _exhaustiveCheck<span class="token operator">:</span> <span class="token builtin">never</span> <span class="token operator">=</span> strOrNumOrBool  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Unknown input type: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>_exhaustiveCheck<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，我们实际上通过 if 条件中的表达式进行了类型保护，即告知了流过这里的分析程序每个 if 语句代码块中变量会是何类型。这即是编程语言的类型能力中最重要的一部分：<strong>与实际逻辑紧密关联的类型</strong>。我们从逻辑中进行类型地推导，再反过来让类型为逻辑保驾护航。</p><p>前面我们说到，类型控制流分析就像一条河流一样流过，那 if 条件中的表达式要是现在被提取出来了怎么办？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">isString</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">typeof</span> input <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isString</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 类型“string | number”上不存在属性“replace”。</span>    input<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token string">'linbudu599'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> input <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>奇怪的事情发生了，我们只是把逻辑提取到了外面而已，如果 isString 返回了 true，那 input 肯定也是 string 类型啊？</p><p>想象类型控制流分析这条河流，刚流进 <code>if (isString(input))</code> 就戛然而止了。因为 isString 这个函数在另外一个地方，内部的判断逻辑并不在函数 foo 中。这里的类型控制流分析做不到跨函数上下文来进行类型的信息收集（但别的类型语言中可能是支持的）。</p><p>实际上，将判断逻辑封装起来提取到函数外部进行复用非常常见。为了解决这一类型控制流分析的能力不足， TypeScript 引入了 <strong>is 关键字</strong>来显式地提供类型信息：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">isString</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> input <span class="token keyword">is</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">typeof</span> input <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isString</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 正确了</span>    input<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token string">'linbudu599'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> input <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>isString 函数称为类型守卫，在它的返回值中，我们不再使用 boolean 作为类型标注，而是使用 <code>input is string</code> 这么个奇怪的搭配，拆开来看它是这样的：</p><ul><li>input 函数的某个参数；</li><li><code>is string</code>，即 <strong>is 关键字 + 预期类型</strong>，即如果这个函数成功返回为 true，那么 is 关键字前这个入参的类型，就会<strong>被这个类型守卫调用方后续的类型控制流分析收集到</strong>。</li></ul><p>需要注意的是，类型守卫函数中并不会对判断逻辑和实际类型的关联进行检查：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">isString</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> input <span class="token keyword">is</span> <span class="token builtin">number</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">typeof</span> input <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isString</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 报错，在这里变成了 number 类型</span>    input<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token string">'linbudu599'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> input <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>从这个角度来看，其实类型守卫有些类似于类型断言，但类型守卫更宽容，也更信任你一些。你指定什么类型，它就是什么类型。</strong> 除了使用简单的原始类型以外，我们还可以在类型守卫中使用对象类型、联合类型等，比如下面我开发时常用的两个守卫：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Falsy</span> <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token operator">|</span> <span class="token string">''</span> <span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token keyword">export</span> <span class="token keyword">const</span> isFalsy <span class="token operator">=</span> <span class="token punctuation">(</span>val<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> val <span class="token keyword">is</span> Falsy <span class="token operator">=></span> <span class="token operator">!</span>val<span class="token comment">// 不包括不常用的 symbol 和 bigint</span><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Primitive</span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token keyword">export</span> <span class="token keyword">const</span> isPrimitive <span class="token operator">=</span> <span class="token punctuation">(</span>val<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> val <span class="token keyword">is</span> Primitive <span class="token operator">=></span>  <span class="token punctuation">[</span><span class="token string">'string'</span><span class="token punctuation">,</span> <span class="token string">'number'</span><span class="token punctuation">,</span> <span class="token string">'boolean'</span><span class="token punctuation">,</span> <span class="token string">'undefined'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> val<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了使用 typeof 以外，我们还可以使用许多类似的方式来进行类型保护，只要它能够在联合类型的类型成员中起到筛选作用。</p><h3 id="基于-in-与-instanceof-的类型保护"><a href="#基于-in-与-instanceof-的类型保护" class="headerlink" title="基于 in 与 instanceof 的类型保护"></a>基于 in 与 instanceof 的类型保护</h3><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fin"><code>in</code> 操作符</a> 并不是 TypeScript 中新增的概念，而是 JavaScript 中已有的部分，它可以通过 <code>key in object</code> 的方式来判断 key 是否存在于 object 或其原型链上（返回 true 说明存在）。</p><p>既然能起到区分作用，那么 TypeScript 中自然也可以用它来保护类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  foo<span class="token operator">:</span> <span class="token builtin">string</span>  fooOnly<span class="token operator">:</span> <span class="token builtin">boolean</span>  shared<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">Bar</span> <span class="token punctuation">&#123;</span>  bar<span class="token operator">:</span> <span class="token builtin">string</span>  barOnly<span class="token operator">:</span> <span class="token builtin">boolean</span>  shared<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span>input<span class="token operator">:</span> Foo <span class="token operator">|</span> Bar<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'foo'</span> <span class="token keyword">in</span> input<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    input<span class="token punctuation">.</span>fooOnly  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    input<span class="token punctuation">.</span>barOnly  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 foo / bar、fooOnly / barOnly、shared 属性们其实有着不同的意义。我们使用 foo 和 bar 来区分 input 联合类型，然后就可以在对应的分支代码块中正确访问到 Foo 和 Bar 独有的类型 fooOnly / barOnly。但是，如果用 shared 来区分，就会发现在分支代码块中 input 仍然是初始的联合类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span>input<span class="token operator">:</span> Foo <span class="token operator">|</span> Bar<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'shared'</span> <span class="token keyword">in</span> input<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 类型“Foo | Bar”上不存在属性“fooOnly”。类型“Bar”上不存在属性“fooOnly”。</span>    input<span class="token punctuation">.</span>fooOnly  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 类型“never”上不存在属性“barOnly”。</span>    input<span class="token punctuation">.</span>barOnly  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要注意的是，Foo 与 Bar 都满足 <code>&#39;shared&#39; in input</code> 这个条件。因此在 if 分支中， Foo 与 Bar 都会被保留，那在 else 分支中就只剩下 never 类型。</p><p>这个时候肯定有人想问，为什么 shared 不能用来区分？答案很明显，因为它同时存在两个类型中不具有辨识度。而 foo / bar 和 fooOnly / barOnly 是各个类型独有的属性，因此可以作为<strong>可辨识属性（Discriminant Property 或 Tagged Property）</strong>。Foo 与 Bar 又因为存在这样具有区分能力的辨识属性，可以称为<strong>可辨识联合类型（Discriminated Unions 或 Tagged Union）</strong>。虽然它们是一堆类型的联合体，但其中每一个类型都具有一个独一无二的，能让它鹤立鸡群的属性。</p><p>这个可辨识属性可以是结构层面的，比如结构 A 的属性 prop 是数组，而结构 B 的属性 prop 是对象，或者结构 A 中存在属性 prop 而结构 B 中不存在。</p><p>它甚至可以是共同属性的字面量类型差异：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">ensureArray</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> input  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>input<span class="token punctuation">]</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  kind<span class="token operator">:</span> <span class="token string">'foo'</span>  diffType<span class="token operator">:</span> <span class="token builtin">string</span>  fooOnly<span class="token operator">:</span> <span class="token builtin">boolean</span>  shared<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">Bar</span> <span class="token punctuation">&#123;</span>  kind<span class="token operator">:</span> <span class="token string">'bar'</span>  diffType<span class="token operator">:</span> <span class="token builtin">number</span>  barOnly<span class="token operator">:</span> <span class="token builtin">boolean</span>  shared<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">handle1</span><span class="token punctuation">(</span>input<span class="token operator">:</span> Foo <span class="token operator">|</span> Bar<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span>kind <span class="token operator">===</span> <span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    input<span class="token punctuation">.</span>fooOnly  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    input<span class="token punctuation">.</span>barOnly  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上例所示，对于同名但不同类型的属性，我们需要使用字面量类型的区分，并不能使用简单的 typeof：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">handle2</span><span class="token punctuation">(</span>input<span class="token operator">:</span> Foo <span class="token operator">|</span> Bar<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 报错，并没有起到区分的作用，在两个代码块中都是 Foo | Bar</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> input<span class="token punctuation">.</span>diffType <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    input<span class="token punctuation">.</span>fooOnly  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    input<span class="token punctuation">.</span>barOnly  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除此之外，JavaScript 中还存在一个功能类似于 typeof 与 in 的操作符：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Finstanceof">instanceof</a>，它判断的是原型级别的关系，如 <code>foo instanceof Base</code> 会沿着 foo 的原型链查找 <code>Base.prototype</code> 是否存在其上。当然，在 ES6 已经无处不在的今天，我们也可以简单地认为这是判断 foo 是否是 Base 类的实例。同样的，instanceof 也可以用来进行类型保护：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">FooBase</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">BarBase</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token keyword">extends</span> <span class="token class-name">FooBase</span> <span class="token punctuation">&#123;</span>  <span class="token function">fooOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token keyword">extends</span> <span class="token class-name">BarBase</span> <span class="token punctuation">&#123;</span>  <span class="token function">barOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span>input<span class="token operator">:</span> Foo <span class="token operator">|</span> Bar<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>input <span class="token keyword">instanceof</span> <span class="token class-name">FooBase</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    input<span class="token punctuation">.</span><span class="token function">fooOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    input<span class="token punctuation">.</span><span class="token function">barOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了使用 is 关键字的类型守卫以外，其实还存在使用 asserts 关键字的类型断言守卫。</p><h3 id="类型断言守卫"><a href="#类型断言守卫" class="headerlink" title="类型断言守卫"></a>类型断言守卫</h3><p>如果你写过测试用例或者使用过 NodeJs 的 assert 模块，那对断言这个概念应该不陌生：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> assert <span class="token keyword">from</span> <span class="token string">'assert'</span><span class="token keyword">let</span> name<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span><span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> name <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span><span class="token comment">// number 类型</span>name<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这段代码在运行时会抛出一个错误，因为 assert 接收到的表达式执行结果为 false。这其实也类似类型守卫的场景：如果断言<strong>不成立</strong>，比如在这里意味着值的类型不为 number，那么在断言下方的代码就执行不到（相当于 Dead Code）。如果断言通过了，不管你最开始是什么类型，断言后的代码中就<strong>一定是符合断言的类型</strong>，比如在这里就是 number。</p><p><strong>但断言守卫和类型守卫最大的不同点在于，在判断条件不通过时，断言守卫需要抛出一个错误，类型守卫只需要剔除掉预期的类型。</strong> 这里的抛出错误可能让你想到了 never 类型，但实际情况要更复杂一些，断言守卫并不会始终都抛出错误，所以它的返回值类型并不能简单地使用 never 类型。为此，TypeScript 3.7 版本专门引入了 asserts 关键字来进行断言场景下的类型守卫，比如前面 assert 方法的签名可以是这样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">assert</span><span class="token punctuation">(</span>condition<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> msg<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">asserts</span> condition <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>condition<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用的是 <code>asserts condition</code> ，而 condition 来自于实际逻辑！这也意味着，我们<strong>将 condition 这一逻辑层面的代码，作为了类型层面的判断依据</strong>，相当于在返回值类型中使用一个逻辑表达式进行了类型标注。</p><p>举例来说，对于 <code>assert(typeof name === &#39;number&#39;);</code> 这么一个断言，如果函数成功返回，就说明其后续的代码中 condition 均成立，也就是 name 神奇地变成了一个 number 类型。</p><p>这里的 condition 甚至还可以结合使用 is 关键字来提供进一步的类型守卫能力：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">let</span> name<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span><span class="token keyword">function</span> <span class="token function">assertIsNumber</span><span class="token punctuation">(</span>val<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">asserts</span> val <span class="token keyword">is</span> <span class="token builtin">number</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> val <span class="token operator">!==</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Not a number!'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">assertIsNumber</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token comment">// number 类型！</span>name<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下，你无需再为断言守卫传入一个表达式，而是可以将这个判断用的表达式放进断言守卫的内部，来获得更独立地代码逻辑。</p><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节，我们学习了一批新的类型工具，包括操作符 keyof、typeof，属于类型语法的交叉类型、索引类型（的三个部分）、映射类型、类型守卫等等。对这些工具的学习能够更好的帮助你更好的理解“类型编程”这个概念，即，原来对类型也是有这么多花样的！<strong>原来类型编程真是对类型进行编程</strong>！</p><p>在类型守卫部分，我们初次了解到了类型控制流分析的存在，以及使用类型保护、类型守卫来进行类型控制流的分析纠正等。同时，我们还学习了可辨识联合类型与可辨识属性的概念，想必以后你对如何处理联合类型会更有思路。</p><p>在下一节，我们就将开始学习泛型，它在许多语言中都是相当重要的类型能力。我们会了解泛型和类型别名的结合，以及它在接口、函数与 Class 中的作用，再到泛型约束、泛型默认值等概念，让你从此不再看到泛型就脑壳痛。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="接口的合并"><a href="#接口的合并" class="headerlink" title="接口的合并"></a>接口的合并</h3><p>在交叉类型一节中，你可能会注意到，接口和类型别名都能直接使用交叉类型。但除此以外，接口还能够使用继承进行合并，在继承时子接口可以声明同名属性，但并不能覆盖掉父接口中的此属性。<strong>子接口中的属性类型需要能够兼容（extends）父接口中的属性类型</strong>：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Struct1</span> <span class="token punctuation">&#123;</span>  primitiveProp<span class="token operator">:</span> <span class="token builtin">string</span>  objectProp<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token punctuation">&#125;</span>  unionProp<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token comment">// 接口“Struct2”错误扩展接口“Struct1”。</span><span class="token keyword">interface</span> <span class="token class-name">Struct2</span> <span class="token keyword">extends</span> <span class="token class-name">Struct1</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// “primitiveProp”的类型不兼容。不能将类型“number”分配给类型“string”。</span>  primitiveProp<span class="token operator">:</span> <span class="token builtin">number</span>  <span class="token comment">// 属性“objectProp”的类型不兼容。</span>  objectProp<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    age<span class="token operator">:</span> <span class="token builtin">number</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 属性“unionProp”的类型不兼容。</span>  <span class="token comment">// 不能将类型“boolean”分配给类型“string | number”。</span>  unionProp<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似的，如果你直接声明多个同名接口，虽然接口会进行合并，但这些同名属性的类型仍然需要兼容，此时的表现其实和显式扩展接口基本一致：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Struct1</span> <span class="token punctuation">&#123;</span>  primitiveProp<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">Struct1</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 后续属性声明必须属于同一类型。</span>  <span class="token comment">// 属性“primitiveProp”的类型必须为“string”，但此处却为类型“number”。</span>  primitiveProp<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这也是接口和类型别名的重要差异之一。</p><p>那么接口和类型别名之间的合并呢？其实规则一致，如接口<strong>继承</strong>类型别名，和类型别名使用交叉类型<strong>合并</strong>接口：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Base</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">IDerived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 报错！就像继承接口一样需要类型兼容</span>  name<span class="token operator">:</span> <span class="token builtin">number</span>  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">IBase</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token comment">// 合并后的 name 同样是 never 类型</span><span class="token keyword">type</span> <span class="token class-name">Derived</span> <span class="token operator">=</span> IBase <span class="token operator">&amp;</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="更强大的可辨识联合类型分析"><a href="#更强大的可辨识联合类型分析" class="headerlink" title="更强大的可辨识联合类型分析"></a>更强大的可辨识联合类型分析</h3><p>类型控制流分析其实是一直在不断增强的，在 4.5、4.6、4.7 版本中都有或多或少的场景增强。而这里说的增强，其实就包括了<strong>对可辨识联合类型的分析能力</strong>。比如下面这个例子在此前（4.6 版本以前）的 TypeScript 代码中会报错：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Args</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">type</span> <span class="token class-name">Func</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token keyword">const</span> f1<span class="token operator">:</span> <span class="token function-variable function">Func</span> <span class="token operator">=</span> <span class="token punctuation">(</span>kind<span class="token punctuation">,</span> payload<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>kind <span class="token operator">===</span> <span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 仍然是 string | number</span>    payload<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>kind <span class="token operator">===</span> <span class="token string">'b'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 仍然是 string | number</span>    payload<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而在 4.6 版本中则对这一情况下的 <strong>联合类型辨识（即元组）</strong> 做了支持。</p><p>如果你有兴趣了解 TypeScript 中的类型控制流分析以及更多可辨识联合类型的场景，可以阅读：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F461842201">TypeScript 中的类型控制流分析演进</a>。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9.类型编程基石：TypeScript 中无处不在的泛型</title>
      <link href="/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/9.%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%9F%B3%EF%BC%9ATypeScript%20%E4%B8%AD%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E7%9A%84%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/02/16/TS%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/9.%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%9F%B3%EF%BC%9ATypeScript%20%E4%B8%AD%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E7%9A%84%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>从这一节开始，我们正式进入到「类型编程进阶篇」的学习。能来到这里意味着你已经对 TypeScript 比较熟悉，甚至开始爱不释手了。但也意味着课程难度有所提升，知识变得更加复杂了。不过，你也不必担心，我会和你一起将思维调整到类型的频道，去认识这些类型世界的新朋友们！</p><p>如果说 TypeScript 是一门对类型进行编程的语言，那么泛型就是这门语言里的（函数）参数。这一节，我们就来了解 TypeScript 中无处不在的泛型，以及它在类型别名、对象类型、函数与 Class 中的使用方式。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F06-generic-types">Generic Types</a></p></blockquote><h2 id="类型别名中的泛型"><a href="#类型别名中的泛型" class="headerlink" title="类型别名中的泛型"></a>类型别名中的泛型</h2><p>在类型工具学习中，我们已经接触过类型别名中的泛型，比如类型别名如果声明了泛型坑位，那其实就等价于一个接受参数的函数：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Factory<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面这个类型别名的本质就是一个函数，T 就是它的变量，返回值则是一个包含 T 的联合类型，我们可以写段伪代码来加深一下记忆：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Factory</span><span class="token punctuation">(</span>typeArg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">[</span>typeArg<span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>类型别名中的泛型大多是用来进行工具类型封装，比如我们在上一节的映射类型中学习的工具类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Stringify<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">Clone<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Stringify 会将一个对象类型的所有属性类型置为 string ，而 Clone 则会进行类型的完全复制。我们可以提前看一个 TypeScript 的内置工具类型实现：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Partial<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>工具类型 Partial 会将传入的对象类型复制一份，但会额外添加一个<code>?</code>，还记得这代表什么吗？可选，也就是说现在我们获得了一个属性均为可选的山寨版：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">IFoo</span> <span class="token punctuation">&#123;</span>  prop1<span class="token operator">:</span> <span class="token builtin">string</span>  prop2<span class="token operator">:</span> <span class="token builtin">number</span>  prop3<span class="token operator">:</span> <span class="token builtin">boolean</span>  <span class="token function-variable function">prop4</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">PartialIFoo</span> <span class="token operator">=</span> Partial<span class="token operator">&lt;</span>IFoo<span class="token operator">></span><span class="token comment">// 等价于</span><span class="token keyword">interface</span> <span class="token class-name">PartialIFoo</span> <span class="token punctuation">&#123;</span>  prop1<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span>  prop2<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span>  prop3<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span>  prop4<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>内置工具类型地解析、扩展、进阶，在后面我们会一路升级打怪，完全地掌握它们。</p></blockquote><p>类型别名与泛型的结合中，除了映射类型、索引类型等类型工具以外，还有一个非常重要的工具：条件类型。我们先来简单了解一下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">IsEqual<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token boolean">true</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> IsEqual<span class="token operator">&lt;</span><span class="token boolean">true</span><span class="token operator">></span> <span class="token comment">// 1</span><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> IsEqual<span class="token operator">&lt;</span><span class="token boolean">false</span><span class="token operator">></span> <span class="token comment">// 2</span><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token operator">=</span> IsEqual<span class="token operator">&lt;</span><span class="token string">'linbudu'</span><span class="token operator">></span> <span class="token comment">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在条件类型参与的情况下，通常泛型会被作为条件类型中的判断条件（<code>T extends Condition</code>，或者 <code>Type extends T</code>）以及返回值（即 <code>:</code> 两端的值），这也是我们筛选类型需要依赖的能力之一。</p><h3 id="泛型约束与默认值"><a href="#泛型约束与默认值" class="headerlink" title="泛型约束与默认值"></a>泛型约束与默认值</h3><p>像函数可以声明一个参数的默认值一样，泛型同样有着默认值的设定，比如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Factory<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token builtin">boolean</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样在你调用时就可以不带任何参数了，默认会使用我们声明的默认值来填充。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> foo<span class="token operator">:</span> Factory <span class="token operator">=</span> <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再看个伪代码帮助理解：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Factory</span><span class="token punctuation">(</span>typeArg <span class="token operator">=</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">[</span>typeArg<span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>除了声明默认值以外，泛型还能做到一样函数参数做不到的事：<strong>泛型约束</strong>。也就是说，你可以要求传入这个工具类型的泛型必须符合某些条件，否则你就拒绝进行后面的逻辑。在函数中，我们只能在逻辑中处理：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>source<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> add<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> source <span class="token operator">!==</span> <span class="token string">'number'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> add <span class="token operator">!==</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Invalid arguments!'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> source <span class="token operator">+</span> add<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而在泛型中，我们可以使用 <code>extends</code> 关键字来约束传入的泛型参数必须符合要求。关于 extends，<code>A extends B</code> 意味着 <strong>A 是 B 的子类型</strong>，这里我们暂时只需要了解非常简单的判断逻辑，也就是说 A 比 B 的类型更精确，或者说更复杂。具体来说，可以分为以下几类。</p><ul><li>更精确，如<strong>字面量类型是对应原始类型的子类型</strong>，即 <code>&#39;linbudu&#39; extends string</code>，<code>599 extends number</code> 成立。类似的，<strong>联合类型子集均为联合类型的子类型</strong>，即 <code>1</code>、 <code>1 | 2</code> 是 <code>1 | 2 | 3 | 4</code> 的子类型。</li><li>更复杂，如 <code>&#123; name: string &#125;</code> 是 <code>&#123;&#125;</code> 的子类型，因为在 <code>&#123;&#125;</code> 的基础上增加了额外的类型，基类与派生类（父类与子类）同理。</li></ul><blockquote><p>关于 TypeScript 完整的类型层级，我们会在后面一节进行非常详细地说明。</p></blockquote><p>我们来看下面这个例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ResStatus<span class="token operator">&lt;</span>ResCode <span class="token keyword">extends</span> <span class="token builtin">number</span><span class="token operator">></span></span> <span class="token operator">=</span> ResCode <span class="token keyword">extends</span> <span class="token number">10000</span> <span class="token operator">|</span> <span class="token number">10001</span> <span class="token operator">|</span> <span class="token number">10002</span>  <span class="token operator">?</span> <span class="token string">'success'</span>  <span class="token operator">:</span> <span class="token string">'failure'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个例子会根据传入的请求码判断请求是否成功，这意味着它只能处理数字字面量类型的参数，因此这里我们通过 <code>extends number</code> 来标明其类型约束，如果传入一个不合法的值，就会出现类型错误：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ResStatus<span class="token operator">&lt;</span>ResCode <span class="token keyword">extends</span> <span class="token builtin">number</span><span class="token operator">></span></span> <span class="token operator">=</span> ResCode <span class="token keyword">extends</span> <span class="token number">10000</span> <span class="token operator">|</span> <span class="token number">10001</span> <span class="token operator">|</span> <span class="token number">10002</span>  <span class="token operator">?</span> <span class="token string">'success'</span>  <span class="token operator">:</span> <span class="token string">'failure'</span><span class="token keyword">type</span> <span class="token class-name">Res1</span> <span class="token operator">=</span> ResStatus<span class="token operator">&lt;</span><span class="token number">10000</span><span class="token operator">></span> <span class="token comment">// "success"</span><span class="token keyword">type</span> <span class="token class-name">Res2</span> <span class="token operator">=</span> ResStatus<span class="token operator">&lt;</span><span class="token number">20000</span><span class="token operator">></span> <span class="token comment">// "failure"</span><span class="token keyword">type</span> <span class="token class-name">Res3</span> <span class="token operator">=</span> ResStatus<span class="token operator">&lt;</span><span class="token string">'10000'</span><span class="token operator">></span> <span class="token comment">// 类型“string”不满足约束“number”。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与此同时，如果我们想让这个类型别名可以无需显式传入泛型参数也能调用，并且默认情况下是成功地，这样就可以为这个泛型参数声明一个默认值：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ResStatus<span class="token operator">&lt;</span>ResCode <span class="token keyword">extends</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">10000</span><span class="token operator">></span></span> <span class="token operator">=</span> ResCode <span class="token keyword">extends</span>  <span class="token operator">|</span> <span class="token number">10000</span>  <span class="token operator">|</span> <span class="token number">10001</span>  <span class="token operator">|</span> <span class="token number">10002</span>  <span class="token operator">?</span> <span class="token string">'success'</span>  <span class="token operator">:</span> <span class="token string">'failure'</span><span class="token keyword">type</span> <span class="token class-name">Res4</span> <span class="token operator">=</span> ResStatus <span class="token comment">// "success"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 TypeScript 中，泛型参数存在默认约束（在下面的函数泛型、Class 泛型中也是）。这个默认约束值在 TS 3.9 版本以前是 any，而在 3.9 版本以后则为 unknown。在 TypeScript ESLint 中，你可以使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftypescript-eslint%2Ftypescript-eslint%2Fblob%2Fmain%2Fpackages%2Feslint-plugin%2Fdocs%2Frules%2Fno-unnecessary-type-constraint.md"><strong>no-unnecessary-type-constraint</strong></a> 规则，来避免代码中声明了与默认约束相同的泛型约束。</p><h3 id="多泛型关联"><a href="#多泛型关联" class="headerlink" title="多泛型关联"></a>多泛型关联</h3><p>我们不仅可以同时传入多个泛型参数，还可以让这几个泛型参数之间也存在联系。我们可以先看一个简单的场景，条件类型下的多泛型参数：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Conditional<span class="token operator">&lt;</span>Type<span class="token punctuation">,</span> Condition<span class="token punctuation">,</span> TruthyResult<span class="token punctuation">,</span> FalsyResult<span class="token operator">></span></span> <span class="token operator">=</span>  Type <span class="token keyword">extends</span> <span class="token class-name">Condition</span> <span class="token operator">?</span> TruthyResult <span class="token operator">:</span> FalsyResult<span class="token comment">//  "passed!"</span><span class="token keyword">type</span> <span class="token class-name">Result1</span> <span class="token operator">=</span> Conditional<span class="token operator">&lt;</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token string">'passed!'</span><span class="token punctuation">,</span> <span class="token string">'rejected!'</span><span class="token operator">></span><span class="token comment">// "rejected!"</span><span class="token keyword">type</span> <span class="token class-name">Result2</span> <span class="token operator">=</span> Conditional<span class="token operator">&lt;</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token builtin">boolean</span><span class="token punctuation">,</span> <span class="token string">'passed!'</span><span class="token punctuation">,</span> <span class="token string">'rejected!'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子表明，<strong>多泛型参数其实就像接受更多参数的函数，其内部的运行逻辑（类型操作）会更加抽象，表现在参数（泛型参数）需要进行的逻辑运算（类型操作）会更加复杂。</strong></p><p>上面我们说，多个泛型参数之间的依赖，其实指的即是在后续泛型参数中，使用前面的泛型参数作为约束或默认值：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ProcessInput<span class="token operator">&lt;</span>  Input<span class="token punctuation">,</span>  SecondInput <span class="token keyword">extends</span> Input <span class="token operator">=</span> Input<span class="token punctuation">,</span>  ThirdInput <span class="token keyword">extends</span> Input <span class="token operator">=</span> SecondInput<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token builtin">number</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的内部类型操作并不是重点，我们直接忽略即可。从这个类型别名中你能获得哪些信息？</p><ul><li>这个工具类型接受 1-3 个泛型参数。</li><li>第二、三个泛型参数的类型需要是<strong>首个泛型参数的子类型</strong>。</li><li>当只传入一个泛型参数时，其第二个泛型参数会被赋值为此参数，而第三个则会赋值为第二个泛型参数，相当于<strong>均使用了这唯一传入的泛型参数</strong>。</li><li>当传入两个泛型参数时，第三个泛型参数<strong>会默认赋值为第二个泛型参数的值</strong>。</li></ul><p>多泛型关联在一些复杂的工具类型中非常常见，我们会在后续的内置类型讲解、内置类型进阶等章节中再实战，这里先了解即可。</p><h2 id="对象类型中的泛型"><a href="#对象类型中的泛型" class="headerlink" title="对象类型中的泛型"></a>对象类型中的泛型</h2><p>由于泛型提供了对类型结构的复用能力，我们也经常在对象类型结构中使用泛型。最常见的一个例子应该还是响应类型结构的泛型处理：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">IRes<span class="token operator">&lt;</span>TData <span class="token operator">=</span> <span class="token builtin">unknown</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span>  code<span class="token operator">:</span> <span class="token builtin">number</span>  error<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span>  data<span class="token operator">:</span> TData<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个接口描述了一个通用的响应类型结构，预留出了实际响应数据的泛型坑位，然后在你的请求函数中就可以传入特定的响应类型了：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">IUserProfileRes</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span>  homepage<span class="token operator">:</span> <span class="token builtin">string</span>  avatar<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">fetchUserProfile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>IRes<span class="token operator">&lt;</span>IUserProfileRes<span class="token operator">>></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">StatusSucceed</span> <span class="token operator">=</span> <span class="token builtin">boolean</span><span class="token keyword">function</span> <span class="token function">handleOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>IRes<span class="token operator">&lt;</span>StatusSucceed<span class="token operator">>></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而泛型嵌套的场景也非常常用，比如对存在分页结构的数据，我们也可以将其分页的响应结构抽离出来：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">IPaginationRes<span class="token operator">&lt;</span>TItem <span class="token operator">=</span> <span class="token builtin">unknown</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span>  data<span class="token operator">:</span> TItem<span class="token punctuation">[</span><span class="token punctuation">]</span>  page<span class="token operator">:</span> <span class="token builtin">number</span>  totalCount<span class="token operator">:</span> <span class="token builtin">number</span>  hasNextPage<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">fetchUserProfileList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>  IRes<span class="token operator">&lt;</span>IPaginationRes<span class="token operator">&lt;</span>IUserProfileRes<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些结构看起来很复杂，但其实就是<strong>简单的泛型参数填充</strong>而已。就像我们会封装请求库、请求响应拦截器一样，对请求中的参数、响应中的数据的类型的封装其实也不应该落下。甚至在理想情况下，这些结构体封装应该在请求库封装一层中就被处理掉。</p><p>直到目前为止，我们了解的泛型似乎就是一个类型别名的参数，它需要手动传入，可以设置类型层面约束和默认值，看起来似乎没有特别神奇的地方？</p><p>接下来，我们要来看看泛型的另一面，也是你实际上会打交道最频繁的一面：<strong>类型的自动提取</strong>。</p><h2 id="函数中的泛型"><a href="#函数中的泛型" class="headerlink" title="函数中的泛型"></a>函数中的泛型</h2><p>假设我们有这么一个函数，它可以接受多个类型的参数并进行对应处理，比如：</p><ul><li>对于字符串，返回部分截取；</li><li>对于数字，返回它的 n 倍；</li><li>对于对象，修改它的属性并返回。</li></ul><p>这个时候，我们要如何对函数进行类型声明？是 any 大法好？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还是用联合类型来包括所有可能类型？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一种我们肯定要直接 pass，第二种虽然麻烦了一点，但似乎可以满足需要？但如果我们真的调用一下就知道不合适了。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> shouldBeString <span class="token operator">=</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">)</span><span class="token keyword">const</span> shouldBeNumber <span class="token operator">=</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token number">599</span><span class="token punctuation">)</span><span class="token keyword">const</span> shouldBeObject <span class="token operator">=</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'linbudu'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>虽然我们约束了入参的类型，但返回值的类型并没有像我们预期的那样和入参关联起来，上面三个调用结果的类型仍然是一个宽泛的联合类型 <code>string | number | &#123;&#125;</code>。难道要用重载一个个声明可能的关联关系？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>天，如果再多一些复杂的情况，别说你愿不愿意补充每一种关联了，同事看到这样的代码都会质疑你的水平。这个时候，我们就该请出泛型了：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">handle</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们为函数声明了一个泛型参数 T，并将参数的类型与返回值类型指向这个泛型参数。这样，在这个函数接收到参数时，<strong>T 会自动地被填充为这个参数的类型</strong>。这也就意味着你不再需要预先确定参数的可能类型了，而<strong>在返回值与参数类型关联的情况下，也可以通过泛型参数来进行运算</strong>。</p><p>在基于参数类型进行填充泛型时，其类型信息会被推断到尽可能精确的程度，如这里会<strong>推导到字面量类型而不是基础类型</strong>。这是因为在直接传入一个值时，这个值是不会再被修改的，因此可以推导到最精确的程度。而如果你使用一个变量作为参数，那么只会使用这个变量标注的类型（在没有标注时，会使用推导出的类型）。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">handle</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> author <span class="token operator">=</span> <span class="token string">'linbudu'</span> <span class="token comment">// 使用 const 声明，被推导为 "linbudu"</span><span class="token keyword">let</span> authorAge <span class="token operator">=</span> <span class="token number">18</span> <span class="token comment">// 使用 let 声明，被推导为 number</span><span class="token function">handle</span><span class="token punctuation">(</span>author<span class="token punctuation">)</span> <span class="token comment">// 填充为字面量类型 "linbudu"</span><span class="token function">handle</span><span class="token punctuation">(</span>authorAge<span class="token punctuation">)</span> <span class="token comment">// 填充为基础类型 number</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你也可以将鼠标悬浮在表达式上，来查看填充的泛型信息：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0ee934c84ce4e8ab600bb47c22d29d5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>再看一个例子：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">swap</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">[</span>start<span class="token punctuation">,</span> end<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">[</span>end<span class="token punctuation">,</span> start<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> swapped1 <span class="token operator">=</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'linbudu'</span><span class="token punctuation">,</span> <span class="token number">599</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">const</span> swapped2 <span class="token operator">=</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">599</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">const</span> swapped3 <span class="token operator">=</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'linbudu'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里返回值类型对泛型参数进行了一些操作，而同样你可以看到其调用信息符合预期：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/251765b69571411eb607680aff6f7c5a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>函数中的泛型同样存在约束与默认值，比如上面的 handle 函数，现在我们希望做一些代码拆分，不再处理对象类型的情况了：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">handle</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而 swap 函数，现在我们只想处理数字元组的情况：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">swap</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token constant">U</span> <span class="token keyword">extends</span> <span class="token builtin">number</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">[</span>start<span class="token punctuation">,</span> end<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span>  <span class="token constant">U</span><span class="token punctuation">,</span>  <span class="token constant">T</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">[</span>end<span class="token punctuation">,</span> start<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而多泛型关联也是如此，比如 lodash 的 pick 函数，这个函数首先接受一个对象，然后接受一个对象属性名组成的数组，并从这个对象中截取选择的属性部分：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token punctuation">&#123;</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token string">'2'</span><span class="token punctuation">,</span> c<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span>_<span class="token punctuation">.</span><span class="token function">pick</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">// => &#123; 'a': 1, 'c': 3 &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数很明显需要在泛型层面声明关联，即数组中的元素只能来自于对象的属性名（组成的字面量联合类型！），因此我们可以这么写（部分简化）：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token generic-function"><span class="token function">pick</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span> <span class="token constant">U</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>object<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token operator">...</span>props<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token constant">U</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里 T 声明约束为对象类型，而 U 声明约束为 <code>keyof T</code>。同时对应的，其返回值类型中使用了 <code>Pick&lt;T, U&gt;</code> 这一工具类型，它与 pick 函数的作用一致，对一个对象结构进行裁剪，我们会在后面内置工具类型一节讲到。</p><p>函数的泛型参数也会被内部的逻辑消费，如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">handle</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>payload<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> rej<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token function">res</span><span class="token punctuation">(</span><span class="token punctuation">[</span>payload<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于箭头函数的泛型，其书写方式是这样的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> handle <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要注意的是在 tsx 文件中泛型的尖括号可能会造成报错，编译器无法识别这是一个组件还是一个泛型，此时你可以让它长得更像泛型一些：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> handle <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span><span class="token operator">></span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数的泛型是日常使用较多的一部分，更明显地体现了<strong>泛型在调用时被填充</strong>这一特性，而类型别名中，我们更多是手动传入泛型。这一差异的缘由其实就是它们的场景不同，我们通常使用类型别名来<strong>对已经确定的类型结构进行类型操作</strong>，比如将一组确定的类型放置在一起。而在函数这种场景中，我们并不能确定泛型在实际运行时会被什么样的类型填充。</p><p>需要注意的是，不要为了用泛型而用泛型，就像这样：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">handle</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#123;</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在这个函数中，泛型参数 T <strong>没有被返回值消费，也没有被内部的逻辑消费</strong>，这种情况下即使随着调用填充了泛型参数，也是没有意义的。因此这里你就完全可以用 any 来进行类型标注。</p><h2 id="Class-中的泛型"><a href="#Class-中的泛型" class="headerlink" title="Class 中的泛型"></a>Class 中的泛型</h2><p>Class 中的泛型和函数中的泛型非常类似，只不过函数中泛型参数的消费方是参数和返回值类型，Class 中的泛型消费方则是属性、方法、乃至装饰器等。同时 Class 内的方法还可以再声明自己独有的泛型参数。我们直接来看完整的示例：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Queue<span class="token operator">&lt;</span>TElementType<span class="token operator">></span></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> _list<span class="token operator">:</span> TElementType<span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>initial<span class="token operator">:</span> TElementType<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_list <span class="token operator">=</span> initial  <span class="token punctuation">&#125;</span>  <span class="token comment">// 入队一个队列泛型子类型的元素</span>  <span class="token generic-function"><span class="token function">enqueue</span><span class="token generic class-name"><span class="token operator">&lt;</span>TType <span class="token keyword">extends</span> TElementType<span class="token operator">></span></span></span><span class="token punctuation">(</span>ele<span class="token operator">:</span> TType<span class="token punctuation">)</span><span class="token operator">:</span> TElementType<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_list<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_list  <span class="token punctuation">&#125;</span>  <span class="token comment">// 入队一个任意类型元素（无需为队列泛型子类型）</span>  <span class="token generic-function"><span class="token function">enqueueWithUnknownType</span><span class="token generic class-name"><span class="token operator">&lt;</span>TType<span class="token operator">></span></span></span><span class="token punctuation">(</span>element<span class="token operator">:</span> TType<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">(</span>TElementType <span class="token operator">|</span> TType<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>_list<span class="token punctuation">,</span> element<span class="token punctuation">]</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 出队</span>  <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> TElementType<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_list<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_list  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，enqueue 方法的入参类型 TType 被约束为队列类型的子类型，而 enqueueWithUnknownType 方法中的 TType 类型参数则不会受此约束，它会在其被调用时再对应地填充，同时也会在返回值类型中被使用。</p><h3 id="内置方法中的泛型"><a href="#内置方法中的泛型" class="headerlink" title="内置方法中的泛型"></a>内置方法中的泛型</h3><p>TypeScript 中为非常多的内置对象都预留了泛型坑位，如 Promise 中</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">boolean</span><span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在你填充 Promise 的泛型以后，其内部的 resolve 方法也自动填充了泛型，而在 TypeScript 内部的 Promise 类型声明中同样是通过泛型实现：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">PromiseConstructor</span> <span class="token punctuation">&#123;</span>  <span class="token generic-function"><span class="token function">resolve</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">|</span> PromiseLike<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token keyword">declare</span> <span class="token keyword">var</span> <span class="token builtin">Promise</span><span class="token operator">:</span> PromiseConstructor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有数组 <code>Array&lt;T&gt;</code> 当中，其泛型参数代表数组的元素类型，几乎贯穿所有的数组方法：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> arr<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token comment">// 类型“string”的参数不能赋给类型“number”的参数。</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">)</span><span class="token comment">// 类型“string”的参数不能赋给类型“number”的参数。</span>arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">'linbudu'</span><span class="token punctuation">)</span><span class="token comment">// number | undefined</span>arr<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment">// 第一种 reduce</span>arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> curr<span class="token punctuation">,</span> idx<span class="token punctuation">,</span> arr<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> prev<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">// 第二种 reduce</span><span class="token comment">// 报错：不能将 number 类型的值赋值给 never 类型</span>arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> curr<span class="token punctuation">,</span> idx<span class="token punctuation">,</span> arr<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span>prev<span class="token punctuation">,</span> curr<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>reduce 方法是相对特殊的一个，它的类型声明存在几种不同的重载：</p><ul><li>当你不传入初始值时，泛型参数会从数组的元素类型中进行填充。</li><li>当你传入初始值时，如果初始值的类型与数组元素类型一致，则使用数组的元素类型进行填充。即这里第一个 reduce 调用。</li><li>当你传入一个非数组元素类型的初始值，比如这里的第二个 reduce 调用，reduce 的泛型参数会默认从这个初始值推导出的类型进行填充，如这里是 <code>never[]</code>。</li></ul><p>其中第三种情况也就意味着<strong>信息不足，无法推导出正确的类型</strong>，我们可以手动传入泛型参数来解决：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">arr<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">reduce</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> curr<span class="token punctuation">,</span> idx<span class="token punctuation">,</span> arr<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> prev<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在 React 中，我们同样可以找到无处不在的泛型坑位：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">// 不传入默认值，则类型为 number[] | undefined</span><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 体现在 ref.current 上</span><span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> context <span class="token operator">=</span> <span class="token generic-function"><span class="token function">createContext</span><span class="token generic class-name"><span class="token operator">&lt;</span>ContextType<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于 React 中的更多泛型坑位以及 TypeScript 结合使用，我们会在后面的实战一节进行详细讲解。</p><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节，我们学习了类型编程中的“函数参数”，感受到了泛型与类型别名一同使用时，真的就像一个接收输入再输出结果的函数一样，这样来看是不是泛型就好理解多了？但还没完，我们紧接着了解了泛型的本质：基于调用时类型推导来自动填充类型参数，从而让多个位置上的类型存在约束或关联，实现更严格的类型保护。</p><p>在下一节，我们会开始探秘 TypeScript 类型系统核心特性之一：结构化类型系统。你可能此前听说过它的别名“鸭子类型”，但还未深入地了解过，那么下一节我们就来学习这个有趣的类型特性。</p>]]></content>
      
      
      <categories>
          
          <category> TS全面进阶指南 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
